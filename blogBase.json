{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "Proacane\u7684\u4e2a\u4eba\u535a\u5ba2", "subTitle": "\u5b66\u65e0\u6b62\u5883", "avatarUrl": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "faviconUrl": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "GMEEK_VERSION": "last", "postListJson": {"P2": {"htmlDir": "docs/post/Asio-wang-luo-ku-zhai-yao.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Asio\u7f51\u7edc\u5e93\u6458\u8981", "postUrl": "post/Asio-wang-luo-ku-zhai-yao.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/2", "commentNum": 0, "wordCount": 23938, "description": "# \u5355\u7ebf\u7a0b\u901a\u4fe1\u6d41\u7a0b\r\n![image-20240726093453475](https://github.com/user-attachments/assets/a53c98fb-c149-403e-b102-d110905e5eb4)\r\n# \u540c\u6b65\u8bfb\u5199\u7684\u793a\u4f8b\r\n- \u670d\u52a1\u7aef\r\n```cpp\r\n#include <iostream>\r\n#include <boost/asio.hpp>\r\n#include <memory>\r\n#include <set>\r\n#include <thread>\r\n\r\nusing namespace std;\r\nusing namespace boost::asio::ip;\r\n\r\nconst int MAX_LEN = 1024;\r\ntypedef shared_ptr<tcp::socket> socket_ptr;\r\nstd::set<std::shared_ptr<std::thread>> thread_set;\r\n\r\nvoid session(socket_ptr sock) {\r\n    try {\r\n        for (;;) {\r\n            char data[MAX_LEN];\r\n            boost::system::error_code error;\r\n            // \u8bfb\u53d6\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u5185\u5bb9\r\n            size_t length = sock->read_some(boost::asio::buffer(data), error);\r\n\r\n            if (error == boost::asio::error::eof) {\r\n                std::cout << 'Connection closed by peer\\n';\r\n                break;\r\n            } else if (error) {\r\n                throw boost::system::system_error(error);\r\n            }\r\n\r\n            std::string received_message(data, length);\r\n            std::cout << 'Received from ' << sock->remote_endpoint().address().to_string() << ': ' << received_message << std::endl;\r\n\r\n            // \u8f6c\u6362\u4e3a \u5927\u5199\r\n            // Process the received message (e.g., convert to upper case)\r\n            std::transform(received_message.begin(), received_message.end(), received_message.begin(), ::toupper);\r\n            // \u518d\u5199\u56de\u5ba2\u6237\u7aef\r\n            boost::asio::write(*sock, boost::asio::buffer(received_message));\r\n        }\r\n    } catch (exception &e) {\r\n        std::cerr << 'Exception in thread: ' << e.what() << std::endl;\r\n    }\r\n}\r\n\r\n// \u5efa\u7acb\u8fde\u63a5\r\nvoid server(boost::asio::io_context &ios, unsigned short port_num) {\r\n    boost::asio::ip::tcp::acceptor acceptor(ios, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port_num));\r\n    std::cout << 'Server started on port ' << port_num << std::endl;\r\n    // \u6ca1\u8fde\u63a5\u5c31\u4e00\u76f4\u963b\u585e\r\n    for (;;) {\r\n        socket_ptr socket(new tcp::socket(ios));\r\n        acceptor.accept(*socket);\r\n        std::cout << 'Accepted connection from ' << socket->remote_endpoint().address().to_string() << std::endl;\r\n        // \u4e3a\u8fde\u63a5\u521b\u5efa\u4e00\u4e2a\u7ebf\u7a0b\uff0c\u5f00\u59cb\u901a\u4fe1\r\n        auto t = make_shared<std::thread>(session, socket);\r\n        thread_set.insert(t);\r\n    }\r\n}\r\n\r\nint main() {\r\n    try {\r\n        boost::asio::io_context ios;\r\n        server(ios, 1234);\r\n        // \u9632\u6b62\u6709\u6570\u636e\u672a\u4f20\u8f93\u5b8c\u65f6\uff0c\u4e3b\u7ebf\u7a0b\u5c31\u7ed3\u675f\u4e86\r\n        for (auto &t: thread_set) {\r\n            t->join();\r\n        }\r\n    } catch (exception &e) {\r\n        std::cerr << 'Exception in main thread: ' << e.what() << std::endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n# \u5f02\u6b65\u8bfb\u5199\u793a\u4f8b\r\n![image-20240726095026183](https://github.com/user-attachments/assets/bd621b55-b962-4eaf-9488-5bb8f7c47f79)\r\n## \u6ce8\u610f\u7684\u95ee\u9898\r\n\r\n- \u5f02\u5e38\u5904\u7406\u65f6\uff0c\u4e3a\u9632\u6b62 Session \u4e8c\u6b21\u6790\u6784\uff0c\u9700\u8981\u7ee7\u627f std::enable_shared_from_this<CSession>\uff1b\u4f7f\u7528\u667a\u80fd\u6307\u9488\u4e0e map \u5ef6\u957f Session \u7684\u751f\u547d\u5468\u671f\r\n\r\n- \u53d1\u9001\u6d88\u606f\u65f6\uff0c\u4e3a\u4fdd\u8bc1\u6d88\u606f\u7684\u6709\u5e8f\u6027\uff0c\u9700\u8981\u589e\u52a0\u53d1\u9001\u961f\u5217\r\n\r\n- \u5904\u7406\u7c98\u5305\u95ee\u9898\uff0c\u6d88\u606f\u7ed3\u6784\u91c7\u7528 TLV \u683c\u5f0f\uff0c\u4f7f\u7528 async_read_some \u6bd4\u8f83\u9ebb\u70e6\uff0c\u4f7f\u7528 async_read \u6bd4\u8f83\u7b80\u6d01\r\n\r\n  \u200b\t\t\t\t\t\t\t![image-20240726093831093](https://github.com/user-attachments/assets/45a3e63d-53d6-4124-b647-d9742bc9897e)\r\n\r\n  - async_read_some\uff1a\u56de\u8c03\u51fd\u6570\u91cc\u4e0d\u65ad\u5224\u65ad\u5df2\u7ecf\u5904\u7406\u7684\u5b57\u8282\r\n\r\n  - async_read\uff1a\u4e24\u5c42\u56de\u8c03\uff0c\u7b2c\u4e00\u5c42\u5904\u7406\u5305\u5934\uff0c\u7b2c\u4e8c\u5c42\u5904\u7406\u5305\u4f53\r\n\r\n- \u5b57\u8282\u5e8f\u7684\u5904\u7406\uff1a\u53d1\u9001\u524d\u8f6c\u6362\u4e3a\u7f51\u7edc\u5b57\u8282\u5e8f\uff0c\u63a5\u6536\u540e\u8f6c\u6362\u4e3a\u672c\u5730\u5b57\u8282\u5e8f (boost::asio::detail::socket_ops::network_to_host_short)\r\n- \u53d1\u9001\u6570\u636e\u4f7f\u7528jsoncpp\u8fdb\u884c\u5c01\u88c5\r\n\r\nCServer.h\r\n\r\n```cpp\r\n#ifndef ASYNCSERVER_CSERVER_H\r\n#define ASYNCSERVER_CSERVER_H\r\n#include 'CSession.h'\r\n#include <iostream>\r\nclass CSession;\r\n/**\r\n * \u63a5\u53d7\u65b0\u7684\u5ba2\u6237\u7aef\u8fde\u63a5\uff0c\u6bcf\u4e2a\u8fde\u63a5\u90fd\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Session \u5b9e\u4f8b\r\n */\r\nclass CServer {\r\npublic:\r\n    CServer(boost::asio::io_context &ioc, unsigned short port_num);\r\n    // \u79fb\u9664\u5df2\u5904\u7406\u5b8c\u6210\u7684 Session \u5b9e\u4f8b\r\n    void clear_session(std::string uuid);\r\nprivate:\r\n    // \u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Session \u5e76\u7b49\u5f85\u65b0\u7684\u5ba2\u6237\u7aef\u8fde\u63a5\r\n    void start_accept();\r\n    // \u5904\u7406\u65b0\u7684\u5ba2\u6237\u7aef\u8fde\u63a5\uff0c\u5c06\u5176\u52a0\u5165 _sessions \u4e2d\uff0c\u5e76\u542f\u52a8\u6570\u636e\u5904\u7406\r\n    void handle_accept(std::shared_ptr<CSession> newSession, const boost::system::error_code errorCode);\r\n\r\n    boost::asio::io_context &_ioc;\r\n    boost::asio::ip::tcp::acceptor _acceptor;\r\n    // \u7ba1\u7406\u8fde\u63a5\r\n    std::map<std::string, std::shared_ptr<CSession>> _sessions;\r\n\r\n};\r\n#endif //ASYNCSERVER_CSERVER_H\r\n```\r\n\r\nCServer.cpp\r\n\r\n```cpp\r\n#include 'CServer.h'\r\n\r\nCServer::CServer(boost::asio::io_context &ioc, unsigned short port_num) : _ioc(ioc),\r\n                                                                          _acceptor(_ioc,\r\n                                                                                    tcp::endpoint(tcp::v4(),\r\n                                                                                                  port_num)) {\r\n    std::cout << 'Acceptor create succeed! port number is ' << port_num << std::endl;\r\n    start_accept();\r\n}\r\n\r\nvoid CServer::start_accept() {\r\n    // \u4f7f\u7528\u667a\u80fd\u6307\u9488\u6765\u7ba1\u7406 session \u5b9e\u4f8b\uff0c\u4ee5\u4fdd\u8bc1\u4e0d\u4f1a\u4e8c\u6b21\u6790\u6784\r\n    std::shared_ptr<CSession> newSession = std::make_shared<CSession>(_ioc, this);\r\n    // \u7ed1\u5b9a\u5230\u670d\u52a1\u4e0a\uff0c\u65b0\u8fde\u63a5\u5230\u6765\u540e\u89e6\u53d1\u56de\u8c03\u51fd\u6570 handle_accept\r\n    _acceptor.async_accept(newSession->get_socket(),\r\n                           std::bind(&CServer::handle_accept, this, newSession, std::placeholders::_1));\r\n\r\n}\r\n\r\nvoid CServer::handle_accept(std::shared_ptr<CSession> newSession, const boost::system::error_code errorCode) {\r\n    if (errorCode.value() != 0) {\r\n        std::cerr << 'Error occurred int accept connection: ' << errorCode.message() << std::endl;\r\n//        delete newSession;\r\n    } else {\r\n        std::cout << 'Accept connection successfully ' << std::endl;\r\n        std::cout << 'Start dealing with data' << std::endl;\r\n        // \u6ca1\u95ee\u9898\u5c31\u5f00\u59cb\u5904\u7406\u6570\u636e\r\n        newSession->start();\r\n        _sessions.insert(std::make_pair(newSession->get_uuid(), newSession));\r\n    }\r\n    // \u7ee7\u7eed\u63a5\u6536\u65b0\u8fde\u63a5\r\n    start_accept();\r\n}\r\n\r\nvoid CServer::clear_session(std::string uuid) {\r\n    _sessions.erase(uuid);\r\n}\r\n```\r\n\r\nCSession.h\r\n\r\n```cpp\r\n#ifndef ASYNCSERVER_CSESSION_H\r\n#define ASYNCSERVER_CSESSION_H\r\n\r\n#include <boost/asio.hpp>\r\n#include <string>\r\n#include <map>\r\n#include <boost/uuid/uuid_generators.hpp>\r\n#include <boost/uuid/uuid_io.hpp>\r\n#include 'CServer.h'\r\n#include <queue>\r\n#include 'global.h'\r\nusing namespace boost::asio::ip;\r\n\r\nclass MsgNode;\r\n\r\nclass CServer;\r\n\r\n/**\r\n * \u5904\u7406\u5ba2\u6237\u7aef\u6d88\u606f\u6536\u53d1\r\n */\r\nclass CSession : public std::enable_shared_from_this<CSession> {\r\npublic:\r\n    tcp::socket &get_socket() { return _socket; };\r\n\r\n    explicit CSession(boost::asio::io_context &ioc, CServer *server);;\r\n\r\n    // \u5f00\u59cb\u5904\u7406\r\n    void start();\r\n\r\n    // \u83b7\u53d6 uuid\r\n    std::string &get_uuid() {\r\n        return _uuid;\r\n    }\r\n\r\n    /**\r\n     * \u53d1\u9001\u63a5\u53e3\r\n     * @param msg\r\n     * @param max_length\r\n     */\r\n    void send(char *msg, int max_length);\r\n\r\n    void send(std::string msg);\r\nprivate:\r\n    // \u5199\u7684\u56de\u8c03\u51fd\u6570\r\n    void handle_write(const boost::system::error_code &errorCode, std::shared_ptr<CSession> self_shared);\r\n\r\n    // \u8bfb\u7684\u56de\u8c03\u51fd\u6570\r\n    void handle_read(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                     std::shared_ptr<CSession> self_shared);\r\n\r\n    /**\r\n     * \u8bfb\u53d6\u5305\u5934\u7684\u56de\u8c03\u51fd\u6570\r\n     * @param errorCode\r\n     * @param bytes_transferred\r\n     * @param self_shared\r\n     */\r\n    void handle_read_head(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                          std::shared_ptr<CSession> self_shared);\r\n\r\n    /**\r\n     * \u8bfb\u53d6\u5305\u4f53\u7684\u56de\u8c03\u51fd\u6570\r\n     * @param errorCode\r\n     * @param bytes_transferred\r\n     * @param self_shared\r\n     */\r\n    void handle_read_msg(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                          std::shared_ptr<CSession> self_shared);\r\n    // \u6253\u5370\u6536\u5230\u7684\u4e8c\u8fdb\u5236\u6570\u636e\r\n    void printRecvData(char* data, int length);\r\n    // \u4f20\u8f93\u4fe1\u606f\u7684 socket\r\n    tcp::socket _socket;\r\n    // \u4fdd\u5b58\u6570\u636e\r\n\r\n    char _data[MAX_LENGTH];\r\n    // \u96b6\u5c5e\u4e8e\u54ea\u4e2a server\r\n    CServer *_server;\r\n    // uuid\r\n    std::string _uuid;\r\n    // \u53d1\u9001\u961f\u5217\r\n    std::queue<std::shared_ptr<MsgNode>> _send_que;\r\n    // \u4e92\u65a5\u9501\uff0c\u9632\u6b62\u591a\u4e2a\u7ebf\u7a0b\u540c\u65f6\u64cd\u4f5c\u961f\u5217\r\n    std::mutex _send_lock;\r\n\r\n    //\u6536\u5230\u7684\u6d88\u606f\u7ed3\u6784\r\n    std::shared_ptr<MsgNode> _recv_msg_node;\r\n    // \u6807\u8bb0\u5934\u90e8\u7ed3\u6784\u662f\u5426\u63a5\u6536\u5b8c\u6bd5\r\n    bool _b_head_parse;\r\n    //\u6536\u5230\u7684\u5934\u90e8\u7ed3\u6784\r\n    std::shared_ptr<MsgNode> _recv_head_node;\r\n};\r\n\r\n/**\r\n * \u6d88\u606f\u7ed3\u70b9\r\n */\r\nclass MsgNode {\r\n    friend class CSession;\r\n\r\npublic:\r\n    MsgNode(const char *msg, short max_len) : _total_len(max_len + HEAD_LENGTH), _cur_len(0) {\r\n        _data = new char[_total_len + 1];\r\n        // \u5305\u5934\u5b57\u8282\u5e8f\u8f6c\u6362\r\n        int max_len_host = boost::asio::detail::socket_ops::host_to_network_short(max_len);\r\n        // \u8bb0\u5f55\u957f\u5ea6\r\n        memcpy(_data, &max_len_host, HEAD_LENGTH);\r\n        // \u62f7\u8d1d\u6570\u636e\r\n        memcpy(_data + HEAD_LENGTH, msg, max_len);\r\n        _data[_total_len] = '\\0';\r\n    }\r\n\r\n    MsgNode(short max_len) : _total_len(max_len), _cur_len(0) {\r\n        _data = new char[_total_len + 1];\r\n    }\r\n\r\n    void clear() {\r\n        memset(_data, 0, _total_len);\r\n        _cur_len = 0;\r\n    }\r\n\r\n    ~MsgNode() {\r\n        delete[] _data;\r\n    }\r\n\r\nprivate:\r\n    int _cur_len;\r\n    int _total_len;\r\n    char *_data;\r\n};\r\n\r\n#endif //ASYNCSERVER_CSESSION_H\r\n```\r\n\r\nCSession.cpp\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <thread>\r\n#include 'CSession.h'\r\n#include 'proto/msg.pb.h'\r\n#include <json/json.h>\r\n#include <json/value.h>\r\n#include <json/reader.h>\r\n\r\nCSession::CSession(boost::asio::io_context &ioc, CServer *server) : _socket(ioc), _server(server),\r\n                                                                    _b_head_parse(false) {\r\n    std::memset(_data, '\\0', MAX_LENGTH);\r\n    // \u751f\u6210 uuid\r\n    boost::uuids::uuid a_uuid = boost::uuids::random_generator()();\r\n    _uuid = boost::uuids::to_string(a_uuid);\r\n    _recv_head_node = std::make_shared<MsgNode>(HEAD_LENGTH);\r\n}\r\n\r\nvoid CSession::start() {\r\n    std::cout << 'First read from client\\n';\r\n    // \u5148\u5728\u5ba2\u6237\u7aef\u8bfb\u53d6\r\n//    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n//                            std::bind(&CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2,\r\n//                                      shared_from_this()));\r\n    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node->_data, HEAD_LENGTH),\r\n                            std::bind(&CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,\r\n                                      shared_from_this()));\r\n}\r\n\r\nvoid CSession::handle_read(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                           std::shared_ptr<CSession> self_shared) {\r\n    try {\r\n        if (errorCode.value() != 0) {\r\n            std::cerr << 'Error occurred int read: ' << errorCode.message() << std::endl;\r\n            // \u79fb\u9664\u8fde\u63a5\r\n            _server->clear_session(_uuid);\r\n            return;\r\n        }\r\n        // \u6d4b\u8bd5\u7c98\u5305\r\n        printRecvData(_data, bytes_transferred);\r\n        std::chrono::milliseconds dura(2000);\r\n        std::this_thread::sleep_for(dura);\r\n\r\n        while (bytes_transferred > 0) {\r\n            // \u8bb0\u5f55\u5df2\u7ecf\u5904\u7406\u7684\u5b57\u8282\r\n            int copy_len = 0;\r\n            if (!_b_head_parse) {\r\n                // \u5934\u90e8\u7ed3\u6784\u8fd8\u6ca1\u5904\u7406\u5b8c\r\n                // \u6536\u5230\u7684\u6570\u636e\u6bd4\u5934\u90e8\u7ed3\u6784\u5c0f\r\n                if (bytes_transferred < HEAD_LENGTH) {\r\n                    // \u5148\u63a5\u6536\u8fd9\u90e8\u5206\u6570\u636e\r\n                    memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, bytes_transferred);\r\n                    _recv_head_node->_cur_len += bytes_transferred;\r\n                    // \u6e05\u7a7a _data \u7f13\u51b2\u533a\r\n                    memset(_data, 0, MAX_LENGTH);\r\n                    // \u7ee7\u7eed\u76d1\u542c\r\n                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                            std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                      std::placeholders::_2, self_shared));\r\n                    return;\r\n                }\r\n                // \u6536\u5230\u7684\u6570\u636e\u6bd4\u5934\u90e8\u7ed3\u6784\u5927\r\n                int head_remain = HEAD_LENGTH - _recv_head_node->_cur_len;\r\n                // \u5269\u4f59\u7684\u6570\u636e\u62f7\u8d1d\u8fdb\u53bb\r\n                memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, head_remain);\r\n                _recv_head_node->_cur_len += head_remain;\r\n                copy_len += head_remain;\r\n                bytes_transferred -= head_remain;\r\n                // \u83b7\u53d6\u5934\u90e8\u5b58\u50a8\u7684\u6570\u636e\r\n                short data_len = 0;\r\n                memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);\r\n                // \u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u6362\u4e3a\u672c\u5730\u5b57\u8282\u5e8f\r\n                data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);\r\n\r\n                std::cout << 'Receive data length is ' << data_len << std::endl;\r\n                if (data_len > MAX_LENGTH) {\r\n                    std::cerr << 'invalid data length is ' << data_len << std::endl;\r\n                    return;\r\n                }\r\n\r\n                _recv_msg_node = std::make_shared<MsgNode>(data_len);\r\n                // \u5269\u4f59\u6d88\u606f\u7684\u957f\u5ea6\u5c0f\u4e8e\u6570\u636e\u957f\u5ea6\uff0c\u5148\u5c06\u90e8\u5206\u6570\u636e\u653e\u5230\u8282\u70b9\u91cc\r\n                if (bytes_transferred < data_len) {\r\n                    memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);\r\n                    _recv_msg_node->_cur_len += bytes_transferred;\r\n                    // \u91cd\u7f6e _data\r\n                    memset(_data, 0, MAX_LENGTH);\r\n                    // \u7ee7\u7eed\u76d1\u542c\r\n                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                            std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                      std::placeholders::_2, self_shared));\r\n                    // \u5934\u90e8\u5904\u7406\u5b8c\u6bd5\r\n                    _b_head_parse = true;\r\n                    return;\r\n                }\r\n                // \u5927\u4e8e\u76f4\u63a5\u62f7\u8d1d\u8fdb\u53bb\r\n                memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, data_len);\r\n                _recv_msg_node->_cur_len += data_len;\r\n                copy_len += data_len;\r\n                bytes_transferred -= data_len;\r\n                _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\r\n                // \u8c03\u7528 send \u6d4b\u8bd5\r\n//                MsgData msgData;\r\n//                std::string receive_data;\r\n//                msgData.ParseFromString(std::string(_recv_msg_node->_data,_recv_msg_node->_total_len));\r\n//                std::cout << 'Received msg id  is ' << msgData.id() << ' msg data is ' << msgData.data() <<std:: endl;\r\n//                std::string return_str = 'Server has received msg, msg data is ' + msgData.data();\r\n//                MsgData msgReturn;\r\n//                msgReturn.set_id(msgData.id());\r\n//                msgReturn.set_data(return_str);\r\n//                msgReturn.SerializeToString(&return_str);\r\n//                send(return_str);\r\n//                Json::Reader reader;\r\n//                Json::Value root;\r\n//                reader.parse(std::string(_recv_msg_node->_data, _recv_msg_node->_total_len), root);\r\n//                std::cout << 'Received msg id  is ' << root['id'].asInt() << ' msg data is ''\r\n//                          << root['data'].asString() << ''' << std::endl;\r\n//                root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';\r\n//                send(root.toStyledString());\r\n                send(_recv_msg_node->_data,_recv_msg_node->_total_len);\r\n                // \u7ee7\u7eed\u5904\u7406\u5269\u4e0b\u7684\u5b57\u8282\r\n                _b_head_parse = false;\r\n                _recv_head_node->clear();\r\n                // \u5982\u679c\u5c0f\u4e8e\u7b49\u4e8e0\uff0c\u5176\u5b9e\u53ea\u80fd\u7b49\u4e8e\r\n                if (bytes_transferred <= 0) {\r\n                    // \u9700\u8981\u7ee7\u7eed\u76d1\u542c\r\n                    memset(_data, 0, MAX_LENGTH);\r\n                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                            std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                      std::placeholders::_2, self_shared));\r\n                    return;\r\n                }\r\n                // \u7ee7\u7eed\u5faa\u73af\u5373\u53ef\r\n                continue;\r\n            }\r\n            // \u5934\u7ed3\u70b9\u5904\u7406\u5b8c\u4e86\uff0c\u63a5\u7740\u5904\u7406\u6570\u636e\r\n            int remain_msg = _recv_msg_node->_total_len - _recv_msg_node->_cur_len;\r\n            // \u672c\u6b21\u63a5\u6536\u7684\u8fd8\u662f\u4e0d\u8db3\r\n            if (bytes_transferred < remain_msg) {\r\n                // \u62f7\u8d1d\u90e8\u5206\uff0c\u7ee7\u7eed\u76d1\u542c\r\n                memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);\r\n                _recv_msg_node->_cur_len += bytes_transferred;\r\n                memset(_data, 0, MAX_LENGTH);\r\n                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                        std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                  std::placeholders::_2, self_shared));\r\n                return;\r\n            }\r\n            // \u8db3\u591f\u5c31\u76f4\u63a5\u62f7\u8fdb\u6765\r\n            memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, remain_msg);\r\n            _recv_msg_node->_cur_len += remain_msg;\r\n            copy_len += remain_msg;\r\n            bytes_transferred -= remain_msg;\r\n            _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\r\n            // \u8c03\u7528 send \u6d4b\u8bd5\r\n//            MsgData msgData;\r\n//            std::string receive_data;\r\n//            msgData.ParseFromString(std::string(_recv_msg_node->_data,_recv_msg_node->_total_len));\r\n//            std::cout << 'Received msg id  is ' << msgData.id() << ' msg data is ' << msgData.data() <<std:: endl;\r\n//            std::string return_str = 'Server has received msg, msg data is ' + msgData.data();\r\n//            MsgData msgReturn;\r\n//            msgReturn.set_id(msgData.id());\r\n//            msgReturn.set_data(return_str);\r\n//            msgReturn.SerializeToString(&return_str);\r\n//            send(return_str);\r\n\r\n//            Json::Reader reader;\r\n//            Json::Value root;\r\n//            reader.parse(std::string(_recv_msg_node->_data, _recv_msg_node->_total_len), root);\r\n//            std::cout << 'Received msg id  is ' << root['id'].asInt() << ' msg data is ''\r\n//                      << root['data'].asString() << ''' << std::endl;\r\n//            root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';\r\n//            send(root.toStyledString());\r\n            send(_recv_msg_node->_data,_recv_msg_node->_total_len);\r\n\r\n            // \u7ee7\u7eed\u5904\u7406\r\n            _b_head_parse = false;\r\n            _recv_head_node->clear();\r\n\r\n            // \u4e0d\u5269\u4e0b\u6570\u636e\u4e86\r\n            if (bytes_transferred <= 0) {\r\n                memset(_data, 0, MAX_LENGTH);\r\n                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                        std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                  std::placeholders::_2, self_shared));\r\n                return;\r\n            }\r\n            // \u7ee7\u7eed\u5faa\u73af\u5373\u53ef\r\n            continue;\r\n        }\r\n    } catch (std::exception &e) {\r\n        std::cerr << 'Error occurred: ' << e.what() << std::endl;\r\n    }\r\n}\r\n\r\nvoid CSession::handle_write(const boost::system::error_code &errorCode, std::shared_ptr<CSession> self_shared) {\r\n    try {\r\n        if (errorCode.value() != 0) {\r\n            std::cerr << 'Error occurred int write: ' << errorCode.message() << std::endl;\r\n            // \u79fb\u9664\u8fde\u63a5\r\n            _server->clear_session(_uuid);\r\n            return;\r\n        }\r\n        std::cout << 'Writing to client successfully, start read from client\\n';\r\n\r\n        // \u8c03\u7528\u56de\u8c03\u51fd\u6570\u8868\u793a\u5df2\u7ecf\u5199\u5b8c\r\n        // \u4e0a\u9501\r\n        std::lock_guard<std::mutex> lock(_send_lock);\r\n        // \u5f39\u51fa\u961f\u5217\u5143\u7d20\r\n        _send_que.pop();\r\n        // \u961f\u5217\u662f\u5426\u8fd8\u6709\u5269\u4e0b\u7684\u6d88\u606f\r\n        if (!_send_que.empty()) {\r\n            // \u63a5\u7740\u53d1\uff0c\u76f4\u5230\u961f\u5217\u4e3a\u7a7a\r\n            auto &msgNode = _send_que.front();\r\n            boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\r\n                                     std::bind(&CSession::handle_write, this, std::placeholders::_1, self_shared));\r\n        }\r\n    } catch (std::exception &e) {\r\n        std::cerr << 'Error occurred: ' << e.what() << std::endl;\r\n    }\r\n}\r\n\r\nvoid CSession::send(char *msg, int max_length) {\r\n    // \u53d1\u9001\u961f\u5217\u91cc\u662f\u5426\u8fd8\u6709\u6ca1\u6cd5\u5b8c\u7684\u6570\u636e\r\n    bool pending = false;\r\n    // \u4e0a\u9501\r\n    std::lock_guard<std::mutex> lock(_send_lock);\r\n    int send_que_size = _send_que.size();\r\n    if (send_que_size > MAX_SENDQUE) {\r\n        std::cout << 'session: ' << _uuid << ' send que fulled, size is ' << MAX_SENDQUE << std::endl;\r\n        return;\r\n    }\r\n\r\n    // \u52a0\u5165\u53d1\u9001\u961f\u5217\r\n    _send_que.push(std::make_shared<MsgNode>(msg, max_length));\r\n\r\n    if (send_que_size > 0) {\r\n        // \u4e4b\u524d\u7684\u8fd8\u6ca1\u53d1\u9001\u5b8c\r\n        return;\r\n    }\r\n    auto &msgNode = _send_que.front();\r\n    // \u4e4b\u524d\u7684\u5168\u53d1\u5b8c\u4e86\uff0c\u76f4\u63a5\u53d1\u672c\u6b21\u7684\r\n    boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\r\n                             std::bind(&CSession::handle_write, this, std::placeholders::_1, shared_from_this()));\r\n}\r\n\r\n// \u6253\u5370\u4e8c\u8fdb\u5236\u6570\u636e\r\nvoid CSession::printRecvData(char *data, int length) {\r\n    std::stringstream ss;\r\n    std::string result = '0x';\r\n    for (int i = 0; i < length; i++) {\r\n        std::string hexstr;\r\n        ss << std::hex << std::setw(2) << std::setfill('0') << int(data[i]) << std::endl;\r\n        ss >> hexstr;\r\n        result += hexstr;\r\n    }\r\n    std::cout << 'receive raw data is : ' << result << std::endl;;\r\n}\r\n\r\nvoid CSession::send(std::string msg) {\r\n    std::lock_guard<std::mutex> lock(_send_lock);\r\n\r\n    int send_que_size = _send_que.size();\r\n    if (send_que_size > MAX_SENDQUE) {\r\n        std::cout << 'session: ' << _uuid << ' send que fulled, size is ' << MAX_SENDQUE << std::endl;\r\n        return;\r\n    }\r\n    _send_que.push(std::make_shared<MsgNode>(msg.c_str(), msg.size()));\r\n    if (send_que_size > 0) {\r\n        return;\r\n    }\r\n    auto &msgNode = _send_que.front();\r\n    boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\r\n                             std::bind(&CSession::handle_write, this, std::placeholders::_1, shared_from_this()));\r\n}\r\n\r\nvoid CSession::handle_read_head(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                                std::shared_ptr<CSession> self_shared) {\r\n    if (errorCode.value() != 0) {\r\n        std::cerr << 'Error occurred in read head: ' << errorCode.message() << std::endl;\r\n        // \u79fb\u9664\u8fde\u63a5\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n    if (bytes_transferred < HEAD_LENGTH) {\r\n        std::cerr << 'Error occurred in read head: ' << errorCode.message() << std::endl;\r\n        // \u79fb\u9664\u8fde\u63a5\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n    // \u89e3\u6790\u5305\u5934\u6570\u636e\r\n    short data_len = 0;\r\n    memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);\r\n    // \u5b57\u8282\u5e8f\u5904\u7406\r\n    data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);\r\n    if (data_len > MAX_LENGTH) {\r\n        std::cerr << 'Invalid data length :' << data_len << std::endl;\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n\r\n\r\n    _recv_msg_node = std::make_shared<MsgNode>(data_len);\r\n\r\n    boost::asio::async_read(_socket, boost::asio::buffer(_recv_msg_node->_data, _recv_msg_node->_total_len),\r\n                            std::bind(&CSession::handle_read_msg, this, std::placeholders::_1, std::placeholders::_2,\r\n                                      shared_from_this()));\r\n}\r\n\r\nvoid CSession::handle_read_msg(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                               std::shared_ptr<CSession> self_shared) {\r\n    if (errorCode.value() != 0) {\r\n        std::cerr << 'Error occurred in read msg: ' << errorCode.message() << std::endl;\r\n        // \u79fb\u9664\u8fde\u63a5\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n    // \u6d4b\u8bd5\u7c98\u5305\r\n    printRecvData(_recv_msg_node->_data, bytes_transferred);\r\n    std::chrono::milliseconds dura(2000);\r\n    std::this_thread::sleep_for(dura);\r\n    _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\r\n    std::cout << 'receive data is ' << _recv_msg_node->_data << std::endl;\r\n    send(_recv_msg_node->_data, _recv_msg_node->_total_len);\r\n    // \u518d\u6b21\u63a5\u6536\u5934\u90e8\u6570\u636e\r\n    _recv_head_node->clear();\r\n    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node->_data, HEAD_LENGTH),\r\n                            std::bind(&CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,\r\n                                      shared_from_this()));\r\n}\r\n```\u3002", "top": 0, "createdAt": 1727070414, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P3": {"htmlDir": "docs/post/duo-xian-cheng-Asio.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "\u591a\u7ebf\u7a0bAsio", "postUrl": "post/duo-xian-cheng-Asio.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/3", "commentNum": 0, "wordCount": 7499, "description": "# \u591a\u7ebf\u7a0b\u6a21\u578b\r\nasio \u7684\u591a\u7ebf\u7a0b\u6a21\u578b\u6709\u4e24\u79cd\uff0cIOServicePool \u548c IOThreadPool\r\n# IOServicePool\r\nIOServicePool\u6a21\u578b\uff1a\r\n![image-20240801133223177](https://github.com/user-attachments/assets/c036abee-852d-42a7-ab2d-b2acb054f14f)\r\n\u7279\u70b9:\r\n1. \u6bcf\u4e2a io_context \u90fd\u8fd0\u884c\u5728\u4e0d\u540c\u7684\u7ebf\u7a0b\u5185\uff0c\u5bf9\u4e8e\u4e00\u4e2a socket\uff0c\u4f1a\u6ce8\u518c\u5728\u540c\u4e00\u4e2a io_context \u5185\uff0c\u5e76\u4e14\u56de\u8c03\u51fd\u6570\u7684\u89e6\u53d1\u4e5f\u662f\u5728\u540c\u4e00\u4e2a\u7ebf\u7a0b\u5185\uff0c\u4e0d\u5b58\u5728\u5e76\u53d1\u5b89\u5168\u95ee\u9898\r\n2. \u4e0d\u540c\u7684 socket\uff0c\u56de\u8c03\u51fd\u6570\u53ef\u80fd\u7531\u4e0d\u540c\u7684\u7ebf\u7a0b\u8c03\u7528\uff0c\u5982\u679c\u56de\u8c03\u51fd\u6570\u4e2d\u8fdb\u884c\u4e86\u5171\u4eab\u6570\u636e\u7684\u4fee\u6539\uff0c\u5c31\u4f1a\u5b58\u5728\u7ebf\u7a0b\u5b89\u5168\u95ee\u9898\uff0c\u8fd9\u65f6\u53ef\u4ee5\u5728\u56de\u8c03\u51fd\u6570\u4e2d\u52a0\u9501\u6216\u8005\u4f7f\u7528\u903b\u8f91\u961f\u5217\u7684\u65b9\u5f0f\r\n3. \u591a\u7ebf\u7a0b\u6a21\u5f0f\u6781\u5927\u7684\u63d0\u9ad8\u4e86\u5e76\u53d1\u80fd\u529b\uff1b\u5355\u7ebf\u7a0b\u6a21\u5f0f\u4e0b\u5982\u679c\u56de\u8c03\u51fd\u6570\u8c03\u7528\u65f6\u95f4\u8fc7\u957f\uff0c\u4f1a\u5f71\u54cd\u540e\u7eed\u51fd\u6570\u7684\u8c03\u7528\uff1b\u901a\u8fc7\u903b\u8f91\u961f\u5217\u7684\u65b9\u5f0f\u5c06\u7f51\u7edc\u7ebf\u7a0b\u548c\u903b\u8f91\u7ebf\u7a0b\u89e3\u8026\u5408\u4e86\uff0c\u4e0d\u4f1a\u51fa\u73b0\u524d\u4e00\u4e2a\u8c03\u7528\u65f6\u95f4\u5f71\u54cd\u4e0b\u4e00\u4e2a\u56de\u8c03\u89e6\u53d1\u7684\u95ee\u9898\r\n## \u5b9e\u73b0\r\n\r\n\u672c\u8d28\u5c31\u662f\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u57fa\u672c\u529f\u80fd\u5c31\u662f\u6839\u636e\u6784\u9020\u51fd\u6570\u4f20\u5165\u7684\u6570\u91cf\u521b\u5efan\u4e2a\u7ebf\u7a0b\u548c io_context\uff0c\u7136\u540e\u6bcf\u4e2a\u7ebf\u7a0b\u8dd1\u4e00\u4e2a io_context\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5e76\u53d1\u5904\u7406\u4e0d\u540c io_context \u8bfb\u5199\u4e8b\u4ef6\u4e86\u3002", "top": 0, "createdAt": 1727070687, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P5": {"htmlDir": "docs/post/Asio-shi-xian-Http-fu-wu-qi.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Asio\u5b9e\u73b0Http\u670d\u52a1\u5668", "postUrl": "post/Asio-shi-xian-Http-fu-wu-qi.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/5", "commentNum": 0, "wordCount": 8475, "description": "# Http\u7b80\u4ecb\r\n\r\n## Http\u5305\u5934\u4fe1\u606f\r\n\r\n\u4e00\u4e2a\u6807\u51c6\u7684HTTP\u62a5\u6587\u5934\u901a\u5e38\u7531\u8bf7\u6c42\u5934\u548c\u54cd\u5e94\u5934\u4e24\u90e8\u5206\u7ec4\u6210\u3002", "top": 0, "createdAt": 1727071229, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P6": {"htmlDir": "docs/post/Beast-shi-xian-websocket-fu-wu-qi.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Beast\u5b9e\u73b0websocket\u670d\u52a1\u5668", "postUrl": "post/Beast-shi-xian-websocket-fu-wu-qi.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/6", "commentNum": 0, "wordCount": 24558, "description": "# \u6d41\u5bf9\u8c61\r\n\r\nWebSocket\u8fde\u63a5\u9700\u8981\u4e00\u4e2a\u6709\u72b6\u6001\u5bf9\u8c61\uff0c\u7531Beast\u4e2d\u7684\u4e00\u4e2a\u7c7b\u6a21\u677fwebsocket::stream\u8868\u793a\u3002", "top": 0, "createdAt": 1727071296, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P7": {"htmlDir": "docs/post/Grpc.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Grpc", "postUrl": "post/Grpc.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/7", "commentNum": 0, "wordCount": 4045, "description": "# \u4e0b\u8f7d\r\n\r\nvcpkg install grpc\r\n\r\n# \u914d\u7f6e\r\n\r\ncmake \u4e2d\uff1a\r\n\r\n```cmake\r\nfind_package(Protobuf CONFIG REQUIRED)\r\nfind_package(gRPC CONFIG REQUIRED)\r\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\r\narget_link_libraries(${projectName} PRIVATE gRPC::grpc++ protobuf::libprotobuf)\r\n```\r\n\r\n# \u7f16\u8bd1\r\n\r\n\u7f16\u5199\u597d proto\u6587\u4ef6\uff0c\u5728 powershell \u4e2d\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4\uff0c\u63d2\u4ef6\u9009\u62e9\u81ea\u5df1\u7684\u8def\u5f84\uff1a\r\n\r\n```cmd\r\nprotoc --proto_path=. --cpp_out=. demo.proto\r\nprotoc --proto_path=. --grpc_out=. --plugin=protoc-gen-grpc='D:\\develop_tools\\cppsoft\\vcpkg\\packages\\grpc_x64-windows\\tools\\grpc\\grpc_cpp_plugin.exe' demo.proto\r\n```\r\n\r\n\u751f\u6210\u6587\u4ef6\u6dfb\u52a0\u5230 cmakelists.txt \u4e2d\r\n\r\n# \u901a\u4fe1\u6d41\u7a0b\r\n\r\n1. \u8fde\u63a5\u5230\u670d\u52a1\u7aef\u7684\u5730\u5740\r\n2. \u521b\u5efa\u5ba2\u6237\u7aef\u5b9e\u4f8b\uff0c\u8c03\u7528\u51fd\u6570\uff0c\u5c06\u8bf7\u6c42\u6d88\u606f\u53d1\u9001\u7ed9\u670d\u52a1\u7aef\r\n3. \u670d\u52a1\u7aef\u63a5\u6536\u5230\u8bf7\u6c42\uff0c\u5904\u7406\u8bf7\u6c42\u6d88\u606f\u5e76\u751f\u6210\u54cd\u5e94\u6d88\u606f\u3002", "top": 0, "createdAt": 1727071411, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P8": {"htmlDir": "docs/post/Asio-xie-cheng.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Asio\u534f\u7a0b", "postUrl": "post/Asio-xie-cheng.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/8", "commentNum": 0, "wordCount": 2481, "description": "# \u534f\u7a0b\r\n\u534f\u7a0b\uff0c\u82f1\u6587Coroutines\uff0c\u662f\u4e00\u79cd\u57fa\u4e8e\u7ebf\u7a0b\u4e4b\u4e0a\uff0c\u4f46\u53c8\u6bd4\u7ebf\u7a0b\u66f4\u52a0\u8f7b\u91cf\u7ea7\u7684\u5b58\u5728\uff0c\u8fd9\u79cd\u7531\u7a0b\u5e8f\u5458\u81ea\u5df1\u5199\u7a0b\u5e8f\u6765\u7ba1\u7406\u7684\u8f7b\u91cf\u7ea7\u7ebf\u7a0b\u53eb\u505a\u300e\u7528\u6237\u7a7a\u95f4\u7ebf\u7a0b\u300f\uff0c\u5177\u6709\u5bf9\u5185\u6838\u6765\u8bf4\u4e0d\u53ef\u89c1\u7684\u7279\u6027\u3002", "top": 0, "createdAt": 1727071496, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P9": {"htmlDir": "docs/post/DS_1\uff1a-xian-xing-biao.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_1\uff1a\u7ebf\u6027\u8868", "postUrl": "post/DS_1%EF%BC%9A-xian-xing-biao.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/9", "commentNum": 0, "wordCount": 32558, "description": "# \u7ebf\u6027\u8868\r\n\u7ebf\u6027\u8868\u662f\u5177\u6709\u76f8\u540c\u6570\u636e\u7c7b\u578b\u7684n\uff08n\u22650\uff09\u4e2a\u6570\u636e\u5143\u7d20\u7684**\u6709\u9650\u5e8f\u5217**\uff0c\u5176\u4e2dn\u4e3a\u8868\u957f\uff0c\u5f53n = 0\u65f6\u7ebf\u6027\u8868\u662f\u4e00\u4e2a\u7a7a\u8868\u3002", "top": 0, "createdAt": 1727079656, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P10": {"htmlDir": "docs/post/DS_2\uff1a-zhan.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_2\uff1a\u6808", "postUrl": "post/DS_2%EF%BC%9A-zhan.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/10", "commentNum": 0, "wordCount": 3475, "description": "# \u6808\r\n\u5b9a\u4e49\uff1a\u53ea\u5141\u8bb8\u5728\u4e00\u7aef\u8fdb\u884c\u64cd\u4f5c\uff08\u63d2\u5165\u3001\u5220\u9664\uff09\u7684\u7ebf\u6027\u8868\r\n\u57fa\u672c\u64cd\u4f5c\uff1a\r\n1. \u521d\u59cb\u5316\u6808\r\n2. \u91ca\u653e\u5185\u5b58\r\n3. \u8fdb\u6808\r\n4. \u51fa\u6808\r\n5. \u83b7\u53d6\u6808\u9876\u5143\u7d20\r\n6. \u5224\u7a7a\r\n## \u987a\u5e8f\u6808\r\n\u5b9e\u73b0:\u9759\u6001\u6570\u7ec4\u4e2d\u5b58\u653e\u6808\u5143\u7d20\r\n```C\r\n#define Type int\r\n#define MAX_SIZE 10\r\ntypedef struct Stack {\r\n    // \u5b58\u653e\u6808\u5143\u7d20\r\n    Type data[MAX_SIZE];\r\n    // \u6808\u9876\u6307\u9488\r\n    int top;\r\n} Stack;\r\n\r\nvoid initStack(Stack *s) {\r\n    // \u6808\u4e3a\u7a7a\r\n    s->top = -1;\r\n}\r\n\r\nvoid destructorStack(Stack *s) {\r\n    s->top = -1;\r\n}\r\n\r\nbool isEmpty(Stack *s) {\r\n    return s->top == -1;\r\n}\r\n\r\nbool push(Stack *s, Type e) {\r\n    if (s->top == MAX_SIZE - 1) {\r\n        printf('Stack is full');\r\n        return false;\r\n    }\r\n    s->data[++s->top] = e;\r\n    return true;\r\n}\r\n\r\nbool pop(Stack *s) {\r\n    if (isEmpty(s)) {\r\n        printf('Stack is empty');\r\n        return false;\r\n    }\r\n    s->top--;\r\n    return true;\r\n}\r\n\r\nType front(Stack*s){\r\n    if (isEmpty(s)) {\r\n        printf('Stack is empty');\r\n        return false;\r\n    }\r\n    return s->data[s->top];\r\n}\r\n```\r\n\u4e5f\u53ef\u4ee5\u5c06top\u521d\u59cb\u5316\u4e3a0\uff0c\u8fd9\u6837top\u6307\u5411\u7684\u5c31\u662f\u4e0b\u4e00\u4e2a\u5165\u6808\u7684\u4f4d\u7f6e\r\n## \u5171\u4eab\u6808\r\n\u5c31\u662f\u5728\u987a\u5e8f\u6808\u7684\u57fa\u7840\u4e0a\uff0c\u518d\u6dfb\u52a0\u4e00\u4e2atop\u6807\u8bb0\uff0c\u5c06\u4e00\u6574\u7247\u6570\u7ec4\u7a7a\u95f4\u5206\u4e3a\u4e24\u4e2a\u6808\u4f7f\u7528\uff0ctop0\u662f\u4ece\u6570\u7ec4\u7684\u7d22\u5f150\u5411\u4e0a\uff0ctop1\u4ece\u6570\u7ec4\u7684\u6700\u5927\u7d22\u5f15\u5411\u4e0b\uff1b\u76f8\u4ea4\u7684\u65f6\u5019\u5c31\u662f\u6ee1\u4e86\r\n\r\n## \u94fe\u5f0f\u6808\r\n\u6bcf\u4e2a\u5143\u7d20\u5c31\u662f\u4e00\u4e2a\u94fe\u8868\u7ed3\u70b9\uff0c\u5b9e\u73b0\u6808\u7684\u529f\u80fd\u5c31\u884c\uff0c\u4e5f\u662f\u5206\u4e3a\u5e26\u5934\u7ed3\u70b9\u548c\u4e0d\u5e26\u5934\u7ed3\u70b9\r\n\u4e0d\u5e26\u5934\u7ed3\u70b9:\r\n```C\r\n#define Type int\r\ntypedef struct Node {\r\n    Type data;\r\n    struct Node *next;\r\n} Node;\r\ntypedef Node *stack;\r\n\r\nvoid initStack(stack *s) {\r\n    (*s) = NULL;\r\n}\r\n\r\nvoid destructor(stack *s) {\r\n    Node *p = *s;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*s) = NULL;\r\n}\r\n\r\nbool push(stack *s, Type e) {\r\n    Node *p = *s;\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Failed to allocate memory');\r\n        return false;\r\n    }\r\n    newNode->data = e;\r\n    newNode->next = p;\r\n    *s = newNode;\r\n    return true;\r\n}\r\n\r\nbool pop(stack *s) {\r\n    if (*s == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return false;\r\n    }\r\n    Node *p = *s;\r\n    (*s) = (*s)->next;\r\n    free(p);\r\n    return true;\r\n}\r\n\r\nType front(stack *s) {\r\n    if (*s == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return -1;\r\n    }\r\n    return (*s)->data;\r\n}\r\n```\r\n\u5e26\u5934\u7ed3\u70b9\uff1a\r\n```C\r\n#define Type int\r\ntypedef struct Node {\r\n    Type data;\r\n    struct Node *next;\r\n} Node;\r\ntypedef Node *stack;\r\n\r\nvoid constructor(stack *s) {\r\n    // \u5206\u914d\u5934\u7ed3\u70b9\r\n    (*s) = (Node *) malloc(sizeof(Node));\r\n    if (*s == NULL) {\r\n        printf('Failed to allocate memory');\r\n        return;\r\n    }\r\n    (*s)->data = -1;\r\n    (*s)->next = NULL;\r\n}\r\n\r\nvoid destructor(stack *s) {\r\n    if (*s == NULL) {\r\n        return;\r\n    }\r\n    Node *p = *s;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*s) = NULL;\r\n}\r\n\r\nbool push(stack *s, Type e) {\r\n    if (*s == NULL) {\r\n        printf('stack is not initialized');\r\n        return false;\r\n    }\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Failed to allocate memory');\r\n        return false;\r\n    }\r\n    newNode->data = e;\r\n    newNode->next = (*s)->next;\r\n    (*s)->next = newNode;\r\n    return true;\r\n}\r\n\r\nbool pop(stack *s) {\r\n    if ((*s) == NULL || (*s)->next == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return false;\r\n    }\r\n    Node *p = (*s)->next;\r\n    (*s)->next = p->next;\r\n    free(p);\r\n    return true;\r\n}\r\n\r\nType front(stack *s) {\r\n    if ((*s) == NULL || (*s)->next == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return -1;\r\n    }\r\n    return (*s)->next->data;\r\n}\r\n```\r\n\u4ee3\u7801\u5730\u5740\uff1ahttps://github.com/proacane/DataStructure\u3002", "top": 0, "createdAt": 1727332265, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-26", "dateLabelColor": "#bc4c00"}, "P11": {"htmlDir": "docs/post/cao-zuo-xi-tong-gai-shu.html", "labels": ["\u64cd\u4f5c\u7cfb\u7edf"], "postTitle": "\u64cd\u4f5c\u7cfb\u7edf\u6982\u8ff0", "postUrl": "post/cao-zuo-xi-tong-gai-shu.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/11", "commentNum": 0, "wordCount": 1721, "description": "# \u64cd\u4f5c\u7cfb\u7edf\u7684\u6982\u5ff5\r\n\u64cd\u4f5c\u7cfb\u7edf\uff08Operating System\uff0c OS\uff09\u662f\u6307\u63a7\u5236\u548c**\u7ba1\u7406**\u6574\u4e2a\u8ba1\u7b97\u673a\u7cfb\u7edf\u7684**\u786c\u4ef6\u548c\u8f6f\u4ef6**\u8d44\u6e90\uff0c\u5e76\u5408\u7406\u5730\u7ec4\u7ec7\u8c03\u5ea6\u8ba1\u7b97\u673a\u7684\u5de5\u4f5c\u548c\u8d44\u6e90\u7684\u5206\u914d\uff1b\u4ee5**\u63d0\u4f9b\u7ed9\u7528\u6237\u548c\u5176\u4ed6\u8f6f\u4ef6\u65b9\u4fbf\u7684\u63a5\u53e3\u548c\u73af\u5883**\uff1b\u5b83\u662f\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d**\u6700\u57fa\u672c\u7684\u7cfb\u7edf\u8f6f\u4ef6**\r\n# \u7279\u5f81\r\n\u64cd\u4f5c\u7cfb\u7edf\u76844\u4e2a\u7279\u5f81\uff1a\r\n1. \u5e76\u53d1\r\n2. \u5171\u4eab\r\n3. \u865a\u62df\r\n4. \u5f02\u6b65\r\n\u5176\u4e2d\uff0c\u5e76\u53d1\u3001\u5171\u4eab\u662f\u64cd\u4f5c\u7cfb\u7edf\u6700\u57fa\u672c\u7684\u7279\u5f81\uff0c\u5e76\u4e14\u4e8c\u8005\u76f8\u4e92\u4f9d\u5b58\r\n## \u5e76\u53d1\r\n\u5e76\u53d1\u662f\u6307\u4e24\u4e2a\u6216\u591a\u4e2a\u4e8b\u4ef6\u5728\u540c\u4e00\u65f6\u95f4\u95f4\u9694\u5185\u53d1\u751f\uff0c\u5728\u5b8f\u89c2\u770b\u6765\u662f\u540c\u65f6\u53d1\u751f\u7684\uff0c\u4f46\u662f\u5fae\u89c2\u4e0a\u662f\u4ea4\u66ff\u8fd0\u884c\u7684\uff1b\r\n\u64cd\u4f5c\u7cfb\u7edf\u7684\u5e76\u53d1\u6307\u7684\u662f\u53ef\u4ee5\u540c\u65f6\u5b58\u5728\u591a\u4e2a\u8fd0\u884c\u7684\u7a0b\u5e8f\r\n\u5e76\u884c\uff1a\u6307\u591a\u4e2a\u4e8b\u4ef6\u5728\u540c\u4e00\u65f6\u523b\u540c\u65f6\u53d1\u751f\r\n\u5355\u6838 cpu \u540c\u4e00\u65f6\u523b\u53ea\u80fd\u8fd0\u884c\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u53ea\u80fd\u5e76\u53d1\r\n\u591a\u6838 cpu \u540c\u4e00\u65f6\u523b\u53ef\u4ee5\u8fd0\u884c\u591a\u4e2a\u8fdb\u7a0b\uff0c\u65e2\u5b58\u5728\u5e76\u53d1\u3001\u4e5f\u5b58\u5728\u5e76\u884c\r\n## \u5171\u4eab\r\n\u5171\u4eab\uff1a\u6307\u7cfb\u7edf\u4e2d\u7684\u8d44\u6e90\u53ef\u4ee5\u88ab\u591a\u4e2a\u5e76\u53d1\u6267\u884c\u7684\u8fdb\u7a0b\u4f7f\u7528\r\n\u4e92\u65a5\u5171\u4eab\uff1a\u7cfb\u7edf\u4e2d\u7684\u67d0\u4e9b\u8d44\u6e90\uff0c\u867d\u7136\u53ef\u4ee5\u63d0\u4f9b\u7ed9\u591a\u4e2a\u8fdb\u7a0b\u4f7f\u7528\uff0c\u4f46\u4e00\u4e2a\u65f6\u95f4\u6bb5\u5185\u53ea\u5141\u8bb8\u4e00\u4e2a\u8fdb\u7a0b\u8bbf\u95ee\u8be5\u8d44\u6e90\uff0c\u4f8b\u5982\u6444\u50cf\u5934\u7b49\u8d44\u6e90\r\n\u540c\u65f6\u5171\u4eab\uff1a\u7cfb\u7edf\u4e2d\u7684\u67d0\u4e9b\u8d44\u6e90\uff0c\u5141\u8bb8\u4e00\u4e2a\u65f6\u95f4\u6bb5\u5185\u7531\u591a\u4e2a\u8fdb\u7a0b\u201c\u540c\u65f6\u201d\u5bf9\u5b83\u4eec\u8fdb\u884c\u8bbf\u95ee\uff0c\u4f8b\u5982\u78c1\u76d8\u7684\u8bfb\u5199\r\n\u4ece\u5171\u4eab\u7684\u5b9a\u4e49\u5c31\u53ef\u4ee5\u770b\u51fa\u6765\uff0c\u82e5\u64cd\u4f5c\u7cfb\u7edf\u6ca1\u6709\u5e76\u53d1\u6027\uff0c\u5171\u4eab\u5c31\u6ca1\u6709\u610f\u4e49\uff1b\u6ca1\u6709\u5171\u4eab\u6027\uff0c\u5e76\u53d1\u4e5f\u6ca1\u6709\u610f\u4e49\r\n## \u865a\u62df\r\n\u865a\u62df\u662f\u6307\u628a\u4e00\u4e2a\u7269\u7406\u4e0a\u7684\u5b9e\u4f53\u53d8\u4e3a\u82e5\u5e72\u4e2a\u903b\u8f91\u4e0a\u7684\u5bf9\u5e94\u7269\u3002", "top": 0, "createdAt": 1727335375, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-26", "dateLabelColor": "#bc4c00"}, "P12": {"htmlDir": "docs/post/DS_2\uff1a-dui-lie.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_2\uff1a\u961f\u5217", "postUrl": "post/DS_2%EF%BC%9A-dui-lie.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/12", "commentNum": 0, "wordCount": 4324, "description": "# \u961f\u5217\r\n\u53ea\u5141\u8bb8\u4e00\u7aef\u8fdb\u5165\uff0c\u53e6\u4e00\u7aef\u5220\u9664\u7684\u7ebf\u6027\u8868\r\n\u57fa\u672c\u64cd\u4f5c\uff1a\r\n1. \u521d\u59cb\u5316\r\n2. \u91ca\u653e\u5185\u5b58\r\n3. \u5165\u961f\r\n4. \u51fa\u961f\r\n5. \u83b7\u53d6\u961f\u5934\u5143\u7d20\r\n6. \u5224\u7a7a\r\n## \u987a\u5e8f\u5b58\u50a8\u5b9e\u73b0\u961f\u5217\r\n\u5185\u90e8\u4f7f\u7528\u8fde\u7eed\u5185\u5b58\u7684\u6570\u7ec4\uff0c\u91c7\u7528\u5faa\u73af\u961f\u5217\u7684\u683c\u5f0f\r\n```C\r\n#define MAX_SIZE 10\r\n#define Type int\r\ntypedef struct {\r\n    Type data[MAX_SIZE];\r\n    // \u961f\u5934\u6307\u9488\r\n    int front;\r\n    // \u961f\u5c3e\u6307\u9488\r\n    int rear;\r\n    // \u6dfb\u52a0 size\uff0c\u6765\u7ef4\u62a4\u961f\u5217\u7684\u957f\u5ea6\uff0c\u7528\u4e8e\u5224\u65ad\u961f\u5217\u662f\u5426\u5df2\u6ee1\r\n    int size;\r\n} Queue;\r\n\r\nvoid constructor(Queue *q) {\r\n    q->front = 0;\r\n    q->rear = 0;\r\n}\r\n\r\nbool isEmpty(Queue *q) {\r\n    return q->front == q->rear;\r\n}\r\n\r\nbool isFull(Queue *q) {\r\n    return (q->rear + 1) % MAX_SIZE == q->front;\r\n}\r\n\r\nvoid push(Queue *q, Type e) {\r\n    // \u5982\u679c\u961f\u5217\u5df2\u6ee1\u5219\u4e0d\u80fd\u6dfb\u52a0\r\n    if (isFull(q)) {\r\n        printf('Queue is full');\r\n        return;\r\n    }\r\n    q->data[q->rear] = e;\r\n    q->rear = (q->rear + 1) % MAX_SIZE;\r\n}\r\n\r\nType pop(Queue*q){\r\n    if(isEmpty(q)){\r\n        return -1;\r\n    }\r\n    Type t = q->data[q->front];\r\n    q->front = (q->front+1)%MAX_SIZE;\r\n    return t;\r\n}\r\n```\r\n\r\n> \u5728\u5224\u65ad\u961f\u5217\u662f\u5426\u5df2\u6ee1\uff0c\u6216\u662f\u5426\u7a7a\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u91c7\u7528\u4e0d\u540c\u7684\u65b9\u5f0f\uff0c\u4e00\u79cd\u5c31\u662f\u4e0a\u9762\u4ee3\u7801\u6240\u7528\u7684\u65b9\u5f0f\uff0c\u4e5f\u53ef\u4ee5\u6dfb\u52a0 size \u6210\u5458\uff0c\u8bb0\u5f55\u5f53\u524d\u961f\u5217\u7684\u6709\u6548\u5143\u7d20\u6570\u91cf\uff0c\u901a\u8fc7 size == MAX_SIZE \u548c size == 0 \u6765\u5224\u65ad\u961f\u5217\u72b6\u6001\uff1b\r\n> \u53e6\u4e00\u79cd\u6709\u6548\u7684\u65b9\u5f0f\u662f\u6dfb\u52a0 tag \u6807\u8bb0\uff0c0\u548c1\u5206\u522b\u8868\u793a\u4e0a\u6b21\u6210\u529f\u7684\u64cd\u4f5c\u4e3a\u51fa\u961f\u548c\u5165\u961f\uff0c\u5f53 front == rear && tag == 0\uff0c\u5c31\u4ee3\u8868\u961f\u5217\u7a7a\u4e86\uff0c front == rear && tag == 1\u5c31\u4ee3\u8868\u961f\u5217\u5df2\u6ee1\r\n## \u94fe\u5f0f\u961f\u5217\r\n\u94fe\u5f0f\u5b58\u50a8\u4f9d\u7136\u5206\u4e3a\u6709\u5934\u7ed3\u70b9\u548c\u65e0\u5934\u7ed3\u70b9\u4e24\u79cd\u65b9\u5f0f\uff0c\u94fe\u5f0f\u5b58\u50a8\u6ca1\u6709\u5224\u7a7a\u3001\u5224\u6ee1\u7684\u5fc5\u8981\r\n\u65e0\u5934\u7ed3\u70b9\uff1a\r\n```C\r\n#include <stdio.h>\r\n#include <malloc.h>\r\n#include <stdbool.h>\r\n\r\n#define Type int\r\n\r\ntypedef struct Node {\r\n    struct Node *next;\r\n    Type data;\r\n} Node;\r\ntypedef struct {\r\n    Node *front;\r\n    Node *rear;\r\n} Queue;\r\n\r\nvoid constructor(Queue *q) {\r\n    (*q).front = NULL;\r\n    (*q).rear = NULL;\r\n}\r\n\r\nbool isEmpty(Queue *q) {\r\n    return q->front == NULL;\r\n}\r\n\r\nvoid destructor(Queue *q) {\r\n    Node *p = (*q).front;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*q).front = NULL;\r\n    (*q).rear = NULL;  // \u786e\u4fdd\u961f\u5217\u7684 rear \u4e5f\u8bbe\u7f6e\u4e3a NULL\r\n}\r\n\r\nvoid push(Queue *q, Type e) {\r\n    if (q == NULL) {\r\n        printf('Queue is not initialized\\n');\r\n        return;\r\n    }\r\n    // \u63d2\u5165\u5230\u961f\u5c3e\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Can't allocate memory');\r\n        return;\r\n    }\r\n    newNode->next = NULL;\r\n    newNode->data = e;\r\n    // \u5982\u679c\u6ca1\u6709\u7ed3\u70b9\r\n    if (q->front == NULL) {\r\n        q->front = newNode;\r\n        q->rear = newNode;\r\n        printf('Inserted %d as the first element\\n', e);\r\n    } else {\r\n        q->rear->next = newNode;\r\n        q->rear = newNode;\r\n        printf('Inserted %d at the rear of the queue\\n', e);\r\n    }\r\n}\r\n\r\nType pop(Queue *q) {\r\n    if (isEmpty(q)) {\r\n        printf('Queue is empty, can't pop\\n');\r\n        return -1;\r\n    }\r\n    Node *popNode = q->front;\r\n    q->front = q->front->next;\r\n    Type v = popNode->data;\r\n    if (q->front == NULL) {\r\n        q->rear = NULL;\r\n        printf('Queue is now empty after popping %d\\n', v);\r\n    } else {\r\n        printf('Popped %d from the queue\\n', v);\r\n    }\r\n    free(popNode);\r\n    return v;\r\n}\r\n```\r\n\u5e26\u5934\u7ed3\u70b9:\r\n```C\r\n#define Type int\r\n\r\ntypedef struct Node {\r\n    struct Node *next;\r\n    Type data;\r\n} Node;\r\n\r\ntypedef struct {\r\n    Node *front;\r\n    Node *rear;\r\n} Queue;\r\n\r\nvoid constructor(Queue *q) {\r\n    // \u521b\u5efa\u5934\u7ed3\u70b9\r\n    q->front = q->rear = (Node *) malloc(sizeof(Node));\r\n    q->front->next = NULL;\r\n}\r\n\r\nvoid destructor(Queue *q) {\r\n    Node *p = q->front;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*q).front = NULL;\r\n    (*q).rear = NULL;  // \u786e\u4fdd\u961f\u5217\u7684 rear \u4e5f\u8bbe\u7f6e\u4e3a NULL\r\n}\r\n\r\nbool isEmpty(Queue *q) {\r\n    return q->front == q->rear;\r\n}\r\n\r\nvoid push(Queue *q, Type e) {\r\n//    printf('Pushing element: %d\\n', e);  // \u65e5\u5fd7\u8bb0\u5f55\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Can't allocate memory');\r\n        return;\r\n    }\r\n    newNode->next = NULL;\r\n    newNode->data = e;\r\n    q->rear->next = newNode;\r\n    q->rear = newNode;\r\n    printf('Element pushed: %d\\n', e);  // \u65e5\u5fd7\u8bb0\u5f55\r\n}\r\n\r\nType pop(Queue*q){\r\n    if(isEmpty(q)){\r\n        printf('Queue is empty, cannot pop.\\n');  // \u65e5\u5fd7\u8bb0\u5f55\r\n        return -1;\r\n    }\r\n    Node* popNode = q->front->next;\r\n    Type v = popNode->data;\r\n//    printf('Popping element: %d\\n', v);  // \u65e5\u5fd7\u8bb0\u5f55\r\n    q->front->next = popNode->next;\r\n    // \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u7ed3\u70b9\r\n    if(q->rear == popNode){\r\n        q->rear = q->front;\r\n    }\r\n    free(popNode);\r\n    printf('Element popped: %d\\n', v);  // \u65e5\u5fd7\u8bb0\u5f55\r\n    return v;\r\n}\r\n```\u3002", "top": 0, "createdAt": 1727419653, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-27", "dateLabelColor": "#bc4c00"}, "P13": {"htmlDir": "docs/post/OS_1\uff1a-jin-cheng-guan-li.html", "labels": ["\u64cd\u4f5c\u7cfb\u7edf"], "postTitle": "OS_1\uff1a\u8fdb\u7a0b\u7ba1\u7406", "postUrl": "post/OS_1%EF%BC%9A-jin-cheng-guan-li.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/13", "commentNum": 0, "wordCount": 4122, "description": "# \u8fdb\u7a0b\u7684\u6982\u5ff5\u3001\u7ec4\u6210\u3001\u7279\u5f81\r\n## \u6982\u5ff5\r\n\u8fdb\u7a0b\u53ef\u4ee5\u7406\u89e3\u4e3a\u7a0b\u5e8f\u7684\u4e00\u6b21\u6267\u884c\uff0c\u540c\u4e00\u4e2a\u7a0b\u5e8f\u53ef\u4ee5\u521b\u5efa\u591a\u4e2a\u8fdb\u7a0b\r\n## \u7ec4\u6210\r\n\u5f53\u8fdb\u7a0b\u88ab\u521b\u5efa\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4e3a\u8be5\u8fdb\u7a0b\u5206\u914d\u4e00\u4e2a\u552f\u4e00\u7684PID\uff08Process ID\uff0c\u8fdb\u7a0bID\uff09\uff0c\u64cd\u4f5c\u7cfb\u7edf\u8fd8\u4f1a\u8bb0\u5f55\u7ed9\u8fdb\u7a0b\u5206\u914d\u7684\u8d44\u6e90\u60c5\u51b5\u3001\u8fd0\u884c\u72b6\u51b5\u7b49\uff0c\u8fd9\u4e9b\u4fe1\u606f\u90fd\u88ab\u4fdd\u5b58\u5728\u4e00\u4e2a\u6570\u636e\u7ed3\u6784PCB\u4e2d\uff0c\u4e5f\u53eb\u8fdb\u7a0b\u63a7\u5236\u5757\r\n![image](https://github.com/user-attachments/assets/568e1105-9df3-4f30-af4a-54a0885708b6)\r\n\u800c\u8fdb\u7a0b\u7684\u7ec4\u6210\uff0c\u5219\u5982\u4e0b\u56fe\uff1a\r\n![image](https://github.com/user-attachments/assets/195c850a-cbcb-4398-9a1c-77ae05880fef)\r\n\u5176\u4e2d\uff0cPCB\u7531\u64cd\u4f5c\u7cfb\u7edf\u4f7f\u7528\uff0c\u7a0b\u5e8f\u6bb5\u548c\u6570\u636e\u6bb5\u7531\u8fdb\u7a0b\u4f7f\u7528\r\n## \u7279\u5f81\r\n1. \u52a8\u6001\u6027\uff1a\u8fdb\u7a0b\u662f\u7a0b\u5e8f\u7684\u4e00\u6b21\u6267\u884c\u8fc7\u7a0b\uff0c\u662f\u52a8\u6001\u5730\u4ea7\u751f\u3001\u53d8\u5316\u548c\u6d88\u4ea1\u7684\r\n2. \u5e76\u53d1\u6027\uff1a\u5185\u5b58\u4e2d\u6709\u591a\u4e2a\u8fdb\u7a0b\u5b9e\u4f53\uff0c\u5404\u8fdb\u7a0b\u53ef\u5e76\u53d1\u6267\u884c\r\n3. \u72ec\u7acb\u6027\uff1a\u8fdb\u7a0b\u662f\u80fd\u72ec\u7acb\u8fd0\u884c\u3001\u72ec\u7acb\u83b7\u5f97\u8d44\u6e90\u3001\u72ec\u7acb\u63a5\u6536\u8c03\u5ea6\u7684\u57fa\u672c\u5355\u4f4d\r\n4. \u5f02\u6b65\u6027\uff1a\u5404\u8fdb\u7a0b\u6309\u5404\u81ea\u7684\u901f\u5ea6\u63a8\u8fdb\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b**\u8fdb\u7a0b\u540c\u6b65\u673a\u5236**\u6765\u89e3\u51b3\u5f02\u6b65\u95ee\u9898\r\n5. \u7ed3\u6784\u6027\uff1a\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u4f1a\u914d\u7f6e\u4e00\u4e2aPCB\uff0c\u7ed3\u6784\u4e0a\u7531\u4e09\u6bb5\u7ec4\u6210\uff08\u5982\u4e0a\u56fe\uff09\r\n# \u8fdb\u7a0b\u7684\u7ec4\u7ec7\r\n\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u4f1a\u5b58\u5728\u5f88\u591a\u8fdb\u7a0b\uff0c\u6240\u4ee5\u9700\u8981\u4f7f\u7528\u9002\u5f53\u7684\u65b9\u5f0f\u5c06\u591a\u4e2a\u8fdb\u7a0b\u7684PCB\u8fdb\u884c\u7ec4\u7ec7\u7ba1\u7406\r\n## \u94fe\u63a5\u65b9\u5f0f\r\n\u6309\u7167\u8fdb\u7a0b\u72b6\u6001\u5c06PCB\u5206\u4e3a\u591a\u4e2a\u961f\u5217\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6301\u6709\u6307\u5411\u5404\u4e2a\u961f\u5217\u7684\u6307\u9488\r\n![image](https://github.com/user-attachments/assets/583f94a8-0fb0-4df4-8960-78e4651ba05b)\r\n## \u7d22\u5f15\u65b9\u5f0f\r\n\u6839\u636e\u8fdb\u7a0b\u72b6\u6001\u7684\u4e0d\u540c\uff0c\u5efa\u7acb\u51e0\u5f20\u7d22\u5f15\u8868\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6301\u6709\u6307\u5411\u5404\u4e2a\u7d22\u5f15\u8868\u7684\u6307\u9488\r\n![image](https://github.com/user-attachments/assets/615a052b-8780-418c-9dcf-2e7ba81e1e6d)\r\n# \u8fdb\u7a0b\u7684\u72b6\u6001\u4e0e\u8f6c\u6362\r\n\u8fdb\u7a0b\u7684\u72b6\u6001\u6709\uff1a\r\n1. \u8fd0\u884c\u72b6\u6001\r\n2. \u5c31\u7eea\u72b6\u6001\r\n3. \u963b\u585e\u72b6\u6001\r\n4. \u521b\u5efa\u72b6\u6001\r\n5. \u7ec8\u6b62\u72b6\u6001\r\n\u5176\u4e2d\uff0c\u8fd0\u884c\u3001\u5c31\u7eea\u3001\u963b\u585e\u662f\u4e09\u79cd\u6700\u57fa\u672c\u7684\u72b6\u6001\r\n\u72b6\u6001\u4e4b\u95f4\u7684\u8f6c\u6362:\r\n1. \u5c31\u7eea\u6001->\u8fd0\u884c\u6001\r\n2. \u8fd0\u884c\u6001->\u5c31\u7eea\u6001\r\n3. \u8fd0\u884c\u6001->\u963b\u585e\u6001\r\n4. \u963b\u585e\u6001->\u5c31\u7eea\u6001\r\n## \u521b\u5efa\u6001\u3001\u5c31\u7eea\u6001\r\n\u8fdb\u7a0b\u6b63\u5728\u88ab\u521b\u5efa\u65f6\uff0c\u5b83\u7684\u72b6\u6001\u662f\u201c\u521b\u5efa\u6001\u201d\uff0c\u5728\u8fd9\u4e2a\u9636\u6bb5\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4e3a\u8fdb\u7a0b\u5206\u914d\u8d44\u6e90\u3001\u521d\u59cb\u5316PCB\uff1b\u5f53\u8fdb\u7a0b\u521b\u5efa\u5b8c\u6210\u540e\uff0c\u4fbf\u8fdb\u5165\u201c\u5c31\u7eea\u6001\u201d\uff0c\u5904\u4e8e\u5c31\u7eea\u6001\u7684\u8fdb\u7a0b\u5df2\u7ecf\u5177\u5907\u8fd0\u884c\u6761\u4ef6\uff0c\u7b49\u5f85cpu\u7684\u6267\u884c\r\n## \u8fd0\u884c\u6001\r\ncpu\u6b63\u5728\u8fd0\u884c\u7684\u8fdb\u7a0b\r\n## \u963b\u585e\u6001\r\n\u5728\u8fdb\u7a0b\u8fd0\u884c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u53ef\u80fd\u4f1a\u8bf7\u6c42\u7b49\u5f85\u67d0\u4e2a\u4e8b\u4ef6\u7684\u53d1\u751f\uff08\u5982\u7b49\u5f85\u67d0\u79cd\u7cfb\u7edf\u8d44\u6e90\u7684\u5206\u914d\uff0c\u6216\u8005\u7b49\u5f85\u5176\u4ed6\u8fdb\u7a0b\u7684\u54cd\u5e94\uff09\u3002", "top": 0, "createdAt": 1727422623, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-27", "dateLabelColor": "#bc4c00"}, "P14": {"htmlDir": "docs/post/DS_3\uff1a-zi-fu-chuan.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_3\uff1a\u5b57\u7b26\u4e32", "postUrl": "post/DS_3%EF%BC%9A-zi-fu-chuan.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/14", "commentNum": 0, "wordCount": 9429, "description": "# \u5b57\u7b26\u4e32\r\n\u7531\u96f6\u4e2a\u6216\u591a\u4e2a\u5b57\u7b26\u7ec4\u6210\u7684\u6709\u9650\u5e8f\u5217\r\n1. \u5b50\u4e32\uff1a\u4e32\u4e2d\u4efb\u610f\u4e2a\u8fde\u7eed\u7684\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u5e8f\u5217\r\n2. \u4e3b\u4e32\uff1a\u5305\u542b\u5b50\u4e32\u7684\u4e32\r\n3. \u5b57\u7b26\u5728\u4e3b\u4e32\u4e2d\u7684\u4f4d\u7f6e\uff1a\u5b57\u7b26\u5728\u4e32\u4e2d\u7684\u5e8f\u53f7\r\n4. \u5b50\u4e32\u5728\u4e3b\u4e32\u4e2d\u7684\u4f4d\u7f6e\uff1a\u5b50\u4e32\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5728\u4e3b\u4e32\u4e2d\u7684\u4f4d\u7f6e\r\n\u57fa\u672c\u64cd\u4f5c\uff1a\r\n1. \u8d4b\u503c\uff1aassign(str*t,str*s)\uff1at\u8d4b\u503c\u4e3as\r\n2. \u590d\u5236\uff1acopy(str*t,str*s)\uff1as\u590d\u5236\u7ed9t\r\n3. \u5224\u7a7a\r\n4. \u957f\u5ea6\r\n5. \u6e05\u7a7a\r\n6. \u91ca\u653e\u5185\u5b58\r\n7. \u62fc\u63a5\r\n8. \u5b50\u4e32\uff1asubstr(str*s,int pos,int len)\r\n9. \u5b9a\u4f4d\uff1a\u82e5\u4e3b\u4e32S\u4e2d\u5b58\u5728\u4e0e\u4e32T\u503c\u76f8\u540c\u7684\u5b50\u4e32\uff0c\u5219\u8fd4\u56de\u5b83\u5728\u4e3b\u4e32S\u4e2d\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\uff1b\u5426\u5219\u51fd\u6570\u503c\u4e3a0\r\n10. \u6bd4\u8f83\u5927\u5c0f\r\n\u5b9e\u73b0\u4f9d\u7136\u662f\u5206\u4e3a\u987a\u5e8f\u5b58\u50a8\u548c\u94fe\u5f0f\u5b58\u50a8\r\n## \u987a\u5e8f\u5b58\u50a8\u5b9e\u73b0\r\n\u987a\u5e8f\u5b58\u50a8\u5185\u90e8\u7684 char \u6570\u7ec4\uff0c\u53ef\u4ee5\u4f7f\u7528\u9759\u6001\u6570\u7ec4\uff0c\u4e5f\u53ef\u4ee5\u4f7f\u7528\u52a8\u6001\u5206\u914d\uff0c\u8fd9\u91cc\u4f7f\u7528\u9759\u6001\u6570\u7ec4\r\n\u987a\u5e8f\u5b58\u50a8\u6709\u51e0\u79cd\u4e0d\u540c\u7684\u5b9e\u73b0\u65b9\u6848:\r\n1. char\u6570\u7ec4\u4ece\u7d22\u5f150\u5f00\u59cb\u5b58\u653e\u5b57\u7b26\uff0c\u4f7f\u7528\u5355\u72ec\u7684\u53d8\u91cf\u5b58\u50a8\u5b57\u7b26\u4e32\u957f\u5ea6\r\n2. char\u6570\u7ec4\u7d22\u5f150\u5b58\u50a8\u957f\u5ea6\uff0c\u540e\u9762\u5b58\u653e\u5b57\u7b26\r\n3. \u6ca1\u6709\u957f\u5ea6\u53d8\u91cf\uff0c\u4ee5\\0\u4f5c\u4e3a\u5b57\u7b26\u4e32\u7ed3\u5c3e\r\n4. char\u6570\u7ec4\u7d22\u5f150\u4e0d\u4f7f\u7528\uff0c\u4f7f\u7528\u5355\u72ec\u7684\u53d8\u91cf\u5b58\u50a8\u5b57\u7b26\u4e32\u957f\u5ea6\r\n\u6211\u91c7\u7528\u7684\u662f\uff1a\u6700\u540e\u4e00\u4f4d\u662f'\\0'\uff0c\u540c\u65f6\u4f7f\u7528len\u53d8\u91cf\r\n```C\r\n#define MAX_LEN 10\r\n\r\ntypedef struct {\r\n    char data[MAX_LEN];\r\n    int length;\r\n} string;\r\n\r\nvoid constructor(string *s) {\r\n    s->length = 0;\r\n    s->data[0] = '\\0';\r\n}\r\n\r\nbool isEmpty(string *s) {\r\n    return s->length == 0;\r\n}\r\n\r\n// \u8d4b\u503c\r\nvoid assign(string *s, const char *t, int len) {\r\n    if (t[0] == '\\0') {\r\n        return;\r\n    }\r\n    if (len >= MAX_LEN ) {\r\n        len = MAX_LEN - 1;\r\n        printf('t is too long, use %d chars\\n', len);\r\n    }\r\n    for (int i = 0; i < len; i++) {\r\n        s->data[i] = t[i];\r\n    }\r\n    s->length = len;\r\n    s->data[len] = '\\0';\r\n}\r\n\r\nvoid copy(string *s, string *t) {\r\n    memcpy(s->data, t->data, t->length);\r\n    s->length = t->length;\r\n    s->data[s->length] = '\\0';\r\n}\r\n\r\nvoid clear(string *s) {\r\n    memset(s->data, '\\0', s->length);\r\n    s->length = 0;\r\n}\r\n\r\nvoid destructor(string *s) {\r\n\r\n}\r\n\r\nbool concat(string *dest, string *s, string *t) {\r\n    if (s->length + t->length > MAX_LEN) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < s->length; i++) {\r\n        dest->data[i] = s->data[i];\r\n    }\r\n    for(int j = 0;j< t->length;j++){\r\n        dest->data[j + s->length] = t->data[j];\r\n    }\r\n    dest->length = s->length + t->length;\r\n    dest->data[dest->length] = '\\0';\r\n    return true;\r\n}\r\n\r\nbool substr(string *dest, string *s, int pos, int len) {\r\n    if (pos + len > s->length) {\r\n        return false;\r\n    }\r\n\r\n    for (int i = pos; i < pos + len; i++) {\r\n        dest->data[i - pos] = s->data[i];\r\n    }\r\n    dest->length = len;\r\n    dest->data[len] = '\\0';\r\n    return true;\r\n}\r\n\r\n// s1>s2 \u8fd4\u56de\u503c\u5927\u4e8e0\r\nint compare(string*s1,string*s2){\r\n    for(int i = 0; i< s1->length && i < s2->length;i++){\r\n        if(s1->data[i] != s2->data[i]){\r\n            return s1->data[i] - s2->data[i];\r\n        }\r\n    }\r\n    // \u957f\u5ea6\u957f\u7684\u4e32\u5927\r\n    return s1->length -s2->length;\r\n}\r\n// \u8fd4\u56det\u5b50\u4e32\u5728 s \u4e2d\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\r\nint index(string*s,string* t){\r\n    int i = 0;\r\n    int n = s->length;\r\n    int m = t->length;\r\n    if(m > n){\r\n        return -1;\r\n    }\r\n    // \u622a\u53d6\u5b50\u4e32\r\n    string sub;\r\n    constructor(&sub);\r\n    while(i <= n-m){\r\n        substr(&sub,s,i,m);\r\n        // \u76f8\u7b49\u76f4\u63a5\u8fd4\u56de\r\n        if(compare(&sub,t) == 0){\r\n            return i;\r\n        }\r\n        i++;\r\n    }\r\n    return -1;\r\n}\r\n```\r\n## \u94fe\u5f0f\u5b58\u50a8\u5b9e\u73b0\r\n\u94fe\u5f0f\u5b58\u50a8\u7684\u6bcf\u4e2a\u8282\u70b9\u53ef\u4ee5\u653e1\u4e2a\u6216\u591a\u4e2a\u5b57\u7b26\uff0c\u8fd9\u91cc\u5b58\u653e4\u4e2a\u5b57\u7b26\r\n```C\r\n#define MAX_CHARS 4\r\ntypedef struct Node {\r\n    // \u6bcf\u4e2a\u8282\u70b9\u5b58\u653e4\u4e2a\u5b57\u7b26\r\n    char data[MAX_CHARS];\r\n    struct Node *next;\r\n} Node;\r\ntypedef Node *string;\r\n\r\nvoid constructor(string *s) {\r\n    *s = (Node *) malloc(sizeof(Node));\r\n    if (*s == NULL) {\r\n        printf('Failed to allocate memory\\n');\r\n        return;\r\n    }\r\n    (*s)->next = NULL;\r\n    for (int i = 0; i < MAX_CHARS; ++i) {\r\n        (*s)->data[i] = '\\0';\r\n    }\r\n}\r\n\r\nvoid destructor(string *s) {\r\n    Node *current = *s;\r\n    while (current != NULL) {\r\n        Node *temp = current;\r\n        current = current->next;\r\n        free(temp);\r\n    }\r\n    *s = NULL;\r\n}\r\n\r\nint size(string *s) {\r\n    Node *current = *s;\r\n    int totalLen = 0;\r\n    while (current != NULL) {\r\n        for (int i = 0; i < MAX_CHARS; i++) {\r\n            if (current->data[i] == '\\0') {\r\n                return totalLen;\r\n            }\r\n            totalLen++;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return totalLen;\r\n}\r\n\r\nbool isEmpty(string *s) {\r\n    return (*s == NULL || (*s)->data[0] == '\\0');\r\n}\r\n\r\nvoid assign(string *s, const char *t, int len) {\r\n    if (t[0] == '\\0') {\r\n        return;\r\n    }\r\n    destructor(s);\r\n    constructor(s);\r\n    Node *current = *s;\r\n    for (int i = 0; i < len; i++) {\r\n        if (i != 0 && i % MAX_CHARS == 0) {\r\n            // \u521b\u5efa\u65b0\u8282\u70b9\r\n            Node *newNode = (Node *) malloc(sizeof(Node));\r\n            if (newNode == NULL) {\r\n                printf('Failed to allocate memory\\n');\r\n                return;\r\n            }\r\n            newNode->next = NULL;\r\n            for (int k = 0; k < MAX_CHARS; ++k) {\r\n                newNode->data[k] = '\\0';\r\n            }\r\n            current->next = newNode;\r\n            current = newNode;\r\n        }\r\n        current->data[i % MAX_CHARS] = t[i];\r\n    }\r\n}\r\n\r\nvoid printStr(string *s) {\r\n    Node *current = *s;\r\n    while (current != NULL) {\r\n        for (int i = 0; i < MAX_CHARS; i++) {\r\n            if (current->data[i] != '\\0') {\r\n                printf('%c', current->data[i]);\r\n            }\r\n        }\r\n        current = current->next;\r\n    }\r\n    printf('\\n');\r\n}\r\n\r\nbool concat(string *dest, string *s, string *t) {\r\n    destructor(dest);\r\n    constructor(dest);\r\n    Node *current = *s;\r\n    Node *destCurrent = *dest;\r\n    int i = 0;\r\n    // s \u62fc\u5230 dest\r\n    while (current != NULL) {\r\n        for (int j = 0; j < MAX_CHARS; j++) {\r\n            if (current->data[j] == '\\0') {\r\n                break;\r\n            }\r\n            destCurrent->data[i++] = current->data[j];\r\n            if (i == MAX_CHARS) {\r\n                // \u521b\u5efa\u65b0\u8282\u70b9\r\n                Node *newNode = (Node *) malloc(sizeof(Node));\r\n                if (newNode == NULL) {\r\n                    printf('Failed to allocate memory\\n');\r\n                    return false;\r\n                }\r\n                newNode->next = NULL;\r\n                for (int k = 0; k < MAX_CHARS; ++k) {\r\n                    newNode->data[k] = '\\0';\r\n                }\r\n                destCurrent->next = newNode;\r\n                destCurrent = newNode;\r\n                i = 0;\r\n            }\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    // \u62fc\u63a5\u5b8c\u4e86 s\uff0c\u4ece dest\u5f53\u524d\u8282\u70b9\u7684\u7b2c i\u4f4d\u62fc\u63a5 t\r\n    current = *t;\r\n    while (current != NULL) {\r\n        for (int j = 0; j < MAX_CHARS; j++) {\r\n            if (current->data[j] == '\\0') {\r\n                break;\r\n            }\r\n            destCurrent->data[i++] = current->data[j];\r\n            // dest\u7684\u8282\u70b9\u6ee1\u4e86\uff0c\u521b\u5efa\u65b0\u8282\u70b9\r\n            if (i == MAX_CHARS) {\r\n                Node *newNode = (Node *) malloc(sizeof(Node));\r\n                if (newNode == NULL) {\r\n                    printf('Failed to allocate memory\\n');\r\n                    return false;\r\n                }\r\n                newNode->next = NULL;\r\n                for (int k = 0; k < MAX_CHARS; ++k) {\r\n                    newNode->data[k] = '\\0';\r\n                }\r\n                destCurrent->next = newNode;\r\n                destCurrent = newNode;\r\n                i = 0;\r\n            }\r\n        }\r\n        current = current->next;\r\n    }\r\n    return true;\r\n}\r\n\r\nbool substr(string *dest, string *s, int pos, int len) {\r\n    destructor(dest);\r\n    constructor(dest);\r\n    int strLen = size(s);\r\n    if (pos + len > strLen) {\r\n        return false;\r\n    }\r\n    // \u4ece\u7b2c\u51e0\u4e2a\u8282\u70b9\u5f00\u59cb\u622a\u53d6\r\n    int i = pos / MAX_CHARS;\r\n    // \u4ece\u8282\u70b9\u7684\u7b2c\u51e0\u4f4d\u5f00\u59cb\u622a\u53d6\r\n    int j = pos % MAX_CHARS;\r\n    Node *current = *s;\r\n    // \u79fb\u52a8\u5230\u7b2c i \u4e2a\u8282\u70b9\r\n    while (i > 0 && current != NULL) {\r\n        current = current->next;\r\n        i--;\r\n    }\r\n\r\n    if (current == NULL) {\r\n        return false; // \u5982\u679c\u6ca1\u6709\u8db3\u591f\u7684\u8282\u70b9\r\n    }\r\n\r\n    Node *destCurrent = *dest;\r\n    int destIndex = 0;\r\n\r\n    // \u5f00\u59cb\u5411 dest \u4e2d\u6dfb\u52a0\u5b57\u7b26\r\n    for (int k = 0; k < len; k++) {\r\n        // \u622a\u53d6\u5b8c\u4e86\u4e00\u4e2a\u8282\u70b9\r\n        if (j == MAX_CHARS) {\r\n            current = current->next;\r\n            j = 0;\r\n        }\r\n        // dest\u7684\u8282\u70b9\u653e\u6ee1\u4e86\r\n        if (destIndex == MAX_CHARS) {\r\n            // \u521b\u5efa\u65b0\u8282\u70b9\r\n            Node *newNode = (Node *) malloc(sizeof(Node));\r\n            if (newNode == NULL) {\r\n                printf('Failed to allocate memory\\n');\r\n                return false;\r\n            }\r\n            newNode->next = NULL;\r\n            for (int l = 0; l < MAX_CHARS; ++l) {\r\n                newNode->data[l] = '\\0';\r\n            }\r\n            destCurrent->next = newNode;\r\n            destCurrent = newNode;\r\n            destIndex = 0;\r\n        }\r\n        destCurrent->data[destIndex++] = current->data[j++];\r\n    }\r\n    return true;\r\n}\r\n\r\n// s1>s2 \u8fd4\u56de\u503c\u5927\u4e8e0\r\nint compare(string *s1, string *s2) {\r\n    Node *current1 = *s1;\r\n    Node *current2 = *s2;\r\n    while (current1 != NULL && current2 != NULL) {\r\n        for (int i = 0; i < MAX_CHARS; i++) {\r\n            if (current1->data[i] == '\\0' || current2->data[i] == '\\0') {\r\n                return current1->data[i] - current2->data[i];\r\n            }\r\n\r\n            if (current1->data[i] != current2->data[i]) {\r\n                return current1->data[i] - current2->data[i];\r\n            }\r\n        }\r\n        current1 = current1->next;\r\n        current2 = current2->next;\r\n    }\r\n    return size(s1) - size(s2);\r\n}\r\n\r\nint indexOfString(string *s, string *t) {\r\n    int sSize = size(s);\r\n    int tSize = size(t);\r\n    if (tSize > sSize) {\r\n        return -1;\r\n    }\r\n\r\n    string sub = NULL;\r\n    int i = 0;\r\n    while (i <= sSize - tSize) {\r\n        if (!substr(&sub, s, i, tSize)) {\r\n            destructor(&sub);\r\n            return -1;\r\n        };\r\n        if (compare(&sub, t) == 0) {\r\n            destructor(&sub);\r\n            return i;\r\n        }\r\n        i++;\r\n    }\r\n    destructor(&sub);\r\n    return -1;\r\n}\r\n```\r\n\u521d\u59cb\u5316\u7684\u65f6\u5019\u53ef\u80fd\u521d\u59cb\u5316\u4e3aNULL\u6bd4\u8f83\u597d\uff0c\u8fd9\u91cc\u5c31\u4e0d\u4f5c\u66f4\u6539\u4e86\u3002", "top": 0, "createdAt": 1727508472, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-28", "dateLabelColor": "#bc4c00"}, "P16": {"htmlDir": "docs/post/C++-bing-fa-bian-cheng.html", "labels": ["C++", "\u5e76\u53d1"], "postTitle": "C++\u5e76\u53d1\u7f16\u7a0b", "postUrl": "post/C%2B%2B-bing-fa-bian-cheng.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/16", "commentNum": 0, "wordCount": 23460, "description": "\u8bb0\u5f55\u300aC++Concurrency In Action\u300b\u7684\u5b66\u4e60\u8fc7\u7a0b\r\n# \u5e76\u53d1\r\n\u5e76\u53d1\u7684\u4e24\u79cd\u65b9\u5f0f\uff1a\u771f\u6b63\u7684\u5e76\u884c\u4e0e\u4efb\u52a1\u5207\u6362\r\n![image](https://github.com/user-attachments/assets/11994029-b407-4a19-9374-de8ad04bc5de)\r\n## \u591a\u8fdb\u7a0b\u5e76\u53d1\r\n\u5c06\u5e94\u7528\u7a0b\u5e8f\u5206\u4e3a\u591a\u4e2a\u72ec\u7acb\u7684\u8fdb\u7a0b\u540c\u65f6\u8fd0\u884c\uff1b\u4e0d\u540c\u7684\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7\u4fe1\u53f7\u3001\u5957\u63a5\u5b57\u7b49\u6e20\u9053\u8fdb\u884c\u901a\u4fe1\uff0c\u4f46\u662f\u8fd9\u79cd\u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\u590d\u6742\uff0c\u4e14\u901f\u5ea6\u6162\u3002", "top": 0, "createdAt": 1728539751, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-10-10", "dateLabelColor": "#bc4c00"}, "P17": {"htmlDir": "docs/post/C#-yu-fa-xue-xi.html", "labels": ["C#"], "postTitle": "C#\u8bed\u6cd5\u5b66\u4e60", "postUrl": "post/C%23-yu-fa-xue-xi.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/17", "commentNum": 0, "wordCount": 63862, "description": "# \u7b80\u4ecb\r\n\u8bb0\u5f55\u4e00\u4e0bC#\u57fa\u672c\u8bed\u6cd5\u7684\u5b66\u4e60\r\n# HelloWorld\r\n\u4e00\u4e2a C# \u7a0b\u5e8f\u4e3b\u8981\u5305\u62ec\u4ee5\u4e0b\u90e8\u5206\uff1a\r\n- \u547d\u540d\u7a7a\u95f4\u58f0\u660e\uff08Namespace declaration\uff09\r\n- \u4e00\u4e2a class\r\n- Class \u65b9\u6cd5\r\n- Class \u5c5e\u6027\r\n- \u4e00\u4e2a Main \u65b9\u6cd5\r\n- \u8bed\u53e5\uff08Statements\uff09& \u8868\u8fbe\u5f0f\uff08Expressions\uff09\r\n- \u6ce8\u91ca\r\nC# \u6587\u4ef6\u7684\u540e\u7f00\u4e3a .cs\r\n```C#\r\nusing System;\r\nnamespace HelloWorldApplication\r\n{\r\n   class HelloWorld\r\n   {\r\n      static void Main(string[] args)\r\n      {\r\n         /* \u6211\u7684\u7b2c\u4e00\u4e2a C# \u7a0b\u5e8f*/\r\n         Console.WriteLine('Hello World');\r\n         Console.ReadKey();\r\n      }\r\n   }\r\n}\r\n```\r\n# \u57fa\u672c\u8bed\u6cd5\r\nC#\u4e5f\u662f\u4e00\u79cd\u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\u8bed\u8a00\u3002", "top": 0, "createdAt": 1730468262, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-11-01", "dateLabelColor": "#bc4c00"}, "P18": {"htmlDir": "docs/post/Unity-zhong-ying-yong-C#.html", "labels": ["C#", "Unity"], "postTitle": "Unity\u4e2d\u5e94\u7528C#", "postUrl": "post/Unity-zhong-ying-yong-C%23.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/18", "commentNum": 5, "wordCount": 4551, "description": "# \u4ecb\u7ecd\r\n\u9879\u76ee\u5185\u5bb9\u9009\u81eaUnity\u5b98\u65b9Creator Kit - Beginner Code\uff1ahttps://assetstore.unity.com/packages/templates/tutorials/creator-kit-beginner-code-urp-151986\r\n\r\nUnity\u5b98\u65b9API\u6587\u6863\uff1a[Unity - Scripting API: MonoBehaviour](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.html)\r\n\r\n# \u4f7f\u7528VS2022\u4f5c\u4e3a\u4ee3\u7801\u7f16\u8f91\u5668\r\n\r\nEdit-Preferences\u4e2d\u7684External Tools \u4e2d\u8bbe\u7f6e\u7f16\u8f91\u5668\uff0c\u5148\u7528VS\uff0c\u4ee5\u540e\u518d\u8bd5\u7740\u7528\u7528Rider\r\n\r\n![image](https://github.com/user-attachments/assets/74dee040-eac4-48da-a04d-c037d17baac6)\r\n# \u53d8\u91cf\r\n\r\n\u5728unity\u4e2d\uff0c\u521b\u5efa\u811a\u672cscrpit\u5b9e\u9645\u4e0a\u5c31\u662f\u81ea\u5b9a\u4e49\u65b0\u7684component\u7c7b\u578b\uff0c\u53ef\u4ee5\u9644\u52a0\u5230\u6e38\u620f\u5bf9\u8c61GameObject\u4e0a\uff1bC#\u811a\u672c\u4e2d\u7684\u53d8\u91cf\u4e5f\u53ef\u4ee5\u770b\u4f5c\u8fd9\u4e2aComponent\u7c7b\u578b\u4e2d\u7684\u5c5e\u6027\uff1b\u8bbe\u7f6e\u4e3aPublic\u5c31\u4f1a\u66b4\u9732\u5728 inspector \u4e2d\r\n\r\n\u521b\u5efa\u5e76\u4f7f\u7528\u53d8\u91cf\uff1a\r\n\r\n1. \u65b0\u5efa\u4e00\u4e2a scene\uff0c\u547d\u540d\u4e3a MyScene\uff0c\u653e\u5165 Assets/Scenes \u4e0b\r\n2. \u5728\u65b0\u7684 scene \u4e2d\uff0c\u65b0\u5efa\u4e00\u4e2a empty gameobject(\u7a7a\u6e38\u620f\u5bf9\u8c61)\u547d\u540d\u4e3a Player\r\n3. \u4e3a Player \u5bf9\u8c61\u65b0\u589e\u811a\u672c\u7ec4\u4ef6\uff0c\u653e\u5165 Assets/Scripts \u4e0b\uff0c\u547d\u540d\u4e3a MainPlayer\uff1b\u5728\u5176\u4e2d\u6253\u5370\u65e5\u5fd7\r\n4. \u5c06\u4e0a\u4e00\u6b65\u751f\u6210\u7684\u811a\u672c\u4f5c\u4e3aComponent\u5e94\u7528\u5230 Player \u4e2d\uff1b\u8fd0\u884c\u6d4b\u8bd5\u5373\u53ef\u53d1\u73b0\u5728\u63a7\u5236\u53f0\u4e2d\u6253\u5370\u7684\u65e5\u5fd7\r\n\r\n![image](https://github.com/user-attachments/assets/01662b53-afec-440a-a85a-5c4543a5f8fd)\r\n\r\n\u5728 Assets/Creator Kit - Beginner Code/Scripts/Tutorial/SpawnerSample.cs \u811a\u672c\u6587\u4ef6\u4e2d\uff0c\u6dfb\u52a0\u65b0\u7684\u53d8\u91cf radius\uff0c\u7528\u6765\u8bbe\u7f6e\u5b58\u653e\u8ddd\u79bb\uff0c\u8be5\u811a\u672c\u7528\u6765\u751f\u6210\u6307\u5b9a\u5bf9\u8c61\r\n\r\n```c#\r\nusing UnityEngine;\r\nusing CreatorKitCode;\r\n\r\npublic class SpawnerSample : MonoBehaviour\r\n{\r\n    public GameObject ObjectToSpawn;\r\n\r\n    // \u8ddd\u79bb\r\n    public short radius;\r\n    void Start()\r\n    {\r\n        int angle = 15;\r\n        // \u751f\u6210\u7269\u4f53\u7684\u4f4d\u7f6e\uff0c\u521d\u59cb\u503c\u4e3a\u5f53\u524d\u7269\u4f53\u7684\u4f4d\u7f6e\r\n        Vector3 spawnPosition = transform.position;\r\n        // Quaternion.Euler\u65b9\u6cd5\u662f\u8fdb\u884c\u65cb\u8f6c\uff0c\u8fd9\u91cc\u4ee3\u8868\u5355\u4f4d\u5411\u91cf(1,0,0)\u7ed5y\u8f74\u8f6c15\u00b0\r\n        Vector3 direction = Quaternion.Euler(0, angle, 0) * Vector3.right;\r\n        \r\n        spawnPosition = transform.position + direction * radius;\r\n        // \u751f\u6210\u7269\u4f53\r\n        Instantiate(ObjectToSpawn, spawnPosition, Quaternion.identity);\r\n\r\n        angle = 55;\r\n        direction = Quaternion.Euler(0, angle, 0) * Vector3.right;\r\n        spawnPosition = transform.position + direction * radius;\r\n        Instantiate(ObjectToSpawn, spawnPosition, Quaternion.identity);\r\n\r\n        angle = 95;\r\n        direction = Quaternion.Euler(0, angle, 0) * Vector3.right;\r\n        spawnPosition = transform.position + direction * radius;\r\n        Instantiate(ObjectToSpawn, spawnPosition, Quaternion.identity);\r\n    }\r\n}\r\n```\r\n\r\n# \u65b9\u6cd5\r\n\r\n```c#\r\npublic class SpawnerSample : MonoBehaviour\r\n{\r\n    public GameObject ObjectToSpawn;\r\n\r\n    // \u8ddd\u79bb\r\n    public short radius;\r\n    void Start()\r\n    {\r\n        int angle = 15;\r\n        for (; angle < 360; angle +=30) {\r\n            GenNewObject(ref angle);\r\n        }\r\n    }\r\n\r\n    private void GenNewObject(ref int angle)\r\n    {\r\n        Vector3 direction = Quaternion.Euler(0, angle, 0) * Vector3.right;\r\n        Vector3 spawnPosition = transform.position + direction * radius;\r\n        Instantiate(ObjectToSpawn, spawnPosition, Quaternion.identity);\r\n    }\r\n}\r\n```\r\n\r\n# \u7c7b\r\n\r\nC#\u4e2d\uff0c\u7ee7\u627f\u81ea MonoBehaviour \u7684\u7ec4\u4ef6\u7c7b\uff0c\u90fd\u4f1a\u88ab\u81ea\u52a8\u5b9e\u4f8b\u5316\r\n\r\nC#\u4e2d\u81ea\u5b9a\u4e49\u7684\u7c7b\u4f5c\u4e3a\u6210\u5458\uff0c\u9700\u8981\u5728\u7c7b\u4e0a\u6dfb\u52a0`[System.Serializable]`\uff1b\u7c7b\u7684\u5c5e\u6027\u8981\u81ea\u52a8\u66b4\u9732\u5728Unity\u7684Inspector\u4e2d\uff0c\u5fc5\u987b\u8981Public\u6743\u9650\uff1b\u5176\u5b83\u6743\u9650\u7684\u5c5e\u6027\u9700\u8981\u6dfb\u52a0`[UnityEngine.SerializeField]`\r\n\r\n```c#\r\npublic class MainPlayer : MonoBehaviour\r\n{\r\n    public string myName;\r\n    // cat\u7684\u5c5e\u6027\u4f1a\u51fa\u73b0\u5728Inspector\u4e2d\r\n    public Cat cat;\r\n    // Start is called before the first frame update\r\n    void Start()\r\n    {\r\n        Debug.Log('My name is ' + myName);\r\n    }\r\n\r\n    // Update is called once per frame\r\n    void Update() \r\n    {\r\n        \r\n    }\r\n}\r\n\r\n[System.Serializable]\r\npublic class Cat\r\n{\r\n    public string name;\r\n    public string age; \r\n}\r\n```\r\n\r\n# \u5c01\u88c5\u4e0e\u7ee7\u627f\r\n\r\n\u6743\u9650\u4fee\u9970\u7b26\uff1a\r\n\r\n- public\uff1a\u53ef\u5728\u4efb\u4f55\u4f4d\u7f6e\u8bbf\u95ee\r\n- internal\uff1a\u53ea\u80fd\u5728\u540c\u4e00\u9879\u76ee\u4e2d\u8bbf\u95ee\r\n- protected\uff1a\u53ea\u6709\u8be5\u7c7b\u5bf9\u8c61\u53ca\u5176\u5b50\u7c7b\u5bf9\u8c61\u53ef\u4ee5\u8bbf\u95ee\r\n- protected internal\uff1a\u540c\u4e00\u9879\u76ee\u4e2d\u8be5\u7c7b\u53ca\u5176\u5b50\u7c7b\u53ef\u4ee5\u8bbf\u95ee\r\n- private\uff1a\u53ea\u6709\u81ea\u5df1\u7684\u7c7b\u4e2d\u53ef\u4ee5\u8bbf\u95ee\r\n\r\n\u9ed8\u8ba4\u6743\u9650\uff1a\r\n\r\n- \u7c7b\u3001\u63a5\u53e3\u3001\u7ed3\u6784\u4f53\u3001\u679a\u4e3e\u7684\u9ed8\u8ba4\u6743\u9650\u662f internal\uff1b\r\n- \u7c7b\u4e2d\u6210\u5458\u9ed8\u8ba4\u4e3a private\r\n- \u63a5\u53e3\u6210\u5458\u9ed8\u8ba4 public\r\n- \u547d\u540d\u7a7a\u95f4\u3001\u679a\u4e3e\u7c7b\u578b\u6210\u5458\u9ed8\u8ba4 public\r\n\r\n\u5728unity\u4e2d\uff0cpublic \u6210\u5458\u53ef\u4ee5\u5728 Inspector \u4e2d\u76f4\u63a5\u64cd\u4f5c\uff1b\u5176\u5b83\u9700\u8981\u52a0`[UnityEngine.SerializeField]`\uff1b\u5b50\u7c7b\u4e2d\u53ef\u4ee5\u4f7f\u7528`base`\u5173\u952e\u5b57\u4ee3\u8868\u57fa\u7c7b\r\n\r\n```c#\r\n//\u7236\u7c7b Monster.cs\r\nusing System;\r\n[Serializable]\r\npublic class Monster\r\n{\r\n    // \u540d\u5b57\r\n    public string name;\r\n    // \u5e74\u9f84\r\n    public int age;\r\n    // \u6bdb\u8272\r\n    public string color;\r\n    // \u751f\u547d\r\n    public int hp;\r\n\r\n    public Monster() { }\r\n    public Monster(string name, int age, string color, int hp)\r\n    {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.color = color;\r\n        this.hp = hp;\r\n    }\r\n}\r\n\r\n// \u6d3e\u751f\u7c7b Phoenix.cs\r\nusing System;\r\n[Serializable]\r\npublic class Phoenix:Monster\r\n{\r\n    private bool isReborn=false;\r\n\r\n    // \u5168\u53c2\u6784\u9020\u51fd\u6570\r\n    public Phoenix(string name, int age, string color, int hp,bool isReborn) : base(name, age, color, hp)\r\n    {\r\n        this.isReborn = isReborn;\r\n    }\r\n    //\u65e0\u53c2\u7a7a\u6784\u9020\u65b9\u6cd5\r\n    public Phoenix()\r\n    {\r\n    }\r\n\r\n    void Reborn() {\r\n        this.hp = 1000;\r\n        this.isReborn = true;\r\n    }\r\n}\r\n```\r\n\r\n\u3002", "top": 0, "createdAt": 1731549961, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-11-14", "dateLabelColor": "#bc4c00"}}, "singeListJson": {}, "labelColorDict": {"C#": "#3DBEBB", "C++": "#89D2DF", "C\u8bed\u8a00": "#006b75", "QT": "#bfdadc", "question": "#d876e3", "Unity": "#fbca04", "\u5e76\u53d1": "#e99695", "\u64cd\u4f5c\u7cfb\u7edf": "#f9d0c4", "\u6570\u636e\u7ed3\u6784": "#fbca04", "\u7f51\u7edc\u7f16\u7a0b": "#158E9B"}, "displayTitle": "Proacane\u7684\u4e2a\u4eba\u535a\u5ba2", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://proacane.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}