{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "Proacane\u7684\u4e2a\u4eba\u5fae\u535a", "subTitle": "\u5b66\u65e0\u6b62\u5883", "avatarUrl": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "faviconUrl": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "GMEEK_VERSION": "last", "postListJson": {"P2": {"htmlDir": "docs/post/Asio-wang-luo-ku-zhai-yao.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Asio\u7f51\u7edc\u5e93\u6458\u8981", "postUrl": "post/Asio-wang-luo-ku-zhai-yao.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/2", "commentNum": 0, "wordCount": 23938, "description": "# \u5355\u7ebf\u7a0b\u901a\u4fe1\u6d41\u7a0b\r\n![image-20240726093453475](https://github.com/user-attachments/assets/a53c98fb-c149-403e-b102-d110905e5eb4)\r\n# \u540c\u6b65\u8bfb\u5199\u7684\u793a\u4f8b\r\n- \u670d\u52a1\u7aef\r\n```cpp\r\n#include <iostream>\r\n#include <boost/asio.hpp>\r\n#include <memory>\r\n#include <set>\r\n#include <thread>\r\n\r\nusing namespace std;\r\nusing namespace boost::asio::ip;\r\n\r\nconst int MAX_LEN = 1024;\r\ntypedef shared_ptr<tcp::socket> socket_ptr;\r\nstd::set<std::shared_ptr<std::thread>> thread_set;\r\n\r\nvoid session(socket_ptr sock) {\r\n    try {\r\n        for (;;) {\r\n            char data[MAX_LEN];\r\n            boost::system::error_code error;\r\n            // \u8bfb\u53d6\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u5185\u5bb9\r\n            size_t length = sock->read_some(boost::asio::buffer(data), error);\r\n\r\n            if (error == boost::asio::error::eof) {\r\n                std::cout << 'Connection closed by peer\\n';\r\n                break;\r\n            } else if (error) {\r\n                throw boost::system::system_error(error);\r\n            }\r\n\r\n            std::string received_message(data, length);\r\n            std::cout << 'Received from ' << sock->remote_endpoint().address().to_string() << ': ' << received_message << std::endl;\r\n\r\n            // \u8f6c\u6362\u4e3a \u5927\u5199\r\n            // Process the received message (e.g., convert to upper case)\r\n            std::transform(received_message.begin(), received_message.end(), received_message.begin(), ::toupper);\r\n            // \u518d\u5199\u56de\u5ba2\u6237\u7aef\r\n            boost::asio::write(*sock, boost::asio::buffer(received_message));\r\n        }\r\n    } catch (exception &e) {\r\n        std::cerr << 'Exception in thread: ' << e.what() << std::endl;\r\n    }\r\n}\r\n\r\n// \u5efa\u7acb\u8fde\u63a5\r\nvoid server(boost::asio::io_context &ios, unsigned short port_num) {\r\n    boost::asio::ip::tcp::acceptor acceptor(ios, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port_num));\r\n    std::cout << 'Server started on port ' << port_num << std::endl;\r\n    // \u6ca1\u8fde\u63a5\u5c31\u4e00\u76f4\u963b\u585e\r\n    for (;;) {\r\n        socket_ptr socket(new tcp::socket(ios));\r\n        acceptor.accept(*socket);\r\n        std::cout << 'Accepted connection from ' << socket->remote_endpoint().address().to_string() << std::endl;\r\n        // \u4e3a\u8fde\u63a5\u521b\u5efa\u4e00\u4e2a\u7ebf\u7a0b\uff0c\u5f00\u59cb\u901a\u4fe1\r\n        auto t = make_shared<std::thread>(session, socket);\r\n        thread_set.insert(t);\r\n    }\r\n}\r\n\r\nint main() {\r\n    try {\r\n        boost::asio::io_context ios;\r\n        server(ios, 1234);\r\n        // \u9632\u6b62\u6709\u6570\u636e\u672a\u4f20\u8f93\u5b8c\u65f6\uff0c\u4e3b\u7ebf\u7a0b\u5c31\u7ed3\u675f\u4e86\r\n        for (auto &t: thread_set) {\r\n            t->join();\r\n        }\r\n    } catch (exception &e) {\r\n        std::cerr << 'Exception in main thread: ' << e.what() << std::endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n# \u5f02\u6b65\u8bfb\u5199\u793a\u4f8b\r\n![image-20240726095026183](https://github.com/user-attachments/assets/bd621b55-b962-4eaf-9488-5bb8f7c47f79)\r\n## \u6ce8\u610f\u7684\u95ee\u9898\r\n\r\n- \u5f02\u5e38\u5904\u7406\u65f6\uff0c\u4e3a\u9632\u6b62 Session \u4e8c\u6b21\u6790\u6784\uff0c\u9700\u8981\u7ee7\u627f std::enable_shared_from_this<CSession>\uff1b\u4f7f\u7528\u667a\u80fd\u6307\u9488\u4e0e map \u5ef6\u957f Session \u7684\u751f\u547d\u5468\u671f\r\n\r\n- \u53d1\u9001\u6d88\u606f\u65f6\uff0c\u4e3a\u4fdd\u8bc1\u6d88\u606f\u7684\u6709\u5e8f\u6027\uff0c\u9700\u8981\u589e\u52a0\u53d1\u9001\u961f\u5217\r\n\r\n- \u5904\u7406\u7c98\u5305\u95ee\u9898\uff0c\u6d88\u606f\u7ed3\u6784\u91c7\u7528 TLV \u683c\u5f0f\uff0c\u4f7f\u7528 async_read_some \u6bd4\u8f83\u9ebb\u70e6\uff0c\u4f7f\u7528 async_read \u6bd4\u8f83\u7b80\u6d01\r\n\r\n  \u200b\t\t\t\t\t\t\t![image-20240726093831093](https://github.com/user-attachments/assets/45a3e63d-53d6-4124-b647-d9742bc9897e)\r\n\r\n  - async_read_some\uff1a\u56de\u8c03\u51fd\u6570\u91cc\u4e0d\u65ad\u5224\u65ad\u5df2\u7ecf\u5904\u7406\u7684\u5b57\u8282\r\n\r\n  - async_read\uff1a\u4e24\u5c42\u56de\u8c03\uff0c\u7b2c\u4e00\u5c42\u5904\u7406\u5305\u5934\uff0c\u7b2c\u4e8c\u5c42\u5904\u7406\u5305\u4f53\r\n\r\n- \u5b57\u8282\u5e8f\u7684\u5904\u7406\uff1a\u53d1\u9001\u524d\u8f6c\u6362\u4e3a\u7f51\u7edc\u5b57\u8282\u5e8f\uff0c\u63a5\u6536\u540e\u8f6c\u6362\u4e3a\u672c\u5730\u5b57\u8282\u5e8f (boost::asio::detail::socket_ops::network_to_host_short)\r\n- \u53d1\u9001\u6570\u636e\u4f7f\u7528jsoncpp\u8fdb\u884c\u5c01\u88c5\r\n\r\nCServer.h\r\n\r\n```cpp\r\n#ifndef ASYNCSERVER_CSERVER_H\r\n#define ASYNCSERVER_CSERVER_H\r\n#include 'CSession.h'\r\n#include <iostream>\r\nclass CSession;\r\n/**\r\n * \u63a5\u53d7\u65b0\u7684\u5ba2\u6237\u7aef\u8fde\u63a5\uff0c\u6bcf\u4e2a\u8fde\u63a5\u90fd\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Session \u5b9e\u4f8b\r\n */\r\nclass CServer {\r\npublic:\r\n    CServer(boost::asio::io_context &ioc, unsigned short port_num);\r\n    // \u79fb\u9664\u5df2\u5904\u7406\u5b8c\u6210\u7684 Session \u5b9e\u4f8b\r\n    void clear_session(std::string uuid);\r\nprivate:\r\n    // \u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Session \u5e76\u7b49\u5f85\u65b0\u7684\u5ba2\u6237\u7aef\u8fde\u63a5\r\n    void start_accept();\r\n    // \u5904\u7406\u65b0\u7684\u5ba2\u6237\u7aef\u8fde\u63a5\uff0c\u5c06\u5176\u52a0\u5165 _sessions \u4e2d\uff0c\u5e76\u542f\u52a8\u6570\u636e\u5904\u7406\r\n    void handle_accept(std::shared_ptr<CSession> newSession, const boost::system::error_code errorCode);\r\n\r\n    boost::asio::io_context &_ioc;\r\n    boost::asio::ip::tcp::acceptor _acceptor;\r\n    // \u7ba1\u7406\u8fde\u63a5\r\n    std::map<std::string, std::shared_ptr<CSession>> _sessions;\r\n\r\n};\r\n#endif //ASYNCSERVER_CSERVER_H\r\n```\r\n\r\nCServer.cpp\r\n\r\n```cpp\r\n#include 'CServer.h'\r\n\r\nCServer::CServer(boost::asio::io_context &ioc, unsigned short port_num) : _ioc(ioc),\r\n                                                                          _acceptor(_ioc,\r\n                                                                                    tcp::endpoint(tcp::v4(),\r\n                                                                                                  port_num)) {\r\n    std::cout << 'Acceptor create succeed! port number is ' << port_num << std::endl;\r\n    start_accept();\r\n}\r\n\r\nvoid CServer::start_accept() {\r\n    // \u4f7f\u7528\u667a\u80fd\u6307\u9488\u6765\u7ba1\u7406 session \u5b9e\u4f8b\uff0c\u4ee5\u4fdd\u8bc1\u4e0d\u4f1a\u4e8c\u6b21\u6790\u6784\r\n    std::shared_ptr<CSession> newSession = std::make_shared<CSession>(_ioc, this);\r\n    // \u7ed1\u5b9a\u5230\u670d\u52a1\u4e0a\uff0c\u65b0\u8fde\u63a5\u5230\u6765\u540e\u89e6\u53d1\u56de\u8c03\u51fd\u6570 handle_accept\r\n    _acceptor.async_accept(newSession->get_socket(),\r\n                           std::bind(&CServer::handle_accept, this, newSession, std::placeholders::_1));\r\n\r\n}\r\n\r\nvoid CServer::handle_accept(std::shared_ptr<CSession> newSession, const boost::system::error_code errorCode) {\r\n    if (errorCode.value() != 0) {\r\n        std::cerr << 'Error occurred int accept connection: ' << errorCode.message() << std::endl;\r\n//        delete newSession;\r\n    } else {\r\n        std::cout << 'Accept connection successfully ' << std::endl;\r\n        std::cout << 'Start dealing with data' << std::endl;\r\n        // \u6ca1\u95ee\u9898\u5c31\u5f00\u59cb\u5904\u7406\u6570\u636e\r\n        newSession->start();\r\n        _sessions.insert(std::make_pair(newSession->get_uuid(), newSession));\r\n    }\r\n    // \u7ee7\u7eed\u63a5\u6536\u65b0\u8fde\u63a5\r\n    start_accept();\r\n}\r\n\r\nvoid CServer::clear_session(std::string uuid) {\r\n    _sessions.erase(uuid);\r\n}\r\n```\r\n\r\nCSession.h\r\n\r\n```cpp\r\n#ifndef ASYNCSERVER_CSESSION_H\r\n#define ASYNCSERVER_CSESSION_H\r\n\r\n#include <boost/asio.hpp>\r\n#include <string>\r\n#include <map>\r\n#include <boost/uuid/uuid_generators.hpp>\r\n#include <boost/uuid/uuid_io.hpp>\r\n#include 'CServer.h'\r\n#include <queue>\r\n#include 'global.h'\r\nusing namespace boost::asio::ip;\r\n\r\nclass MsgNode;\r\n\r\nclass CServer;\r\n\r\n/**\r\n * \u5904\u7406\u5ba2\u6237\u7aef\u6d88\u606f\u6536\u53d1\r\n */\r\nclass CSession : public std::enable_shared_from_this<CSession> {\r\npublic:\r\n    tcp::socket &get_socket() { return _socket; };\r\n\r\n    explicit CSession(boost::asio::io_context &ioc, CServer *server);;\r\n\r\n    // \u5f00\u59cb\u5904\u7406\r\n    void start();\r\n\r\n    // \u83b7\u53d6 uuid\r\n    std::string &get_uuid() {\r\n        return _uuid;\r\n    }\r\n\r\n    /**\r\n     * \u53d1\u9001\u63a5\u53e3\r\n     * @param msg\r\n     * @param max_length\r\n     */\r\n    void send(char *msg, int max_length);\r\n\r\n    void send(std::string msg);\r\nprivate:\r\n    // \u5199\u7684\u56de\u8c03\u51fd\u6570\r\n    void handle_write(const boost::system::error_code &errorCode, std::shared_ptr<CSession> self_shared);\r\n\r\n    // \u8bfb\u7684\u56de\u8c03\u51fd\u6570\r\n    void handle_read(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                     std::shared_ptr<CSession> self_shared);\r\n\r\n    /**\r\n     * \u8bfb\u53d6\u5305\u5934\u7684\u56de\u8c03\u51fd\u6570\r\n     * @param errorCode\r\n     * @param bytes_transferred\r\n     * @param self_shared\r\n     */\r\n    void handle_read_head(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                          std::shared_ptr<CSession> self_shared);\r\n\r\n    /**\r\n     * \u8bfb\u53d6\u5305\u4f53\u7684\u56de\u8c03\u51fd\u6570\r\n     * @param errorCode\r\n     * @param bytes_transferred\r\n     * @param self_shared\r\n     */\r\n    void handle_read_msg(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                          std::shared_ptr<CSession> self_shared);\r\n    // \u6253\u5370\u6536\u5230\u7684\u4e8c\u8fdb\u5236\u6570\u636e\r\n    void printRecvData(char* data, int length);\r\n    // \u4f20\u8f93\u4fe1\u606f\u7684 socket\r\n    tcp::socket _socket;\r\n    // \u4fdd\u5b58\u6570\u636e\r\n\r\n    char _data[MAX_LENGTH];\r\n    // \u96b6\u5c5e\u4e8e\u54ea\u4e2a server\r\n    CServer *_server;\r\n    // uuid\r\n    std::string _uuid;\r\n    // \u53d1\u9001\u961f\u5217\r\n    std::queue<std::shared_ptr<MsgNode>> _send_que;\r\n    // \u4e92\u65a5\u9501\uff0c\u9632\u6b62\u591a\u4e2a\u7ebf\u7a0b\u540c\u65f6\u64cd\u4f5c\u961f\u5217\r\n    std::mutex _send_lock;\r\n\r\n    //\u6536\u5230\u7684\u6d88\u606f\u7ed3\u6784\r\n    std::shared_ptr<MsgNode> _recv_msg_node;\r\n    // \u6807\u8bb0\u5934\u90e8\u7ed3\u6784\u662f\u5426\u63a5\u6536\u5b8c\u6bd5\r\n    bool _b_head_parse;\r\n    //\u6536\u5230\u7684\u5934\u90e8\u7ed3\u6784\r\n    std::shared_ptr<MsgNode> _recv_head_node;\r\n};\r\n\r\n/**\r\n * \u6d88\u606f\u7ed3\u70b9\r\n */\r\nclass MsgNode {\r\n    friend class CSession;\r\n\r\npublic:\r\n    MsgNode(const char *msg, short max_len) : _total_len(max_len + HEAD_LENGTH), _cur_len(0) {\r\n        _data = new char[_total_len + 1];\r\n        // \u5305\u5934\u5b57\u8282\u5e8f\u8f6c\u6362\r\n        int max_len_host = boost::asio::detail::socket_ops::host_to_network_short(max_len);\r\n        // \u8bb0\u5f55\u957f\u5ea6\r\n        memcpy(_data, &max_len_host, HEAD_LENGTH);\r\n        // \u62f7\u8d1d\u6570\u636e\r\n        memcpy(_data + HEAD_LENGTH, msg, max_len);\r\n        _data[_total_len] = '\\0';\r\n    }\r\n\r\n    MsgNode(short max_len) : _total_len(max_len), _cur_len(0) {\r\n        _data = new char[_total_len + 1];\r\n    }\r\n\r\n    void clear() {\r\n        memset(_data, 0, _total_len);\r\n        _cur_len = 0;\r\n    }\r\n\r\n    ~MsgNode() {\r\n        delete[] _data;\r\n    }\r\n\r\nprivate:\r\n    int _cur_len;\r\n    int _total_len;\r\n    char *_data;\r\n};\r\n\r\n#endif //ASYNCSERVER_CSESSION_H\r\n```\r\n\r\nCSession.cpp\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <thread>\r\n#include 'CSession.h'\r\n#include 'proto/msg.pb.h'\r\n#include <json/json.h>\r\n#include <json/value.h>\r\n#include <json/reader.h>\r\n\r\nCSession::CSession(boost::asio::io_context &ioc, CServer *server) : _socket(ioc), _server(server),\r\n                                                                    _b_head_parse(false) {\r\n    std::memset(_data, '\\0', MAX_LENGTH);\r\n    // \u751f\u6210 uuid\r\n    boost::uuids::uuid a_uuid = boost::uuids::random_generator()();\r\n    _uuid = boost::uuids::to_string(a_uuid);\r\n    _recv_head_node = std::make_shared<MsgNode>(HEAD_LENGTH);\r\n}\r\n\r\nvoid CSession::start() {\r\n    std::cout << 'First read from client\\n';\r\n    // \u5148\u5728\u5ba2\u6237\u7aef\u8bfb\u53d6\r\n//    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n//                            std::bind(&CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2,\r\n//                                      shared_from_this()));\r\n    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node->_data, HEAD_LENGTH),\r\n                            std::bind(&CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,\r\n                                      shared_from_this()));\r\n}\r\n\r\nvoid CSession::handle_read(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                           std::shared_ptr<CSession> self_shared) {\r\n    try {\r\n        if (errorCode.value() != 0) {\r\n            std::cerr << 'Error occurred int read: ' << errorCode.message() << std::endl;\r\n            // \u79fb\u9664\u8fde\u63a5\r\n            _server->clear_session(_uuid);\r\n            return;\r\n        }\r\n        // \u6d4b\u8bd5\u7c98\u5305\r\n        printRecvData(_data, bytes_transferred);\r\n        std::chrono::milliseconds dura(2000);\r\n        std::this_thread::sleep_for(dura);\r\n\r\n        while (bytes_transferred > 0) {\r\n            // \u8bb0\u5f55\u5df2\u7ecf\u5904\u7406\u7684\u5b57\u8282\r\n            int copy_len = 0;\r\n            if (!_b_head_parse) {\r\n                // \u5934\u90e8\u7ed3\u6784\u8fd8\u6ca1\u5904\u7406\u5b8c\r\n                // \u6536\u5230\u7684\u6570\u636e\u6bd4\u5934\u90e8\u7ed3\u6784\u5c0f\r\n                if (bytes_transferred < HEAD_LENGTH) {\r\n                    // \u5148\u63a5\u6536\u8fd9\u90e8\u5206\u6570\u636e\r\n                    memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, bytes_transferred);\r\n                    _recv_head_node->_cur_len += bytes_transferred;\r\n                    // \u6e05\u7a7a _data \u7f13\u51b2\u533a\r\n                    memset(_data, 0, MAX_LENGTH);\r\n                    // \u7ee7\u7eed\u76d1\u542c\r\n                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                            std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                      std::placeholders::_2, self_shared));\r\n                    return;\r\n                }\r\n                // \u6536\u5230\u7684\u6570\u636e\u6bd4\u5934\u90e8\u7ed3\u6784\u5927\r\n                int head_remain = HEAD_LENGTH - _recv_head_node->_cur_len;\r\n                // \u5269\u4f59\u7684\u6570\u636e\u62f7\u8d1d\u8fdb\u53bb\r\n                memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, head_remain);\r\n                _recv_head_node->_cur_len += head_remain;\r\n                copy_len += head_remain;\r\n                bytes_transferred -= head_remain;\r\n                // \u83b7\u53d6\u5934\u90e8\u5b58\u50a8\u7684\u6570\u636e\r\n                short data_len = 0;\r\n                memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);\r\n                // \u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u6362\u4e3a\u672c\u5730\u5b57\u8282\u5e8f\r\n                data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);\r\n\r\n                std::cout << 'Receive data length is ' << data_len << std::endl;\r\n                if (data_len > MAX_LENGTH) {\r\n                    std::cerr << 'invalid data length is ' << data_len << std::endl;\r\n                    return;\r\n                }\r\n\r\n                _recv_msg_node = std::make_shared<MsgNode>(data_len);\r\n                // \u5269\u4f59\u6d88\u606f\u7684\u957f\u5ea6\u5c0f\u4e8e\u6570\u636e\u957f\u5ea6\uff0c\u5148\u5c06\u90e8\u5206\u6570\u636e\u653e\u5230\u8282\u70b9\u91cc\r\n                if (bytes_transferred < data_len) {\r\n                    memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);\r\n                    _recv_msg_node->_cur_len += bytes_transferred;\r\n                    // \u91cd\u7f6e _data\r\n                    memset(_data, 0, MAX_LENGTH);\r\n                    // \u7ee7\u7eed\u76d1\u542c\r\n                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                            std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                      std::placeholders::_2, self_shared));\r\n                    // \u5934\u90e8\u5904\u7406\u5b8c\u6bd5\r\n                    _b_head_parse = true;\r\n                    return;\r\n                }\r\n                // \u5927\u4e8e\u76f4\u63a5\u62f7\u8d1d\u8fdb\u53bb\r\n                memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, data_len);\r\n                _recv_msg_node->_cur_len += data_len;\r\n                copy_len += data_len;\r\n                bytes_transferred -= data_len;\r\n                _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\r\n                // \u8c03\u7528 send \u6d4b\u8bd5\r\n//                MsgData msgData;\r\n//                std::string receive_data;\r\n//                msgData.ParseFromString(std::string(_recv_msg_node->_data,_recv_msg_node->_total_len));\r\n//                std::cout << 'Received msg id  is ' << msgData.id() << ' msg data is ' << msgData.data() <<std:: endl;\r\n//                std::string return_str = 'Server has received msg, msg data is ' + msgData.data();\r\n//                MsgData msgReturn;\r\n//                msgReturn.set_id(msgData.id());\r\n//                msgReturn.set_data(return_str);\r\n//                msgReturn.SerializeToString(&return_str);\r\n//                send(return_str);\r\n//                Json::Reader reader;\r\n//                Json::Value root;\r\n//                reader.parse(std::string(_recv_msg_node->_data, _recv_msg_node->_total_len), root);\r\n//                std::cout << 'Received msg id  is ' << root['id'].asInt() << ' msg data is ''\r\n//                          << root['data'].asString() << ''' << std::endl;\r\n//                root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';\r\n//                send(root.toStyledString());\r\n                send(_recv_msg_node->_data,_recv_msg_node->_total_len);\r\n                // \u7ee7\u7eed\u5904\u7406\u5269\u4e0b\u7684\u5b57\u8282\r\n                _b_head_parse = false;\r\n                _recv_head_node->clear();\r\n                // \u5982\u679c\u5c0f\u4e8e\u7b49\u4e8e0\uff0c\u5176\u5b9e\u53ea\u80fd\u7b49\u4e8e\r\n                if (bytes_transferred <= 0) {\r\n                    // \u9700\u8981\u7ee7\u7eed\u76d1\u542c\r\n                    memset(_data, 0, MAX_LENGTH);\r\n                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                            std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                      std::placeholders::_2, self_shared));\r\n                    return;\r\n                }\r\n                // \u7ee7\u7eed\u5faa\u73af\u5373\u53ef\r\n                continue;\r\n            }\r\n            // \u5934\u7ed3\u70b9\u5904\u7406\u5b8c\u4e86\uff0c\u63a5\u7740\u5904\u7406\u6570\u636e\r\n            int remain_msg = _recv_msg_node->_total_len - _recv_msg_node->_cur_len;\r\n            // \u672c\u6b21\u63a5\u6536\u7684\u8fd8\u662f\u4e0d\u8db3\r\n            if (bytes_transferred < remain_msg) {\r\n                // \u62f7\u8d1d\u90e8\u5206\uff0c\u7ee7\u7eed\u76d1\u542c\r\n                memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);\r\n                _recv_msg_node->_cur_len += bytes_transferred;\r\n                memset(_data, 0, MAX_LENGTH);\r\n                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                        std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                  std::placeholders::_2, self_shared));\r\n                return;\r\n            }\r\n            // \u8db3\u591f\u5c31\u76f4\u63a5\u62f7\u8fdb\u6765\r\n            memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, remain_msg);\r\n            _recv_msg_node->_cur_len += remain_msg;\r\n            copy_len += remain_msg;\r\n            bytes_transferred -= remain_msg;\r\n            _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\r\n            // \u8c03\u7528 send \u6d4b\u8bd5\r\n//            MsgData msgData;\r\n//            std::string receive_data;\r\n//            msgData.ParseFromString(std::string(_recv_msg_node->_data,_recv_msg_node->_total_len));\r\n//            std::cout << 'Received msg id  is ' << msgData.id() << ' msg data is ' << msgData.data() <<std:: endl;\r\n//            std::string return_str = 'Server has received msg, msg data is ' + msgData.data();\r\n//            MsgData msgReturn;\r\n//            msgReturn.set_id(msgData.id());\r\n//            msgReturn.set_data(return_str);\r\n//            msgReturn.SerializeToString(&return_str);\r\n//            send(return_str);\r\n\r\n//            Json::Reader reader;\r\n//            Json::Value root;\r\n//            reader.parse(std::string(_recv_msg_node->_data, _recv_msg_node->_total_len), root);\r\n//            std::cout << 'Received msg id  is ' << root['id'].asInt() << ' msg data is ''\r\n//                      << root['data'].asString() << ''' << std::endl;\r\n//            root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';\r\n//            send(root.toStyledString());\r\n            send(_recv_msg_node->_data,_recv_msg_node->_total_len);\r\n\r\n            // \u7ee7\u7eed\u5904\u7406\r\n            _b_head_parse = false;\r\n            _recv_head_node->clear();\r\n\r\n            // \u4e0d\u5269\u4e0b\u6570\u636e\u4e86\r\n            if (bytes_transferred <= 0) {\r\n                memset(_data, 0, MAX_LENGTH);\r\n                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                        std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                  std::placeholders::_2, self_shared));\r\n                return;\r\n            }\r\n            // \u7ee7\u7eed\u5faa\u73af\u5373\u53ef\r\n            continue;\r\n        }\r\n    } catch (std::exception &e) {\r\n        std::cerr << 'Error occurred: ' << e.what() << std::endl;\r\n    }\r\n}\r\n\r\nvoid CSession::handle_write(const boost::system::error_code &errorCode, std::shared_ptr<CSession> self_shared) {\r\n    try {\r\n        if (errorCode.value() != 0) {\r\n            std::cerr << 'Error occurred int write: ' << errorCode.message() << std::endl;\r\n            // \u79fb\u9664\u8fde\u63a5\r\n            _server->clear_session(_uuid);\r\n            return;\r\n        }\r\n        std::cout << 'Writing to client successfully, start read from client\\n';\r\n\r\n        // \u8c03\u7528\u56de\u8c03\u51fd\u6570\u8868\u793a\u5df2\u7ecf\u5199\u5b8c\r\n        // \u4e0a\u9501\r\n        std::lock_guard<std::mutex> lock(_send_lock);\r\n        // \u5f39\u51fa\u961f\u5217\u5143\u7d20\r\n        _send_que.pop();\r\n        // \u961f\u5217\u662f\u5426\u8fd8\u6709\u5269\u4e0b\u7684\u6d88\u606f\r\n        if (!_send_que.empty()) {\r\n            // \u63a5\u7740\u53d1\uff0c\u76f4\u5230\u961f\u5217\u4e3a\u7a7a\r\n            auto &msgNode = _send_que.front();\r\n            boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\r\n                                     std::bind(&CSession::handle_write, this, std::placeholders::_1, self_shared));\r\n        }\r\n    } catch (std::exception &e) {\r\n        std::cerr << 'Error occurred: ' << e.what() << std::endl;\r\n    }\r\n}\r\n\r\nvoid CSession::send(char *msg, int max_length) {\r\n    // \u53d1\u9001\u961f\u5217\u91cc\u662f\u5426\u8fd8\u6709\u6ca1\u6cd5\u5b8c\u7684\u6570\u636e\r\n    bool pending = false;\r\n    // \u4e0a\u9501\r\n    std::lock_guard<std::mutex> lock(_send_lock);\r\n    int send_que_size = _send_que.size();\r\n    if (send_que_size > MAX_SENDQUE) {\r\n        std::cout << 'session: ' << _uuid << ' send que fulled, size is ' << MAX_SENDQUE << std::endl;\r\n        return;\r\n    }\r\n\r\n    // \u52a0\u5165\u53d1\u9001\u961f\u5217\r\n    _send_que.push(std::make_shared<MsgNode>(msg, max_length));\r\n\r\n    if (send_que_size > 0) {\r\n        // \u4e4b\u524d\u7684\u8fd8\u6ca1\u53d1\u9001\u5b8c\r\n        return;\r\n    }\r\n    auto &msgNode = _send_que.front();\r\n    // \u4e4b\u524d\u7684\u5168\u53d1\u5b8c\u4e86\uff0c\u76f4\u63a5\u53d1\u672c\u6b21\u7684\r\n    boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\r\n                             std::bind(&CSession::handle_write, this, std::placeholders::_1, shared_from_this()));\r\n}\r\n\r\n// \u6253\u5370\u4e8c\u8fdb\u5236\u6570\u636e\r\nvoid CSession::printRecvData(char *data, int length) {\r\n    std::stringstream ss;\r\n    std::string result = '0x';\r\n    for (int i = 0; i < length; i++) {\r\n        std::string hexstr;\r\n        ss << std::hex << std::setw(2) << std::setfill('0') << int(data[i]) << std::endl;\r\n        ss >> hexstr;\r\n        result += hexstr;\r\n    }\r\n    std::cout << 'receive raw data is : ' << result << std::endl;;\r\n}\r\n\r\nvoid CSession::send(std::string msg) {\r\n    std::lock_guard<std::mutex> lock(_send_lock);\r\n\r\n    int send_que_size = _send_que.size();\r\n    if (send_que_size > MAX_SENDQUE) {\r\n        std::cout << 'session: ' << _uuid << ' send que fulled, size is ' << MAX_SENDQUE << std::endl;\r\n        return;\r\n    }\r\n    _send_que.push(std::make_shared<MsgNode>(msg.c_str(), msg.size()));\r\n    if (send_que_size > 0) {\r\n        return;\r\n    }\r\n    auto &msgNode = _send_que.front();\r\n    boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\r\n                             std::bind(&CSession::handle_write, this, std::placeholders::_1, shared_from_this()));\r\n}\r\n\r\nvoid CSession::handle_read_head(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                                std::shared_ptr<CSession> self_shared) {\r\n    if (errorCode.value() != 0) {\r\n        std::cerr << 'Error occurred in read head: ' << errorCode.message() << std::endl;\r\n        // \u79fb\u9664\u8fde\u63a5\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n    if (bytes_transferred < HEAD_LENGTH) {\r\n        std::cerr << 'Error occurred in read head: ' << errorCode.message() << std::endl;\r\n        // \u79fb\u9664\u8fde\u63a5\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n    // \u89e3\u6790\u5305\u5934\u6570\u636e\r\n    short data_len = 0;\r\n    memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);\r\n    // \u5b57\u8282\u5e8f\u5904\u7406\r\n    data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);\r\n    if (data_len > MAX_LENGTH) {\r\n        std::cerr << 'Invalid data length :' << data_len << std::endl;\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n\r\n\r\n    _recv_msg_node = std::make_shared<MsgNode>(data_len);\r\n\r\n    boost::asio::async_read(_socket, boost::asio::buffer(_recv_msg_node->_data, _recv_msg_node->_total_len),\r\n                            std::bind(&CSession::handle_read_msg, this, std::placeholders::_1, std::placeholders::_2,\r\n                                      shared_from_this()));\r\n}\r\n\r\nvoid CSession::handle_read_msg(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                               std::shared_ptr<CSession> self_shared) {\r\n    if (errorCode.value() != 0) {\r\n        std::cerr << 'Error occurred in read msg: ' << errorCode.message() << std::endl;\r\n        // \u79fb\u9664\u8fde\u63a5\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n    // \u6d4b\u8bd5\u7c98\u5305\r\n    printRecvData(_recv_msg_node->_data, bytes_transferred);\r\n    std::chrono::milliseconds dura(2000);\r\n    std::this_thread::sleep_for(dura);\r\n    _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\r\n    std::cout << 'receive data is ' << _recv_msg_node->_data << std::endl;\r\n    send(_recv_msg_node->_data, _recv_msg_node->_total_len);\r\n    // \u518d\u6b21\u63a5\u6536\u5934\u90e8\u6570\u636e\r\n    _recv_head_node->clear();\r\n    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node->_data, HEAD_LENGTH),\r\n                            std::bind(&CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,\r\n                                      shared_from_this()));\r\n}\r\n```\u3002", "top": 0, "createdAt": 1727070414, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P3": {"htmlDir": "docs/post/duo-xian-cheng-Asio.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "\u591a\u7ebf\u7a0bAsio", "postUrl": "post/duo-xian-cheng-Asio.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/3", "commentNum": 0, "wordCount": 7499, "description": "# \u591a\u7ebf\u7a0b\u6a21\u578b\r\nasio \u7684\u591a\u7ebf\u7a0b\u6a21\u578b\u6709\u4e24\u79cd\uff0cIOServicePool \u548c IOThreadPool\r\n# IOServicePool\r\nIOServicePool\u6a21\u578b\uff1a\r\n![image-20240801133223177](https://github.com/user-attachments/assets/c036abee-852d-42a7-ab2d-b2acb054f14f)\r\n\u7279\u70b9:\r\n1. \u6bcf\u4e2a io_context \u90fd\u8fd0\u884c\u5728\u4e0d\u540c\u7684\u7ebf\u7a0b\u5185\uff0c\u5bf9\u4e8e\u4e00\u4e2a socket\uff0c\u4f1a\u6ce8\u518c\u5728\u540c\u4e00\u4e2a io_context \u5185\uff0c\u5e76\u4e14\u56de\u8c03\u51fd\u6570\u7684\u89e6\u53d1\u4e5f\u662f\u5728\u540c\u4e00\u4e2a\u7ebf\u7a0b\u5185\uff0c\u4e0d\u5b58\u5728\u5e76\u53d1\u5b89\u5168\u95ee\u9898\r\n2. \u4e0d\u540c\u7684 socket\uff0c\u56de\u8c03\u51fd\u6570\u53ef\u80fd\u7531\u4e0d\u540c\u7684\u7ebf\u7a0b\u8c03\u7528\uff0c\u5982\u679c\u56de\u8c03\u51fd\u6570\u4e2d\u8fdb\u884c\u4e86\u5171\u4eab\u6570\u636e\u7684\u4fee\u6539\uff0c\u5c31\u4f1a\u5b58\u5728\u7ebf\u7a0b\u5b89\u5168\u95ee\u9898\uff0c\u8fd9\u65f6\u53ef\u4ee5\u5728\u56de\u8c03\u51fd\u6570\u4e2d\u52a0\u9501\u6216\u8005\u4f7f\u7528\u903b\u8f91\u961f\u5217\u7684\u65b9\u5f0f\r\n3. \u591a\u7ebf\u7a0b\u6a21\u5f0f\u6781\u5927\u7684\u63d0\u9ad8\u4e86\u5e76\u53d1\u80fd\u529b\uff1b\u5355\u7ebf\u7a0b\u6a21\u5f0f\u4e0b\u5982\u679c\u56de\u8c03\u51fd\u6570\u8c03\u7528\u65f6\u95f4\u8fc7\u957f\uff0c\u4f1a\u5f71\u54cd\u540e\u7eed\u51fd\u6570\u7684\u8c03\u7528\uff1b\u901a\u8fc7\u903b\u8f91\u961f\u5217\u7684\u65b9\u5f0f\u5c06\u7f51\u7edc\u7ebf\u7a0b\u548c\u903b\u8f91\u7ebf\u7a0b\u89e3\u8026\u5408\u4e86\uff0c\u4e0d\u4f1a\u51fa\u73b0\u524d\u4e00\u4e2a\u8c03\u7528\u65f6\u95f4\u5f71\u54cd\u4e0b\u4e00\u4e2a\u56de\u8c03\u89e6\u53d1\u7684\u95ee\u9898\r\n## \u5b9e\u73b0\r\n\r\n\u672c\u8d28\u5c31\u662f\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u57fa\u672c\u529f\u80fd\u5c31\u662f\u6839\u636e\u6784\u9020\u51fd\u6570\u4f20\u5165\u7684\u6570\u91cf\u521b\u5efan\u4e2a\u7ebf\u7a0b\u548c io_context\uff0c\u7136\u540e\u6bcf\u4e2a\u7ebf\u7a0b\u8dd1\u4e00\u4e2a io_context\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5e76\u53d1\u5904\u7406\u4e0d\u540c io_context \u8bfb\u5199\u4e8b\u4ef6\u4e86\u3002", "top": 0, "createdAt": 1727070687, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P5": {"htmlDir": "docs/post/Asio-shi-xian-Http-fu-wu-qi.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Asio\u5b9e\u73b0Http\u670d\u52a1\u5668", "postUrl": "post/Asio-shi-xian-Http-fu-wu-qi.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/5", "commentNum": 0, "wordCount": 8475, "description": "# Http\u7b80\u4ecb\r\n\r\n## Http\u5305\u5934\u4fe1\u606f\r\n\r\n\u4e00\u4e2a\u6807\u51c6\u7684HTTP\u62a5\u6587\u5934\u901a\u5e38\u7531\u8bf7\u6c42\u5934\u548c\u54cd\u5e94\u5934\u4e24\u90e8\u5206\u7ec4\u6210\u3002", "top": 0, "createdAt": 1727071229, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P6": {"htmlDir": "docs/post/Beast-shi-xian-websocket-fu-wu-qi.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Beast\u5b9e\u73b0websocket\u670d\u52a1\u5668", "postUrl": "post/Beast-shi-xian-websocket-fu-wu-qi.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/6", "commentNum": 0, "wordCount": 24558, "description": "# \u6d41\u5bf9\u8c61\r\n\r\nWebSocket\u8fde\u63a5\u9700\u8981\u4e00\u4e2a\u6709\u72b6\u6001\u5bf9\u8c61\uff0c\u7531Beast\u4e2d\u7684\u4e00\u4e2a\u7c7b\u6a21\u677fwebsocket::stream\u8868\u793a\u3002", "top": 0, "createdAt": 1727071296, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P7": {"htmlDir": "docs/post/Grpc.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Grpc", "postUrl": "post/Grpc.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/7", "commentNum": 0, "wordCount": 4045, "description": "# \u4e0b\u8f7d\r\n\r\nvcpkg install grpc\r\n\r\n# \u914d\u7f6e\r\n\r\ncmake \u4e2d\uff1a\r\n\r\n```cmake\r\nfind_package(Protobuf CONFIG REQUIRED)\r\nfind_package(gRPC CONFIG REQUIRED)\r\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\r\narget_link_libraries(${projectName} PRIVATE gRPC::grpc++ protobuf::libprotobuf)\r\n```\r\n\r\n# \u7f16\u8bd1\r\n\r\n\u7f16\u5199\u597d proto\u6587\u4ef6\uff0c\u5728 powershell \u4e2d\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4\uff0c\u63d2\u4ef6\u9009\u62e9\u81ea\u5df1\u7684\u8def\u5f84\uff1a\r\n\r\n```cmd\r\nprotoc --proto_path=. --cpp_out=. demo.proto\r\nprotoc --proto_path=. --grpc_out=. --plugin=protoc-gen-grpc='D:\\develop_tools\\cppsoft\\vcpkg\\packages\\grpc_x64-windows\\tools\\grpc\\grpc_cpp_plugin.exe' demo.proto\r\n```\r\n\r\n\u751f\u6210\u6587\u4ef6\u6dfb\u52a0\u5230 cmakelists.txt \u4e2d\r\n\r\n# \u901a\u4fe1\u6d41\u7a0b\r\n\r\n1. \u8fde\u63a5\u5230\u670d\u52a1\u7aef\u7684\u5730\u5740\r\n2. \u521b\u5efa\u5ba2\u6237\u7aef\u5b9e\u4f8b\uff0c\u8c03\u7528\u51fd\u6570\uff0c\u5c06\u8bf7\u6c42\u6d88\u606f\u53d1\u9001\u7ed9\u670d\u52a1\u7aef\r\n3. \u670d\u52a1\u7aef\u63a5\u6536\u5230\u8bf7\u6c42\uff0c\u5904\u7406\u8bf7\u6c42\u6d88\u606f\u5e76\u751f\u6210\u54cd\u5e94\u6d88\u606f\u3002", "top": 0, "createdAt": 1727071411, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P8": {"htmlDir": "docs/post/Asio-xie-cheng.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Asio\u534f\u7a0b", "postUrl": "post/Asio-xie-cheng.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/8", "commentNum": 0, "wordCount": 2481, "description": "# \u534f\u7a0b\r\n\u534f\u7a0b\uff0c\u82f1\u6587Coroutines\uff0c\u662f\u4e00\u79cd\u57fa\u4e8e\u7ebf\u7a0b\u4e4b\u4e0a\uff0c\u4f46\u53c8\u6bd4\u7ebf\u7a0b\u66f4\u52a0\u8f7b\u91cf\u7ea7\u7684\u5b58\u5728\uff0c\u8fd9\u79cd\u7531\u7a0b\u5e8f\u5458\u81ea\u5df1\u5199\u7a0b\u5e8f\u6765\u7ba1\u7406\u7684\u8f7b\u91cf\u7ea7\u7ebf\u7a0b\u53eb\u505a\u300e\u7528\u6237\u7a7a\u95f4\u7ebf\u7a0b\u300f\uff0c\u5177\u6709\u5bf9\u5185\u6838\u6765\u8bf4\u4e0d\u53ef\u89c1\u7684\u7279\u6027\u3002", "top": 0, "createdAt": 1727071496, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P9": {"htmlDir": "docs/post/DS_1\uff1a-xian-xing-biao.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_1\uff1a\u7ebf\u6027\u8868", "postUrl": "post/DS_1%EF%BC%9A-xian-xing-biao.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/9", "commentNum": 0, "wordCount": 32558, "description": "# \u7ebf\u6027\u8868\r\n\u7ebf\u6027\u8868\u662f\u5177\u6709\u76f8\u540c\u6570\u636e\u7c7b\u578b\u7684n\uff08n\u22650\uff09\u4e2a\u6570\u636e\u5143\u7d20\u7684**\u6709\u9650\u5e8f\u5217**\uff0c\u5176\u4e2dn\u4e3a\u8868\u957f\uff0c\u5f53n = 0\u65f6\u7ebf\u6027\u8868\u662f\u4e00\u4e2a\u7a7a\u8868\u3002", "top": 0, "createdAt": 1727079656, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P10": {"htmlDir": "docs/post/DS_2\uff1a-zhan.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_2\uff1a\u6808", "postUrl": "post/DS_2%EF%BC%9A-zhan.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/10", "commentNum": 0, "wordCount": 3475, "description": "# \u6808\r\n\u5b9a\u4e49\uff1a\u53ea\u5141\u8bb8\u5728\u4e00\u7aef\u8fdb\u884c\u64cd\u4f5c\uff08\u63d2\u5165\u3001\u5220\u9664\uff09\u7684\u7ebf\u6027\u8868\r\n\u57fa\u672c\u64cd\u4f5c\uff1a\r\n1. \u521d\u59cb\u5316\u6808\r\n2. \u91ca\u653e\u5185\u5b58\r\n3. \u8fdb\u6808\r\n4. \u51fa\u6808\r\n5. \u83b7\u53d6\u6808\u9876\u5143\u7d20\r\n6. \u5224\u7a7a\r\n## \u987a\u5e8f\u6808\r\n\u5b9e\u73b0:\u9759\u6001\u6570\u7ec4\u4e2d\u5b58\u653e\u6808\u5143\u7d20\r\n```C\r\n#define Type int\r\n#define MAX_SIZE 10\r\ntypedef struct Stack {\r\n    // \u5b58\u653e\u6808\u5143\u7d20\r\n    Type data[MAX_SIZE];\r\n    // \u6808\u9876\u6307\u9488\r\n    int top;\r\n} Stack;\r\n\r\nvoid initStack(Stack *s) {\r\n    // \u6808\u4e3a\u7a7a\r\n    s->top = -1;\r\n}\r\n\r\nvoid destructorStack(Stack *s) {\r\n    s->top = -1;\r\n}\r\n\r\nbool isEmpty(Stack *s) {\r\n    return s->top == -1;\r\n}\r\n\r\nbool push(Stack *s, Type e) {\r\n    if (s->top == MAX_SIZE - 1) {\r\n        printf('Stack is full');\r\n        return false;\r\n    }\r\n    s->data[++s->top] = e;\r\n    return true;\r\n}\r\n\r\nbool pop(Stack *s) {\r\n    if (isEmpty(s)) {\r\n        printf('Stack is empty');\r\n        return false;\r\n    }\r\n    s->top--;\r\n    return true;\r\n}\r\n\r\nType front(Stack*s){\r\n    if (isEmpty(s)) {\r\n        printf('Stack is empty');\r\n        return false;\r\n    }\r\n    return s->data[s->top];\r\n}\r\n```\r\n\u4e5f\u53ef\u4ee5\u5c06top\u521d\u59cb\u5316\u4e3a0\uff0c\u8fd9\u6837top\u6307\u5411\u7684\u5c31\u662f\u4e0b\u4e00\u4e2a\u5165\u6808\u7684\u4f4d\u7f6e\r\n## \u5171\u4eab\u6808\r\n\u5c31\u662f\u5728\u987a\u5e8f\u6808\u7684\u57fa\u7840\u4e0a\uff0c\u518d\u6dfb\u52a0\u4e00\u4e2atop\u6807\u8bb0\uff0c\u5c06\u4e00\u6574\u7247\u6570\u7ec4\u7a7a\u95f4\u5206\u4e3a\u4e24\u4e2a\u6808\u4f7f\u7528\uff0ctop0\u662f\u4ece\u6570\u7ec4\u7684\u7d22\u5f150\u5411\u4e0a\uff0ctop1\u4ece\u6570\u7ec4\u7684\u6700\u5927\u7d22\u5f15\u5411\u4e0b\uff1b\u76f8\u4ea4\u7684\u65f6\u5019\u5c31\u662f\u6ee1\u4e86\r\n\r\n## \u94fe\u5f0f\u6808\r\n\u6bcf\u4e2a\u5143\u7d20\u5c31\u662f\u4e00\u4e2a\u94fe\u8868\u7ed3\u70b9\uff0c\u5b9e\u73b0\u6808\u7684\u529f\u80fd\u5c31\u884c\uff0c\u4e5f\u662f\u5206\u4e3a\u5e26\u5934\u7ed3\u70b9\u548c\u4e0d\u5e26\u5934\u7ed3\u70b9\r\n\u4e0d\u5e26\u5934\u7ed3\u70b9:\r\n```C\r\n#define Type int\r\ntypedef struct Node {\r\n    Type data;\r\n    struct Node *next;\r\n} Node;\r\ntypedef Node *stack;\r\n\r\nvoid initStack(stack *s) {\r\n    (*s) = NULL;\r\n}\r\n\r\nvoid destructor(stack *s) {\r\n    Node *p = *s;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*s) = NULL;\r\n}\r\n\r\nbool push(stack *s, Type e) {\r\n    Node *p = *s;\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Failed to allocate memory');\r\n        return false;\r\n    }\r\n    newNode->data = e;\r\n    newNode->next = p;\r\n    *s = newNode;\r\n    return true;\r\n}\r\n\r\nbool pop(stack *s) {\r\n    if (*s == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return false;\r\n    }\r\n    Node *p = *s;\r\n    (*s) = (*s)->next;\r\n    free(p);\r\n    return true;\r\n}\r\n\r\nType front(stack *s) {\r\n    if (*s == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return -1;\r\n    }\r\n    return (*s)->data;\r\n}\r\n```\r\n\u5e26\u5934\u7ed3\u70b9\uff1a\r\n```C\r\n#define Type int\r\ntypedef struct Node {\r\n    Type data;\r\n    struct Node *next;\r\n} Node;\r\ntypedef Node *stack;\r\n\r\nvoid constructor(stack *s) {\r\n    // \u5206\u914d\u5934\u7ed3\u70b9\r\n    (*s) = (Node *) malloc(sizeof(Node));\r\n    if (*s == NULL) {\r\n        printf('Failed to allocate memory');\r\n        return;\r\n    }\r\n    (*s)->data = -1;\r\n    (*s)->next = NULL;\r\n}\r\n\r\nvoid destructor(stack *s) {\r\n    if (*s == NULL) {\r\n        return;\r\n    }\r\n    Node *p = *s;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*s) = NULL;\r\n}\r\n\r\nbool push(stack *s, Type e) {\r\n    if (*s == NULL) {\r\n        printf('stack is not initialized');\r\n        return false;\r\n    }\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Failed to allocate memory');\r\n        return false;\r\n    }\r\n    newNode->data = e;\r\n    newNode->next = (*s)->next;\r\n    (*s)->next = newNode;\r\n    return true;\r\n}\r\n\r\nbool pop(stack *s) {\r\n    if ((*s) == NULL || (*s)->next == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return false;\r\n    }\r\n    Node *p = (*s)->next;\r\n    (*s)->next = p->next;\r\n    free(p);\r\n    return true;\r\n}\r\n\r\nType front(stack *s) {\r\n    if ((*s) == NULL || (*s)->next == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return -1;\r\n    }\r\n    return (*s)->next->data;\r\n}\r\n```\r\n\u4ee3\u7801\u5730\u5740\uff1ahttps://github.com/proacane/DataStructure\u3002", "top": 0, "createdAt": 1727332265, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-26", "dateLabelColor": "#bc4c00"}, "P11": {"htmlDir": "docs/post/cao-zuo-xi-tong-gai-shu.html", "labels": ["\u64cd\u4f5c\u7cfb\u7edf"], "postTitle": "\u64cd\u4f5c\u7cfb\u7edf\u6982\u8ff0", "postUrl": "post/cao-zuo-xi-tong-gai-shu.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/11", "commentNum": 0, "wordCount": 1721, "description": "# \u64cd\u4f5c\u7cfb\u7edf\u7684\u6982\u5ff5\r\n\u64cd\u4f5c\u7cfb\u7edf\uff08Operating System\uff0c OS\uff09\u662f\u6307\u63a7\u5236\u548c**\u7ba1\u7406**\u6574\u4e2a\u8ba1\u7b97\u673a\u7cfb\u7edf\u7684**\u786c\u4ef6\u548c\u8f6f\u4ef6**\u8d44\u6e90\uff0c\u5e76\u5408\u7406\u5730\u7ec4\u7ec7\u8c03\u5ea6\u8ba1\u7b97\u673a\u7684\u5de5\u4f5c\u548c\u8d44\u6e90\u7684\u5206\u914d\uff1b\u4ee5**\u63d0\u4f9b\u7ed9\u7528\u6237\u548c\u5176\u4ed6\u8f6f\u4ef6\u65b9\u4fbf\u7684\u63a5\u53e3\u548c\u73af\u5883**\uff1b\u5b83\u662f\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d**\u6700\u57fa\u672c\u7684\u7cfb\u7edf\u8f6f\u4ef6**\r\n# \u7279\u5f81\r\n\u64cd\u4f5c\u7cfb\u7edf\u76844\u4e2a\u7279\u5f81\uff1a\r\n1. \u5e76\u53d1\r\n2. \u5171\u4eab\r\n3. \u865a\u62df\r\n4. \u5f02\u6b65\r\n\u5176\u4e2d\uff0c\u5e76\u53d1\u3001\u5171\u4eab\u662f\u64cd\u4f5c\u7cfb\u7edf\u6700\u57fa\u672c\u7684\u7279\u5f81\uff0c\u5e76\u4e14\u4e8c\u8005\u76f8\u4e92\u4f9d\u5b58\r\n## \u5e76\u53d1\r\n\u5e76\u53d1\u662f\u6307\u4e24\u4e2a\u6216\u591a\u4e2a\u4e8b\u4ef6\u5728\u540c\u4e00\u65f6\u95f4\u95f4\u9694\u5185\u53d1\u751f\uff0c\u5728\u5b8f\u89c2\u770b\u6765\u662f\u540c\u65f6\u53d1\u751f\u7684\uff0c\u4f46\u662f\u5fae\u89c2\u4e0a\u662f\u4ea4\u66ff\u8fd0\u884c\u7684\uff1b\r\n\u64cd\u4f5c\u7cfb\u7edf\u7684\u5e76\u53d1\u6307\u7684\u662f\u53ef\u4ee5\u540c\u65f6\u5b58\u5728\u591a\u4e2a\u8fd0\u884c\u7684\u7a0b\u5e8f\r\n\u5e76\u884c\uff1a\u6307\u591a\u4e2a\u4e8b\u4ef6\u5728\u540c\u4e00\u65f6\u523b\u540c\u65f6\u53d1\u751f\r\n\u5355\u6838 cpu \u540c\u4e00\u65f6\u523b\u53ea\u80fd\u8fd0\u884c\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u53ea\u80fd\u5e76\u53d1\r\n\u591a\u6838 cpu \u540c\u4e00\u65f6\u523b\u53ef\u4ee5\u8fd0\u884c\u591a\u4e2a\u8fdb\u7a0b\uff0c\u65e2\u5b58\u5728\u5e76\u53d1\u3001\u4e5f\u5b58\u5728\u5e76\u884c\r\n## \u5171\u4eab\r\n\u5171\u4eab\uff1a\u6307\u7cfb\u7edf\u4e2d\u7684\u8d44\u6e90\u53ef\u4ee5\u88ab\u591a\u4e2a\u5e76\u53d1\u6267\u884c\u7684\u8fdb\u7a0b\u4f7f\u7528\r\n\u4e92\u65a5\u5171\u4eab\uff1a\u7cfb\u7edf\u4e2d\u7684\u67d0\u4e9b\u8d44\u6e90\uff0c\u867d\u7136\u53ef\u4ee5\u63d0\u4f9b\u7ed9\u591a\u4e2a\u8fdb\u7a0b\u4f7f\u7528\uff0c\u4f46\u4e00\u4e2a\u65f6\u95f4\u6bb5\u5185\u53ea\u5141\u8bb8\u4e00\u4e2a\u8fdb\u7a0b\u8bbf\u95ee\u8be5\u8d44\u6e90\uff0c\u4f8b\u5982\u6444\u50cf\u5934\u7b49\u8d44\u6e90\r\n\u540c\u65f6\u5171\u4eab\uff1a\u7cfb\u7edf\u4e2d\u7684\u67d0\u4e9b\u8d44\u6e90\uff0c\u5141\u8bb8\u4e00\u4e2a\u65f6\u95f4\u6bb5\u5185\u7531\u591a\u4e2a\u8fdb\u7a0b\u201c\u540c\u65f6\u201d\u5bf9\u5b83\u4eec\u8fdb\u884c\u8bbf\u95ee\uff0c\u4f8b\u5982\u78c1\u76d8\u7684\u8bfb\u5199\r\n\u4ece\u5171\u4eab\u7684\u5b9a\u4e49\u5c31\u53ef\u4ee5\u770b\u51fa\u6765\uff0c\u82e5\u64cd\u4f5c\u7cfb\u7edf\u6ca1\u6709\u5e76\u53d1\u6027\uff0c\u5171\u4eab\u5c31\u6ca1\u6709\u610f\u4e49\uff1b\u6ca1\u6709\u5171\u4eab\u6027\uff0c\u5e76\u53d1\u4e5f\u6ca1\u6709\u610f\u4e49\r\n## \u865a\u62df\r\n\u865a\u62df\u662f\u6307\u628a\u4e00\u4e2a\u7269\u7406\u4e0a\u7684\u5b9e\u4f53\u53d8\u4e3a\u82e5\u5e72\u4e2a\u903b\u8f91\u4e0a\u7684\u5bf9\u5e94\u7269\u3002", "top": 0, "createdAt": 1727335375, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-26", "dateLabelColor": "#bc4c00"}}, "singeListJson": {}, "labelColorDict": {"bug": "#d73a4a", "C\u8bed\u8a00": "#006b75", "documentation": "#0075ca", "duplicate": "#cfd3d7", "enhancement": "#a2eeef", "good first issue": "#7057ff", "help wanted": "#008672", "invalid": "#e4e669", "question": "#d876e3", "wontfix": "#ffffff", "\u64cd\u4f5c\u7cfb\u7edf": "#f9d0c4", "\u6570\u636e\u7ed3\u6784": "#fbca04", "\u7f51\u7edc\u7f16\u7a0b": "#158E9B"}, "displayTitle": "Proacane\u7684\u4e2a\u4eba\u5fae\u535a", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://proacane.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}