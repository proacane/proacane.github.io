{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "Proacane\u7684\u4e2a\u4eba\u5fae\u535a", "subTitle": "\u5b66\u65e0\u6b62\u5883", "avatarUrl": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "faviconUrl": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "GMEEK_VERSION": "last", "postListJson": {"P2": {"htmlDir": "docs/post/Asio-wang-luo-ku-zhai-yao.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Asio\u7f51\u7edc\u5e93\u6458\u8981", "postUrl": "post/Asio-wang-luo-ku-zhai-yao.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/2", "commentNum": 0, "wordCount": 23938, "description": "# \u5355\u7ebf\u7a0b\u901a\u4fe1\u6d41\u7a0b\r\n![image-20240726093453475](https://github.com/user-attachments/assets/a53c98fb-c149-403e-b102-d110905e5eb4)\r\n# \u540c\u6b65\u8bfb\u5199\u7684\u793a\u4f8b\r\n- \u670d\u52a1\u7aef\r\n```cpp\r\n#include <iostream>\r\n#include <boost/asio.hpp>\r\n#include <memory>\r\n#include <set>\r\n#include <thread>\r\n\r\nusing namespace std;\r\nusing namespace boost::asio::ip;\r\n\r\nconst int MAX_LEN = 1024;\r\ntypedef shared_ptr<tcp::socket> socket_ptr;\r\nstd::set<std::shared_ptr<std::thread>> thread_set;\r\n\r\nvoid session(socket_ptr sock) {\r\n    try {\r\n        for (;;) {\r\n            char data[MAX_LEN];\r\n            boost::system::error_code error;\r\n            // \u8bfb\u53d6\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u5185\u5bb9\r\n            size_t length = sock->read_some(boost::asio::buffer(data), error);\r\n\r\n            if (error == boost::asio::error::eof) {\r\n                std::cout << 'Connection closed by peer\\n';\r\n                break;\r\n            } else if (error) {\r\n                throw boost::system::system_error(error);\r\n            }\r\n\r\n            std::string received_message(data, length);\r\n            std::cout << 'Received from ' << sock->remote_endpoint().address().to_string() << ': ' << received_message << std::endl;\r\n\r\n            // \u8f6c\u6362\u4e3a \u5927\u5199\r\n            // Process the received message (e.g., convert to upper case)\r\n            std::transform(received_message.begin(), received_message.end(), received_message.begin(), ::toupper);\r\n            // \u518d\u5199\u56de\u5ba2\u6237\u7aef\r\n            boost::asio::write(*sock, boost::asio::buffer(received_message));\r\n        }\r\n    } catch (exception &e) {\r\n        std::cerr << 'Exception in thread: ' << e.what() << std::endl;\r\n    }\r\n}\r\n\r\n// \u5efa\u7acb\u8fde\u63a5\r\nvoid server(boost::asio::io_context &ios, unsigned short port_num) {\r\n    boost::asio::ip::tcp::acceptor acceptor(ios, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port_num));\r\n    std::cout << 'Server started on port ' << port_num << std::endl;\r\n    // \u6ca1\u8fde\u63a5\u5c31\u4e00\u76f4\u963b\u585e\r\n    for (;;) {\r\n        socket_ptr socket(new tcp::socket(ios));\r\n        acceptor.accept(*socket);\r\n        std::cout << 'Accepted connection from ' << socket->remote_endpoint().address().to_string() << std::endl;\r\n        // \u4e3a\u8fde\u63a5\u521b\u5efa\u4e00\u4e2a\u7ebf\u7a0b\uff0c\u5f00\u59cb\u901a\u4fe1\r\n        auto t = make_shared<std::thread>(session, socket);\r\n        thread_set.insert(t);\r\n    }\r\n}\r\n\r\nint main() {\r\n    try {\r\n        boost::asio::io_context ios;\r\n        server(ios, 1234);\r\n        // \u9632\u6b62\u6709\u6570\u636e\u672a\u4f20\u8f93\u5b8c\u65f6\uff0c\u4e3b\u7ebf\u7a0b\u5c31\u7ed3\u675f\u4e86\r\n        for (auto &t: thread_set) {\r\n            t->join();\r\n        }\r\n    } catch (exception &e) {\r\n        std::cerr << 'Exception in main thread: ' << e.what() << std::endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n# \u5f02\u6b65\u8bfb\u5199\u793a\u4f8b\r\n![image-20240726095026183](https://github.com/user-attachments/assets/bd621b55-b962-4eaf-9488-5bb8f7c47f79)\r\n## \u6ce8\u610f\u7684\u95ee\u9898\r\n\r\n- \u5f02\u5e38\u5904\u7406\u65f6\uff0c\u4e3a\u9632\u6b62 Session \u4e8c\u6b21\u6790\u6784\uff0c\u9700\u8981\u7ee7\u627f std::enable_shared_from_this<CSession>\uff1b\u4f7f\u7528\u667a\u80fd\u6307\u9488\u4e0e map \u5ef6\u957f Session \u7684\u751f\u547d\u5468\u671f\r\n\r\n- \u53d1\u9001\u6d88\u606f\u65f6\uff0c\u4e3a\u4fdd\u8bc1\u6d88\u606f\u7684\u6709\u5e8f\u6027\uff0c\u9700\u8981\u589e\u52a0\u53d1\u9001\u961f\u5217\r\n\r\n- \u5904\u7406\u7c98\u5305\u95ee\u9898\uff0c\u6d88\u606f\u7ed3\u6784\u91c7\u7528 TLV \u683c\u5f0f\uff0c\u4f7f\u7528 async_read_some \u6bd4\u8f83\u9ebb\u70e6\uff0c\u4f7f\u7528 async_read \u6bd4\u8f83\u7b80\u6d01\r\n\r\n  \u200b\t\t\t\t\t\t\t![image-20240726093831093](https://github.com/user-attachments/assets/45a3e63d-53d6-4124-b647-d9742bc9897e)\r\n\r\n  - async_read_some\uff1a\u56de\u8c03\u51fd\u6570\u91cc\u4e0d\u65ad\u5224\u65ad\u5df2\u7ecf\u5904\u7406\u7684\u5b57\u8282\r\n\r\n  - async_read\uff1a\u4e24\u5c42\u56de\u8c03\uff0c\u7b2c\u4e00\u5c42\u5904\u7406\u5305\u5934\uff0c\u7b2c\u4e8c\u5c42\u5904\u7406\u5305\u4f53\r\n\r\n- \u5b57\u8282\u5e8f\u7684\u5904\u7406\uff1a\u53d1\u9001\u524d\u8f6c\u6362\u4e3a\u7f51\u7edc\u5b57\u8282\u5e8f\uff0c\u63a5\u6536\u540e\u8f6c\u6362\u4e3a\u672c\u5730\u5b57\u8282\u5e8f (boost::asio::detail::socket_ops::network_to_host_short)\r\n- \u53d1\u9001\u6570\u636e\u4f7f\u7528jsoncpp\u8fdb\u884c\u5c01\u88c5\r\n\r\nCServer.h\r\n\r\n```cpp\r\n#ifndef ASYNCSERVER_CSERVER_H\r\n#define ASYNCSERVER_CSERVER_H\r\n#include 'CSession.h'\r\n#include <iostream>\r\nclass CSession;\r\n/**\r\n * \u63a5\u53d7\u65b0\u7684\u5ba2\u6237\u7aef\u8fde\u63a5\uff0c\u6bcf\u4e2a\u8fde\u63a5\u90fd\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Session \u5b9e\u4f8b\r\n */\r\nclass CServer {\r\npublic:\r\n    CServer(boost::asio::io_context &ioc, unsigned short port_num);\r\n    // \u79fb\u9664\u5df2\u5904\u7406\u5b8c\u6210\u7684 Session \u5b9e\u4f8b\r\n    void clear_session(std::string uuid);\r\nprivate:\r\n    // \u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Session \u5e76\u7b49\u5f85\u65b0\u7684\u5ba2\u6237\u7aef\u8fde\u63a5\r\n    void start_accept();\r\n    // \u5904\u7406\u65b0\u7684\u5ba2\u6237\u7aef\u8fde\u63a5\uff0c\u5c06\u5176\u52a0\u5165 _sessions \u4e2d\uff0c\u5e76\u542f\u52a8\u6570\u636e\u5904\u7406\r\n    void handle_accept(std::shared_ptr<CSession> newSession, const boost::system::error_code errorCode);\r\n\r\n    boost::asio::io_context &_ioc;\r\n    boost::asio::ip::tcp::acceptor _acceptor;\r\n    // \u7ba1\u7406\u8fde\u63a5\r\n    std::map<std::string, std::shared_ptr<CSession>> _sessions;\r\n\r\n};\r\n#endif //ASYNCSERVER_CSERVER_H\r\n```\r\n\r\nCServer.cpp\r\n\r\n```cpp\r\n#include 'CServer.h'\r\n\r\nCServer::CServer(boost::asio::io_context &ioc, unsigned short port_num) : _ioc(ioc),\r\n                                                                          _acceptor(_ioc,\r\n                                                                                    tcp::endpoint(tcp::v4(),\r\n                                                                                                  port_num)) {\r\n    std::cout << 'Acceptor create succeed! port number is ' << port_num << std::endl;\r\n    start_accept();\r\n}\r\n\r\nvoid CServer::start_accept() {\r\n    // \u4f7f\u7528\u667a\u80fd\u6307\u9488\u6765\u7ba1\u7406 session \u5b9e\u4f8b\uff0c\u4ee5\u4fdd\u8bc1\u4e0d\u4f1a\u4e8c\u6b21\u6790\u6784\r\n    std::shared_ptr<CSession> newSession = std::make_shared<CSession>(_ioc, this);\r\n    // \u7ed1\u5b9a\u5230\u670d\u52a1\u4e0a\uff0c\u65b0\u8fde\u63a5\u5230\u6765\u540e\u89e6\u53d1\u56de\u8c03\u51fd\u6570 handle_accept\r\n    _acceptor.async_accept(newSession->get_socket(),\r\n                           std::bind(&CServer::handle_accept, this, newSession, std::placeholders::_1));\r\n\r\n}\r\n\r\nvoid CServer::handle_accept(std::shared_ptr<CSession> newSession, const boost::system::error_code errorCode) {\r\n    if (errorCode.value() != 0) {\r\n        std::cerr << 'Error occurred int accept connection: ' << errorCode.message() << std::endl;\r\n//        delete newSession;\r\n    } else {\r\n        std::cout << 'Accept connection successfully ' << std::endl;\r\n        std::cout << 'Start dealing with data' << std::endl;\r\n        // \u6ca1\u95ee\u9898\u5c31\u5f00\u59cb\u5904\u7406\u6570\u636e\r\n        newSession->start();\r\n        _sessions.insert(std::make_pair(newSession->get_uuid(), newSession));\r\n    }\r\n    // \u7ee7\u7eed\u63a5\u6536\u65b0\u8fde\u63a5\r\n    start_accept();\r\n}\r\n\r\nvoid CServer::clear_session(std::string uuid) {\r\n    _sessions.erase(uuid);\r\n}\r\n```\r\n\r\nCSession.h\r\n\r\n```cpp\r\n#ifndef ASYNCSERVER_CSESSION_H\r\n#define ASYNCSERVER_CSESSION_H\r\n\r\n#include <boost/asio.hpp>\r\n#include <string>\r\n#include <map>\r\n#include <boost/uuid/uuid_generators.hpp>\r\n#include <boost/uuid/uuid_io.hpp>\r\n#include 'CServer.h'\r\n#include <queue>\r\n#include 'global.h'\r\nusing namespace boost::asio::ip;\r\n\r\nclass MsgNode;\r\n\r\nclass CServer;\r\n\r\n/**\r\n * \u5904\u7406\u5ba2\u6237\u7aef\u6d88\u606f\u6536\u53d1\r\n */\r\nclass CSession : public std::enable_shared_from_this<CSession> {\r\npublic:\r\n    tcp::socket &get_socket() { return _socket; };\r\n\r\n    explicit CSession(boost::asio::io_context &ioc, CServer *server);;\r\n\r\n    // \u5f00\u59cb\u5904\u7406\r\n    void start();\r\n\r\n    // \u83b7\u53d6 uuid\r\n    std::string &get_uuid() {\r\n        return _uuid;\r\n    }\r\n\r\n    /**\r\n     * \u53d1\u9001\u63a5\u53e3\r\n     * @param msg\r\n     * @param max_length\r\n     */\r\n    void send(char *msg, int max_length);\r\n\r\n    void send(std::string msg);\r\nprivate:\r\n    // \u5199\u7684\u56de\u8c03\u51fd\u6570\r\n    void handle_write(const boost::system::error_code &errorCode, std::shared_ptr<CSession> self_shared);\r\n\r\n    // \u8bfb\u7684\u56de\u8c03\u51fd\u6570\r\n    void handle_read(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                     std::shared_ptr<CSession> self_shared);\r\n\r\n    /**\r\n     * \u8bfb\u53d6\u5305\u5934\u7684\u56de\u8c03\u51fd\u6570\r\n     * @param errorCode\r\n     * @param bytes_transferred\r\n     * @param self_shared\r\n     */\r\n    void handle_read_head(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                          std::shared_ptr<CSession> self_shared);\r\n\r\n    /**\r\n     * \u8bfb\u53d6\u5305\u4f53\u7684\u56de\u8c03\u51fd\u6570\r\n     * @param errorCode\r\n     * @param bytes_transferred\r\n     * @param self_shared\r\n     */\r\n    void handle_read_msg(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                          std::shared_ptr<CSession> self_shared);\r\n    // \u6253\u5370\u6536\u5230\u7684\u4e8c\u8fdb\u5236\u6570\u636e\r\n    void printRecvData(char* data, int length);\r\n    // \u4f20\u8f93\u4fe1\u606f\u7684 socket\r\n    tcp::socket _socket;\r\n    // \u4fdd\u5b58\u6570\u636e\r\n\r\n    char _data[MAX_LENGTH];\r\n    // \u96b6\u5c5e\u4e8e\u54ea\u4e2a server\r\n    CServer *_server;\r\n    // uuid\r\n    std::string _uuid;\r\n    // \u53d1\u9001\u961f\u5217\r\n    std::queue<std::shared_ptr<MsgNode>> _send_que;\r\n    // \u4e92\u65a5\u9501\uff0c\u9632\u6b62\u591a\u4e2a\u7ebf\u7a0b\u540c\u65f6\u64cd\u4f5c\u961f\u5217\r\n    std::mutex _send_lock;\r\n\r\n    //\u6536\u5230\u7684\u6d88\u606f\u7ed3\u6784\r\n    std::shared_ptr<MsgNode> _recv_msg_node;\r\n    // \u6807\u8bb0\u5934\u90e8\u7ed3\u6784\u662f\u5426\u63a5\u6536\u5b8c\u6bd5\r\n    bool _b_head_parse;\r\n    //\u6536\u5230\u7684\u5934\u90e8\u7ed3\u6784\r\n    std::shared_ptr<MsgNode> _recv_head_node;\r\n};\r\n\r\n/**\r\n * \u6d88\u606f\u7ed3\u70b9\r\n */\r\nclass MsgNode {\r\n    friend class CSession;\r\n\r\npublic:\r\n    MsgNode(const char *msg, short max_len) : _total_len(max_len + HEAD_LENGTH), _cur_len(0) {\r\n        _data = new char[_total_len + 1];\r\n        // \u5305\u5934\u5b57\u8282\u5e8f\u8f6c\u6362\r\n        int max_len_host = boost::asio::detail::socket_ops::host_to_network_short(max_len);\r\n        // \u8bb0\u5f55\u957f\u5ea6\r\n        memcpy(_data, &max_len_host, HEAD_LENGTH);\r\n        // \u62f7\u8d1d\u6570\u636e\r\n        memcpy(_data + HEAD_LENGTH, msg, max_len);\r\n        _data[_total_len] = '\\0';\r\n    }\r\n\r\n    MsgNode(short max_len) : _total_len(max_len), _cur_len(0) {\r\n        _data = new char[_total_len + 1];\r\n    }\r\n\r\n    void clear() {\r\n        memset(_data, 0, _total_len);\r\n        _cur_len = 0;\r\n    }\r\n\r\n    ~MsgNode() {\r\n        delete[] _data;\r\n    }\r\n\r\nprivate:\r\n    int _cur_len;\r\n    int _total_len;\r\n    char *_data;\r\n};\r\n\r\n#endif //ASYNCSERVER_CSESSION_H\r\n```\r\n\r\nCSession.cpp\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <iomanip>\r\n#include <thread>\r\n#include 'CSession.h'\r\n#include 'proto/msg.pb.h'\r\n#include <json/json.h>\r\n#include <json/value.h>\r\n#include <json/reader.h>\r\n\r\nCSession::CSession(boost::asio::io_context &ioc, CServer *server) : _socket(ioc), _server(server),\r\n                                                                    _b_head_parse(false) {\r\n    std::memset(_data, '\\0', MAX_LENGTH);\r\n    // \u751f\u6210 uuid\r\n    boost::uuids::uuid a_uuid = boost::uuids::random_generator()();\r\n    _uuid = boost::uuids::to_string(a_uuid);\r\n    _recv_head_node = std::make_shared<MsgNode>(HEAD_LENGTH);\r\n}\r\n\r\nvoid CSession::start() {\r\n    std::cout << 'First read from client\\n';\r\n    // \u5148\u5728\u5ba2\u6237\u7aef\u8bfb\u53d6\r\n//    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n//                            std::bind(&CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2,\r\n//                                      shared_from_this()));\r\n    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node->_data, HEAD_LENGTH),\r\n                            std::bind(&CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,\r\n                                      shared_from_this()));\r\n}\r\n\r\nvoid CSession::handle_read(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                           std::shared_ptr<CSession> self_shared) {\r\n    try {\r\n        if (errorCode.value() != 0) {\r\n            std::cerr << 'Error occurred int read: ' << errorCode.message() << std::endl;\r\n            // \u79fb\u9664\u8fde\u63a5\r\n            _server->clear_session(_uuid);\r\n            return;\r\n        }\r\n        // \u6d4b\u8bd5\u7c98\u5305\r\n        printRecvData(_data, bytes_transferred);\r\n        std::chrono::milliseconds dura(2000);\r\n        std::this_thread::sleep_for(dura);\r\n\r\n        while (bytes_transferred > 0) {\r\n            // \u8bb0\u5f55\u5df2\u7ecf\u5904\u7406\u7684\u5b57\u8282\r\n            int copy_len = 0;\r\n            if (!_b_head_parse) {\r\n                // \u5934\u90e8\u7ed3\u6784\u8fd8\u6ca1\u5904\u7406\u5b8c\r\n                // \u6536\u5230\u7684\u6570\u636e\u6bd4\u5934\u90e8\u7ed3\u6784\u5c0f\r\n                if (bytes_transferred < HEAD_LENGTH) {\r\n                    // \u5148\u63a5\u6536\u8fd9\u90e8\u5206\u6570\u636e\r\n                    memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, bytes_transferred);\r\n                    _recv_head_node->_cur_len += bytes_transferred;\r\n                    // \u6e05\u7a7a _data \u7f13\u51b2\u533a\r\n                    memset(_data, 0, MAX_LENGTH);\r\n                    // \u7ee7\u7eed\u76d1\u542c\r\n                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                            std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                      std::placeholders::_2, self_shared));\r\n                    return;\r\n                }\r\n                // \u6536\u5230\u7684\u6570\u636e\u6bd4\u5934\u90e8\u7ed3\u6784\u5927\r\n                int head_remain = HEAD_LENGTH - _recv_head_node->_cur_len;\r\n                // \u5269\u4f59\u7684\u6570\u636e\u62f7\u8d1d\u8fdb\u53bb\r\n                memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, head_remain);\r\n                _recv_head_node->_cur_len += head_remain;\r\n                copy_len += head_remain;\r\n                bytes_transferred -= head_remain;\r\n                // \u83b7\u53d6\u5934\u90e8\u5b58\u50a8\u7684\u6570\u636e\r\n                short data_len = 0;\r\n                memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);\r\n                // \u7f51\u7edc\u5b57\u8282\u5e8f\u8f6c\u6362\u4e3a\u672c\u5730\u5b57\u8282\u5e8f\r\n                data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);\r\n\r\n                std::cout << 'Receive data length is ' << data_len << std::endl;\r\n                if (data_len > MAX_LENGTH) {\r\n                    std::cerr << 'invalid data length is ' << data_len << std::endl;\r\n                    return;\r\n                }\r\n\r\n                _recv_msg_node = std::make_shared<MsgNode>(data_len);\r\n                // \u5269\u4f59\u6d88\u606f\u7684\u957f\u5ea6\u5c0f\u4e8e\u6570\u636e\u957f\u5ea6\uff0c\u5148\u5c06\u90e8\u5206\u6570\u636e\u653e\u5230\u8282\u70b9\u91cc\r\n                if (bytes_transferred < data_len) {\r\n                    memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);\r\n                    _recv_msg_node->_cur_len += bytes_transferred;\r\n                    // \u91cd\u7f6e _data\r\n                    memset(_data, 0, MAX_LENGTH);\r\n                    // \u7ee7\u7eed\u76d1\u542c\r\n                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                            std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                      std::placeholders::_2, self_shared));\r\n                    // \u5934\u90e8\u5904\u7406\u5b8c\u6bd5\r\n                    _b_head_parse = true;\r\n                    return;\r\n                }\r\n                // \u5927\u4e8e\u76f4\u63a5\u62f7\u8d1d\u8fdb\u53bb\r\n                memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, data_len);\r\n                _recv_msg_node->_cur_len += data_len;\r\n                copy_len += data_len;\r\n                bytes_transferred -= data_len;\r\n                _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\r\n                // \u8c03\u7528 send \u6d4b\u8bd5\r\n//                MsgData msgData;\r\n//                std::string receive_data;\r\n//                msgData.ParseFromString(std::string(_recv_msg_node->_data,_recv_msg_node->_total_len));\r\n//                std::cout << 'Received msg id  is ' << msgData.id() << ' msg data is ' << msgData.data() <<std:: endl;\r\n//                std::string return_str = 'Server has received msg, msg data is ' + msgData.data();\r\n//                MsgData msgReturn;\r\n//                msgReturn.set_id(msgData.id());\r\n//                msgReturn.set_data(return_str);\r\n//                msgReturn.SerializeToString(&return_str);\r\n//                send(return_str);\r\n//                Json::Reader reader;\r\n//                Json::Value root;\r\n//                reader.parse(std::string(_recv_msg_node->_data, _recv_msg_node->_total_len), root);\r\n//                std::cout << 'Received msg id  is ' << root['id'].asInt() << ' msg data is ''\r\n//                          << root['data'].asString() << ''' << std::endl;\r\n//                root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';\r\n//                send(root.toStyledString());\r\n                send(_recv_msg_node->_data,_recv_msg_node->_total_len);\r\n                // \u7ee7\u7eed\u5904\u7406\u5269\u4e0b\u7684\u5b57\u8282\r\n                _b_head_parse = false;\r\n                _recv_head_node->clear();\r\n                // \u5982\u679c\u5c0f\u4e8e\u7b49\u4e8e0\uff0c\u5176\u5b9e\u53ea\u80fd\u7b49\u4e8e\r\n                if (bytes_transferred <= 0) {\r\n                    // \u9700\u8981\u7ee7\u7eed\u76d1\u542c\r\n                    memset(_data, 0, MAX_LENGTH);\r\n                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                            std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                      std::placeholders::_2, self_shared));\r\n                    return;\r\n                }\r\n                // \u7ee7\u7eed\u5faa\u73af\u5373\u53ef\r\n                continue;\r\n            }\r\n            // \u5934\u7ed3\u70b9\u5904\u7406\u5b8c\u4e86\uff0c\u63a5\u7740\u5904\u7406\u6570\u636e\r\n            int remain_msg = _recv_msg_node->_total_len - _recv_msg_node->_cur_len;\r\n            // \u672c\u6b21\u63a5\u6536\u7684\u8fd8\u662f\u4e0d\u8db3\r\n            if (bytes_transferred < remain_msg) {\r\n                // \u62f7\u8d1d\u90e8\u5206\uff0c\u7ee7\u7eed\u76d1\u542c\r\n                memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);\r\n                _recv_msg_node->_cur_len += bytes_transferred;\r\n                memset(_data, 0, MAX_LENGTH);\r\n                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                        std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                  std::placeholders::_2, self_shared));\r\n                return;\r\n            }\r\n            // \u8db3\u591f\u5c31\u76f4\u63a5\u62f7\u8fdb\u6765\r\n            memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, remain_msg);\r\n            _recv_msg_node->_cur_len += remain_msg;\r\n            copy_len += remain_msg;\r\n            bytes_transferred -= remain_msg;\r\n            _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\r\n            // \u8c03\u7528 send \u6d4b\u8bd5\r\n//            MsgData msgData;\r\n//            std::string receive_data;\r\n//            msgData.ParseFromString(std::string(_recv_msg_node->_data,_recv_msg_node->_total_len));\r\n//            std::cout << 'Received msg id  is ' << msgData.id() << ' msg data is ' << msgData.data() <<std:: endl;\r\n//            std::string return_str = 'Server has received msg, msg data is ' + msgData.data();\r\n//            MsgData msgReturn;\r\n//            msgReturn.set_id(msgData.id());\r\n//            msgReturn.set_data(return_str);\r\n//            msgReturn.SerializeToString(&return_str);\r\n//            send(return_str);\r\n\r\n//            Json::Reader reader;\r\n//            Json::Value root;\r\n//            reader.parse(std::string(_recv_msg_node->_data, _recv_msg_node->_total_len), root);\r\n//            std::cout << 'Received msg id  is ' << root['id'].asInt() << ' msg data is ''\r\n//                      << root['data'].asString() << ''' << std::endl;\r\n//            root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';\r\n//            send(root.toStyledString());\r\n            send(_recv_msg_node->_data,_recv_msg_node->_total_len);\r\n\r\n            // \u7ee7\u7eed\u5904\u7406\r\n            _b_head_parse = false;\r\n            _recv_head_node->clear();\r\n\r\n            // \u4e0d\u5269\u4e0b\u6570\u636e\u4e86\r\n            if (bytes_transferred <= 0) {\r\n                memset(_data, 0, MAX_LENGTH);\r\n                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),\r\n                                        std::bind(&CSession::handle_read, this, std::placeholders::_1,\r\n                                                  std::placeholders::_2, self_shared));\r\n                return;\r\n            }\r\n            // \u7ee7\u7eed\u5faa\u73af\u5373\u53ef\r\n            continue;\r\n        }\r\n    } catch (std::exception &e) {\r\n        std::cerr << 'Error occurred: ' << e.what() << std::endl;\r\n    }\r\n}\r\n\r\nvoid CSession::handle_write(const boost::system::error_code &errorCode, std::shared_ptr<CSession> self_shared) {\r\n    try {\r\n        if (errorCode.value() != 0) {\r\n            std::cerr << 'Error occurred int write: ' << errorCode.message() << std::endl;\r\n            // \u79fb\u9664\u8fde\u63a5\r\n            _server->clear_session(_uuid);\r\n            return;\r\n        }\r\n        std::cout << 'Writing to client successfully, start read from client\\n';\r\n\r\n        // \u8c03\u7528\u56de\u8c03\u51fd\u6570\u8868\u793a\u5df2\u7ecf\u5199\u5b8c\r\n        // \u4e0a\u9501\r\n        std::lock_guard<std::mutex> lock(_send_lock);\r\n        // \u5f39\u51fa\u961f\u5217\u5143\u7d20\r\n        _send_que.pop();\r\n        // \u961f\u5217\u662f\u5426\u8fd8\u6709\u5269\u4e0b\u7684\u6d88\u606f\r\n        if (!_send_que.empty()) {\r\n            // \u63a5\u7740\u53d1\uff0c\u76f4\u5230\u961f\u5217\u4e3a\u7a7a\r\n            auto &msgNode = _send_que.front();\r\n            boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\r\n                                     std::bind(&CSession::handle_write, this, std::placeholders::_1, self_shared));\r\n        }\r\n    } catch (std::exception &e) {\r\n        std::cerr << 'Error occurred: ' << e.what() << std::endl;\r\n    }\r\n}\r\n\r\nvoid CSession::send(char *msg, int max_length) {\r\n    // \u53d1\u9001\u961f\u5217\u91cc\u662f\u5426\u8fd8\u6709\u6ca1\u6cd5\u5b8c\u7684\u6570\u636e\r\n    bool pending = false;\r\n    // \u4e0a\u9501\r\n    std::lock_guard<std::mutex> lock(_send_lock);\r\n    int send_que_size = _send_que.size();\r\n    if (send_que_size > MAX_SENDQUE) {\r\n        std::cout << 'session: ' << _uuid << ' send que fulled, size is ' << MAX_SENDQUE << std::endl;\r\n        return;\r\n    }\r\n\r\n    // \u52a0\u5165\u53d1\u9001\u961f\u5217\r\n    _send_que.push(std::make_shared<MsgNode>(msg, max_length));\r\n\r\n    if (send_que_size > 0) {\r\n        // \u4e4b\u524d\u7684\u8fd8\u6ca1\u53d1\u9001\u5b8c\r\n        return;\r\n    }\r\n    auto &msgNode = _send_que.front();\r\n    // \u4e4b\u524d\u7684\u5168\u53d1\u5b8c\u4e86\uff0c\u76f4\u63a5\u53d1\u672c\u6b21\u7684\r\n    boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\r\n                             std::bind(&CSession::handle_write, this, std::placeholders::_1, shared_from_this()));\r\n}\r\n\r\n// \u6253\u5370\u4e8c\u8fdb\u5236\u6570\u636e\r\nvoid CSession::printRecvData(char *data, int length) {\r\n    std::stringstream ss;\r\n    std::string result = '0x';\r\n    for (int i = 0; i < length; i++) {\r\n        std::string hexstr;\r\n        ss << std::hex << std::setw(2) << std::setfill('0') << int(data[i]) << std::endl;\r\n        ss >> hexstr;\r\n        result += hexstr;\r\n    }\r\n    std::cout << 'receive raw data is : ' << result << std::endl;;\r\n}\r\n\r\nvoid CSession::send(std::string msg) {\r\n    std::lock_guard<std::mutex> lock(_send_lock);\r\n\r\n    int send_que_size = _send_que.size();\r\n    if (send_que_size > MAX_SENDQUE) {\r\n        std::cout << 'session: ' << _uuid << ' send que fulled, size is ' << MAX_SENDQUE << std::endl;\r\n        return;\r\n    }\r\n    _send_que.push(std::make_shared<MsgNode>(msg.c_str(), msg.size()));\r\n    if (send_que_size > 0) {\r\n        return;\r\n    }\r\n    auto &msgNode = _send_que.front();\r\n    boost::asio::async_write(_socket, boost::asio::buffer(msgNode->_data, msgNode->_total_len),\r\n                             std::bind(&CSession::handle_write, this, std::placeholders::_1, shared_from_this()));\r\n}\r\n\r\nvoid CSession::handle_read_head(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                                std::shared_ptr<CSession> self_shared) {\r\n    if (errorCode.value() != 0) {\r\n        std::cerr << 'Error occurred in read head: ' << errorCode.message() << std::endl;\r\n        // \u79fb\u9664\u8fde\u63a5\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n    if (bytes_transferred < HEAD_LENGTH) {\r\n        std::cerr << 'Error occurred in read head: ' << errorCode.message() << std::endl;\r\n        // \u79fb\u9664\u8fde\u63a5\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n    // \u89e3\u6790\u5305\u5934\u6570\u636e\r\n    short data_len = 0;\r\n    memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);\r\n    // \u5b57\u8282\u5e8f\u5904\u7406\r\n    data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);\r\n    if (data_len > MAX_LENGTH) {\r\n        std::cerr << 'Invalid data length :' << data_len << std::endl;\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n\r\n\r\n    _recv_msg_node = std::make_shared<MsgNode>(data_len);\r\n\r\n    boost::asio::async_read(_socket, boost::asio::buffer(_recv_msg_node->_data, _recv_msg_node->_total_len),\r\n                            std::bind(&CSession::handle_read_msg, this, std::placeholders::_1, std::placeholders::_2,\r\n                                      shared_from_this()));\r\n}\r\n\r\nvoid CSession::handle_read_msg(const boost::system::error_code &errorCode, size_t bytes_transferred,\r\n                               std::shared_ptr<CSession> self_shared) {\r\n    if (errorCode.value() != 0) {\r\n        std::cerr << 'Error occurred in read msg: ' << errorCode.message() << std::endl;\r\n        // \u79fb\u9664\u8fde\u63a5\r\n        _server->clear_session(_uuid);\r\n        return;\r\n    }\r\n    // \u6d4b\u8bd5\u7c98\u5305\r\n    printRecvData(_recv_msg_node->_data, bytes_transferred);\r\n    std::chrono::milliseconds dura(2000);\r\n    std::this_thread::sleep_for(dura);\r\n    _recv_msg_node->_data[_recv_msg_node->_total_len] = '\\0';\r\n    std::cout << 'receive data is ' << _recv_msg_node->_data << std::endl;\r\n    send(_recv_msg_node->_data, _recv_msg_node->_total_len);\r\n    // \u518d\u6b21\u63a5\u6536\u5934\u90e8\u6570\u636e\r\n    _recv_head_node->clear();\r\n    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node->_data, HEAD_LENGTH),\r\n                            std::bind(&CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,\r\n                                      shared_from_this()));\r\n}\r\n```\u3002", "top": 0, "createdAt": 1727070414, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P3": {"htmlDir": "docs/post/duo-xian-cheng-Asio.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "\u591a\u7ebf\u7a0bAsio", "postUrl": "post/duo-xian-cheng-Asio.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/3", "commentNum": 0, "wordCount": 7499, "description": "# \u591a\u7ebf\u7a0b\u6a21\u578b\r\nasio \u7684\u591a\u7ebf\u7a0b\u6a21\u578b\u6709\u4e24\u79cd\uff0cIOServicePool \u548c IOThreadPool\r\n# IOServicePool\r\nIOServicePool\u6a21\u578b\uff1a\r\n![image-20240801133223177](https://github.com/user-attachments/assets/c036abee-852d-42a7-ab2d-b2acb054f14f)\r\n\u7279\u70b9:\r\n1. \u6bcf\u4e2a io_context \u90fd\u8fd0\u884c\u5728\u4e0d\u540c\u7684\u7ebf\u7a0b\u5185\uff0c\u5bf9\u4e8e\u4e00\u4e2a socket\uff0c\u4f1a\u6ce8\u518c\u5728\u540c\u4e00\u4e2a io_context \u5185\uff0c\u5e76\u4e14\u56de\u8c03\u51fd\u6570\u7684\u89e6\u53d1\u4e5f\u662f\u5728\u540c\u4e00\u4e2a\u7ebf\u7a0b\u5185\uff0c\u4e0d\u5b58\u5728\u5e76\u53d1\u5b89\u5168\u95ee\u9898\r\n2. \u4e0d\u540c\u7684 socket\uff0c\u56de\u8c03\u51fd\u6570\u53ef\u80fd\u7531\u4e0d\u540c\u7684\u7ebf\u7a0b\u8c03\u7528\uff0c\u5982\u679c\u56de\u8c03\u51fd\u6570\u4e2d\u8fdb\u884c\u4e86\u5171\u4eab\u6570\u636e\u7684\u4fee\u6539\uff0c\u5c31\u4f1a\u5b58\u5728\u7ebf\u7a0b\u5b89\u5168\u95ee\u9898\uff0c\u8fd9\u65f6\u53ef\u4ee5\u5728\u56de\u8c03\u51fd\u6570\u4e2d\u52a0\u9501\u6216\u8005\u4f7f\u7528\u903b\u8f91\u961f\u5217\u7684\u65b9\u5f0f\r\n3. \u591a\u7ebf\u7a0b\u6a21\u5f0f\u6781\u5927\u7684\u63d0\u9ad8\u4e86\u5e76\u53d1\u80fd\u529b\uff1b\u5355\u7ebf\u7a0b\u6a21\u5f0f\u4e0b\u5982\u679c\u56de\u8c03\u51fd\u6570\u8c03\u7528\u65f6\u95f4\u8fc7\u957f\uff0c\u4f1a\u5f71\u54cd\u540e\u7eed\u51fd\u6570\u7684\u8c03\u7528\uff1b\u901a\u8fc7\u903b\u8f91\u961f\u5217\u7684\u65b9\u5f0f\u5c06\u7f51\u7edc\u7ebf\u7a0b\u548c\u903b\u8f91\u7ebf\u7a0b\u89e3\u8026\u5408\u4e86\uff0c\u4e0d\u4f1a\u51fa\u73b0\u524d\u4e00\u4e2a\u8c03\u7528\u65f6\u95f4\u5f71\u54cd\u4e0b\u4e00\u4e2a\u56de\u8c03\u89e6\u53d1\u7684\u95ee\u9898\r\n## \u5b9e\u73b0\r\n\r\n\u672c\u8d28\u5c31\u662f\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u57fa\u672c\u529f\u80fd\u5c31\u662f\u6839\u636e\u6784\u9020\u51fd\u6570\u4f20\u5165\u7684\u6570\u91cf\u521b\u5efan\u4e2a\u7ebf\u7a0b\u548c io_context\uff0c\u7136\u540e\u6bcf\u4e2a\u7ebf\u7a0b\u8dd1\u4e00\u4e2a io_context\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5e76\u53d1\u5904\u7406\u4e0d\u540c io_context \u8bfb\u5199\u4e8b\u4ef6\u4e86\u3002", "top": 0, "createdAt": 1727070687, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P5": {"htmlDir": "docs/post/Asio-shi-xian-Http-fu-wu-qi.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Asio\u5b9e\u73b0Http\u670d\u52a1\u5668", "postUrl": "post/Asio-shi-xian-Http-fu-wu-qi.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/5", "commentNum": 0, "wordCount": 8475, "description": "# Http\u7b80\u4ecb\r\n\r\n## Http\u5305\u5934\u4fe1\u606f\r\n\r\n\u4e00\u4e2a\u6807\u51c6\u7684HTTP\u62a5\u6587\u5934\u901a\u5e38\u7531\u8bf7\u6c42\u5934\u548c\u54cd\u5e94\u5934\u4e24\u90e8\u5206\u7ec4\u6210\u3002", "top": 0, "createdAt": 1727071229, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P6": {"htmlDir": "docs/post/Beast-shi-xian-websocket-fu-wu-qi.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Beast\u5b9e\u73b0websocket\u670d\u52a1\u5668", "postUrl": "post/Beast-shi-xian-websocket-fu-wu-qi.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/6", "commentNum": 0, "wordCount": 24558, "description": "# \u6d41\u5bf9\u8c61\r\n\r\nWebSocket\u8fde\u63a5\u9700\u8981\u4e00\u4e2a\u6709\u72b6\u6001\u5bf9\u8c61\uff0c\u7531Beast\u4e2d\u7684\u4e00\u4e2a\u7c7b\u6a21\u677fwebsocket::stream\u8868\u793a\u3002", "top": 0, "createdAt": 1727071296, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P7": {"htmlDir": "docs/post/Grpc.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Grpc", "postUrl": "post/Grpc.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/7", "commentNum": 0, "wordCount": 4045, "description": "# \u4e0b\u8f7d\r\n\r\nvcpkg install grpc\r\n\r\n# \u914d\u7f6e\r\n\r\ncmake \u4e2d\uff1a\r\n\r\n```cmake\r\nfind_package(Protobuf CONFIG REQUIRED)\r\nfind_package(gRPC CONFIG REQUIRED)\r\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\r\narget_link_libraries(${projectName} PRIVATE gRPC::grpc++ protobuf::libprotobuf)\r\n```\r\n\r\n# \u7f16\u8bd1\r\n\r\n\u7f16\u5199\u597d proto\u6587\u4ef6\uff0c\u5728 powershell \u4e2d\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4\uff0c\u63d2\u4ef6\u9009\u62e9\u81ea\u5df1\u7684\u8def\u5f84\uff1a\r\n\r\n```cmd\r\nprotoc --proto_path=. --cpp_out=. demo.proto\r\nprotoc --proto_path=. --grpc_out=. --plugin=protoc-gen-grpc='D:\\develop_tools\\cppsoft\\vcpkg\\packages\\grpc_x64-windows\\tools\\grpc\\grpc_cpp_plugin.exe' demo.proto\r\n```\r\n\r\n\u751f\u6210\u6587\u4ef6\u6dfb\u52a0\u5230 cmakelists.txt \u4e2d\r\n\r\n# \u901a\u4fe1\u6d41\u7a0b\r\n\r\n1. \u8fde\u63a5\u5230\u670d\u52a1\u7aef\u7684\u5730\u5740\r\n2. \u521b\u5efa\u5ba2\u6237\u7aef\u5b9e\u4f8b\uff0c\u8c03\u7528\u51fd\u6570\uff0c\u5c06\u8bf7\u6c42\u6d88\u606f\u53d1\u9001\u7ed9\u670d\u52a1\u7aef\r\n3. \u670d\u52a1\u7aef\u63a5\u6536\u5230\u8bf7\u6c42\uff0c\u5904\u7406\u8bf7\u6c42\u6d88\u606f\u5e76\u751f\u6210\u54cd\u5e94\u6d88\u606f\u3002", "top": 0, "createdAt": 1727071411, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P8": {"htmlDir": "docs/post/Asio-xie-cheng.html", "labels": ["\u7f51\u7edc\u7f16\u7a0b"], "postTitle": "Asio\u534f\u7a0b", "postUrl": "post/Asio-xie-cheng.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/8", "commentNum": 0, "wordCount": 2481, "description": "# \u534f\u7a0b\r\n\u534f\u7a0b\uff0c\u82f1\u6587Coroutines\uff0c\u662f\u4e00\u79cd\u57fa\u4e8e\u7ebf\u7a0b\u4e4b\u4e0a\uff0c\u4f46\u53c8\u6bd4\u7ebf\u7a0b\u66f4\u52a0\u8f7b\u91cf\u7ea7\u7684\u5b58\u5728\uff0c\u8fd9\u79cd\u7531\u7a0b\u5e8f\u5458\u81ea\u5df1\u5199\u7a0b\u5e8f\u6765\u7ba1\u7406\u7684\u8f7b\u91cf\u7ea7\u7ebf\u7a0b\u53eb\u505a\u300e\u7528\u6237\u7a7a\u95f4\u7ebf\u7a0b\u300f\uff0c\u5177\u6709\u5bf9\u5185\u6838\u6765\u8bf4\u4e0d\u53ef\u89c1\u7684\u7279\u6027\u3002", "top": 0, "createdAt": 1727071496, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P9": {"htmlDir": "docs/post/DS_1\uff1a-xian-xing-biao.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_1\uff1a\u7ebf\u6027\u8868", "postUrl": "post/DS_1%EF%BC%9A-xian-xing-biao.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/9", "commentNum": 0, "wordCount": 32558, "description": "# \u7ebf\u6027\u8868\r\n\u7ebf\u6027\u8868\u662f\u5177\u6709\u76f8\u540c\u6570\u636e\u7c7b\u578b\u7684n\uff08n\u22650\uff09\u4e2a\u6570\u636e\u5143\u7d20\u7684**\u6709\u9650\u5e8f\u5217**\uff0c\u5176\u4e2dn\u4e3a\u8868\u957f\uff0c\u5f53n = 0\u65f6\u7ebf\u6027\u8868\u662f\u4e00\u4e2a\u7a7a\u8868\u3002", "top": 0, "createdAt": 1727079656, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-23", "dateLabelColor": "#bc4c00"}, "P10": {"htmlDir": "docs/post/DS_2\uff1a-zhan.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_2\uff1a\u6808", "postUrl": "post/DS_2%EF%BC%9A-zhan.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/10", "commentNum": 0, "wordCount": 3475, "description": "# \u6808\r\n\u5b9a\u4e49\uff1a\u53ea\u5141\u8bb8\u5728\u4e00\u7aef\u8fdb\u884c\u64cd\u4f5c\uff08\u63d2\u5165\u3001\u5220\u9664\uff09\u7684\u7ebf\u6027\u8868\r\n\u57fa\u672c\u64cd\u4f5c\uff1a\r\n1. \u521d\u59cb\u5316\u6808\r\n2. \u91ca\u653e\u5185\u5b58\r\n3. \u8fdb\u6808\r\n4. \u51fa\u6808\r\n5. \u83b7\u53d6\u6808\u9876\u5143\u7d20\r\n6. \u5224\u7a7a\r\n## \u987a\u5e8f\u6808\r\n\u5b9e\u73b0:\u9759\u6001\u6570\u7ec4\u4e2d\u5b58\u653e\u6808\u5143\u7d20\r\n```C\r\n#define Type int\r\n#define MAX_SIZE 10\r\ntypedef struct Stack {\r\n    // \u5b58\u653e\u6808\u5143\u7d20\r\n    Type data[MAX_SIZE];\r\n    // \u6808\u9876\u6307\u9488\r\n    int top;\r\n} Stack;\r\n\r\nvoid initStack(Stack *s) {\r\n    // \u6808\u4e3a\u7a7a\r\n    s->top = -1;\r\n}\r\n\r\nvoid destructorStack(Stack *s) {\r\n    s->top = -1;\r\n}\r\n\r\nbool isEmpty(Stack *s) {\r\n    return s->top == -1;\r\n}\r\n\r\nbool push(Stack *s, Type e) {\r\n    if (s->top == MAX_SIZE - 1) {\r\n        printf('Stack is full');\r\n        return false;\r\n    }\r\n    s->data[++s->top] = e;\r\n    return true;\r\n}\r\n\r\nbool pop(Stack *s) {\r\n    if (isEmpty(s)) {\r\n        printf('Stack is empty');\r\n        return false;\r\n    }\r\n    s->top--;\r\n    return true;\r\n}\r\n\r\nType front(Stack*s){\r\n    if (isEmpty(s)) {\r\n        printf('Stack is empty');\r\n        return false;\r\n    }\r\n    return s->data[s->top];\r\n}\r\n```\r\n\u4e5f\u53ef\u4ee5\u5c06top\u521d\u59cb\u5316\u4e3a0\uff0c\u8fd9\u6837top\u6307\u5411\u7684\u5c31\u662f\u4e0b\u4e00\u4e2a\u5165\u6808\u7684\u4f4d\u7f6e\r\n## \u5171\u4eab\u6808\r\n\u5c31\u662f\u5728\u987a\u5e8f\u6808\u7684\u57fa\u7840\u4e0a\uff0c\u518d\u6dfb\u52a0\u4e00\u4e2atop\u6807\u8bb0\uff0c\u5c06\u4e00\u6574\u7247\u6570\u7ec4\u7a7a\u95f4\u5206\u4e3a\u4e24\u4e2a\u6808\u4f7f\u7528\uff0ctop0\u662f\u4ece\u6570\u7ec4\u7684\u7d22\u5f150\u5411\u4e0a\uff0ctop1\u4ece\u6570\u7ec4\u7684\u6700\u5927\u7d22\u5f15\u5411\u4e0b\uff1b\u76f8\u4ea4\u7684\u65f6\u5019\u5c31\u662f\u6ee1\u4e86\r\n\r\n## \u94fe\u5f0f\u6808\r\n\u6bcf\u4e2a\u5143\u7d20\u5c31\u662f\u4e00\u4e2a\u94fe\u8868\u7ed3\u70b9\uff0c\u5b9e\u73b0\u6808\u7684\u529f\u80fd\u5c31\u884c\uff0c\u4e5f\u662f\u5206\u4e3a\u5e26\u5934\u7ed3\u70b9\u548c\u4e0d\u5e26\u5934\u7ed3\u70b9\r\n\u4e0d\u5e26\u5934\u7ed3\u70b9:\r\n```C\r\n#define Type int\r\ntypedef struct Node {\r\n    Type data;\r\n    struct Node *next;\r\n} Node;\r\ntypedef Node *stack;\r\n\r\nvoid initStack(stack *s) {\r\n    (*s) = NULL;\r\n}\r\n\r\nvoid destructor(stack *s) {\r\n    Node *p = *s;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*s) = NULL;\r\n}\r\n\r\nbool push(stack *s, Type e) {\r\n    Node *p = *s;\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Failed to allocate memory');\r\n        return false;\r\n    }\r\n    newNode->data = e;\r\n    newNode->next = p;\r\n    *s = newNode;\r\n    return true;\r\n}\r\n\r\nbool pop(stack *s) {\r\n    if (*s == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return false;\r\n    }\r\n    Node *p = *s;\r\n    (*s) = (*s)->next;\r\n    free(p);\r\n    return true;\r\n}\r\n\r\nType front(stack *s) {\r\n    if (*s == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return -1;\r\n    }\r\n    return (*s)->data;\r\n}\r\n```\r\n\u5e26\u5934\u7ed3\u70b9\uff1a\r\n```C\r\n#define Type int\r\ntypedef struct Node {\r\n    Type data;\r\n    struct Node *next;\r\n} Node;\r\ntypedef Node *stack;\r\n\r\nvoid constructor(stack *s) {\r\n    // \u5206\u914d\u5934\u7ed3\u70b9\r\n    (*s) = (Node *) malloc(sizeof(Node));\r\n    if (*s == NULL) {\r\n        printf('Failed to allocate memory');\r\n        return;\r\n    }\r\n    (*s)->data = -1;\r\n    (*s)->next = NULL;\r\n}\r\n\r\nvoid destructor(stack *s) {\r\n    if (*s == NULL) {\r\n        return;\r\n    }\r\n    Node *p = *s;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*s) = NULL;\r\n}\r\n\r\nbool push(stack *s, Type e) {\r\n    if (*s == NULL) {\r\n        printf('stack is not initialized');\r\n        return false;\r\n    }\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Failed to allocate memory');\r\n        return false;\r\n    }\r\n    newNode->data = e;\r\n    newNode->next = (*s)->next;\r\n    (*s)->next = newNode;\r\n    return true;\r\n}\r\n\r\nbool pop(stack *s) {\r\n    if ((*s) == NULL || (*s)->next == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return false;\r\n    }\r\n    Node *p = (*s)->next;\r\n    (*s)->next = p->next;\r\n    free(p);\r\n    return true;\r\n}\r\n\r\nType front(stack *s) {\r\n    if ((*s) == NULL || (*s)->next == NULL) {\r\n        printf('Stack is empty\\n');\r\n        return -1;\r\n    }\r\n    return (*s)->next->data;\r\n}\r\n```\r\n\u4ee3\u7801\u5730\u5740\uff1ahttps://github.com/proacane/DataStructure\u3002", "top": 0, "createdAt": 1727332265, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-26", "dateLabelColor": "#bc4c00"}, "P11": {"htmlDir": "docs/post/cao-zuo-xi-tong-gai-shu.html", "labels": ["\u64cd\u4f5c\u7cfb\u7edf"], "postTitle": "\u64cd\u4f5c\u7cfb\u7edf\u6982\u8ff0", "postUrl": "post/cao-zuo-xi-tong-gai-shu.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/11", "commentNum": 0, "wordCount": 1721, "description": "# \u64cd\u4f5c\u7cfb\u7edf\u7684\u6982\u5ff5\r\n\u64cd\u4f5c\u7cfb\u7edf\uff08Operating System\uff0c OS\uff09\u662f\u6307\u63a7\u5236\u548c**\u7ba1\u7406**\u6574\u4e2a\u8ba1\u7b97\u673a\u7cfb\u7edf\u7684**\u786c\u4ef6\u548c\u8f6f\u4ef6**\u8d44\u6e90\uff0c\u5e76\u5408\u7406\u5730\u7ec4\u7ec7\u8c03\u5ea6\u8ba1\u7b97\u673a\u7684\u5de5\u4f5c\u548c\u8d44\u6e90\u7684\u5206\u914d\uff1b\u4ee5**\u63d0\u4f9b\u7ed9\u7528\u6237\u548c\u5176\u4ed6\u8f6f\u4ef6\u65b9\u4fbf\u7684\u63a5\u53e3\u548c\u73af\u5883**\uff1b\u5b83\u662f\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d**\u6700\u57fa\u672c\u7684\u7cfb\u7edf\u8f6f\u4ef6**\r\n# \u7279\u5f81\r\n\u64cd\u4f5c\u7cfb\u7edf\u76844\u4e2a\u7279\u5f81\uff1a\r\n1. \u5e76\u53d1\r\n2. \u5171\u4eab\r\n3. \u865a\u62df\r\n4. \u5f02\u6b65\r\n\u5176\u4e2d\uff0c\u5e76\u53d1\u3001\u5171\u4eab\u662f\u64cd\u4f5c\u7cfb\u7edf\u6700\u57fa\u672c\u7684\u7279\u5f81\uff0c\u5e76\u4e14\u4e8c\u8005\u76f8\u4e92\u4f9d\u5b58\r\n## \u5e76\u53d1\r\n\u5e76\u53d1\u662f\u6307\u4e24\u4e2a\u6216\u591a\u4e2a\u4e8b\u4ef6\u5728\u540c\u4e00\u65f6\u95f4\u95f4\u9694\u5185\u53d1\u751f\uff0c\u5728\u5b8f\u89c2\u770b\u6765\u662f\u540c\u65f6\u53d1\u751f\u7684\uff0c\u4f46\u662f\u5fae\u89c2\u4e0a\u662f\u4ea4\u66ff\u8fd0\u884c\u7684\uff1b\r\n\u64cd\u4f5c\u7cfb\u7edf\u7684\u5e76\u53d1\u6307\u7684\u662f\u53ef\u4ee5\u540c\u65f6\u5b58\u5728\u591a\u4e2a\u8fd0\u884c\u7684\u7a0b\u5e8f\r\n\u5e76\u884c\uff1a\u6307\u591a\u4e2a\u4e8b\u4ef6\u5728\u540c\u4e00\u65f6\u523b\u540c\u65f6\u53d1\u751f\r\n\u5355\u6838 cpu \u540c\u4e00\u65f6\u523b\u53ea\u80fd\u8fd0\u884c\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u53ea\u80fd\u5e76\u53d1\r\n\u591a\u6838 cpu \u540c\u4e00\u65f6\u523b\u53ef\u4ee5\u8fd0\u884c\u591a\u4e2a\u8fdb\u7a0b\uff0c\u65e2\u5b58\u5728\u5e76\u53d1\u3001\u4e5f\u5b58\u5728\u5e76\u884c\r\n## \u5171\u4eab\r\n\u5171\u4eab\uff1a\u6307\u7cfb\u7edf\u4e2d\u7684\u8d44\u6e90\u53ef\u4ee5\u88ab\u591a\u4e2a\u5e76\u53d1\u6267\u884c\u7684\u8fdb\u7a0b\u4f7f\u7528\r\n\u4e92\u65a5\u5171\u4eab\uff1a\u7cfb\u7edf\u4e2d\u7684\u67d0\u4e9b\u8d44\u6e90\uff0c\u867d\u7136\u53ef\u4ee5\u63d0\u4f9b\u7ed9\u591a\u4e2a\u8fdb\u7a0b\u4f7f\u7528\uff0c\u4f46\u4e00\u4e2a\u65f6\u95f4\u6bb5\u5185\u53ea\u5141\u8bb8\u4e00\u4e2a\u8fdb\u7a0b\u8bbf\u95ee\u8be5\u8d44\u6e90\uff0c\u4f8b\u5982\u6444\u50cf\u5934\u7b49\u8d44\u6e90\r\n\u540c\u65f6\u5171\u4eab\uff1a\u7cfb\u7edf\u4e2d\u7684\u67d0\u4e9b\u8d44\u6e90\uff0c\u5141\u8bb8\u4e00\u4e2a\u65f6\u95f4\u6bb5\u5185\u7531\u591a\u4e2a\u8fdb\u7a0b\u201c\u540c\u65f6\u201d\u5bf9\u5b83\u4eec\u8fdb\u884c\u8bbf\u95ee\uff0c\u4f8b\u5982\u78c1\u76d8\u7684\u8bfb\u5199\r\n\u4ece\u5171\u4eab\u7684\u5b9a\u4e49\u5c31\u53ef\u4ee5\u770b\u51fa\u6765\uff0c\u82e5\u64cd\u4f5c\u7cfb\u7edf\u6ca1\u6709\u5e76\u53d1\u6027\uff0c\u5171\u4eab\u5c31\u6ca1\u6709\u610f\u4e49\uff1b\u6ca1\u6709\u5171\u4eab\u6027\uff0c\u5e76\u53d1\u4e5f\u6ca1\u6709\u610f\u4e49\r\n## \u865a\u62df\r\n\u865a\u62df\u662f\u6307\u628a\u4e00\u4e2a\u7269\u7406\u4e0a\u7684\u5b9e\u4f53\u53d8\u4e3a\u82e5\u5e72\u4e2a\u903b\u8f91\u4e0a\u7684\u5bf9\u5e94\u7269\u3002", "top": 0, "createdAt": 1727335375, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-26", "dateLabelColor": "#bc4c00"}, "P12": {"htmlDir": "docs/post/DS_2\uff1a-dui-lie.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_2\uff1a\u961f\u5217", "postUrl": "post/DS_2%EF%BC%9A-dui-lie.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/12", "commentNum": 0, "wordCount": 4324, "description": "# \u961f\u5217\r\n\u53ea\u5141\u8bb8\u4e00\u7aef\u8fdb\u5165\uff0c\u53e6\u4e00\u7aef\u5220\u9664\u7684\u7ebf\u6027\u8868\r\n\u57fa\u672c\u64cd\u4f5c\uff1a\r\n1. \u521d\u59cb\u5316\r\n2. \u91ca\u653e\u5185\u5b58\r\n3. \u5165\u961f\r\n4. \u51fa\u961f\r\n5. \u83b7\u53d6\u961f\u5934\u5143\u7d20\r\n6. \u5224\u7a7a\r\n## \u987a\u5e8f\u5b58\u50a8\u5b9e\u73b0\u961f\u5217\r\n\u5185\u90e8\u4f7f\u7528\u8fde\u7eed\u5185\u5b58\u7684\u6570\u7ec4\uff0c\u91c7\u7528\u5faa\u73af\u961f\u5217\u7684\u683c\u5f0f\r\n```C\r\n#define MAX_SIZE 10\r\n#define Type int\r\ntypedef struct {\r\n    Type data[MAX_SIZE];\r\n    // \u961f\u5934\u6307\u9488\r\n    int front;\r\n    // \u961f\u5c3e\u6307\u9488\r\n    int rear;\r\n    // \u6dfb\u52a0 size\uff0c\u6765\u7ef4\u62a4\u961f\u5217\u7684\u957f\u5ea6\uff0c\u7528\u4e8e\u5224\u65ad\u961f\u5217\u662f\u5426\u5df2\u6ee1\r\n    int size;\r\n} Queue;\r\n\r\nvoid constructor(Queue *q) {\r\n    q->front = 0;\r\n    q->rear = 0;\r\n}\r\n\r\nbool isEmpty(Queue *q) {\r\n    return q->front == q->rear;\r\n}\r\n\r\nbool isFull(Queue *q) {\r\n    return (q->rear + 1) % MAX_SIZE == q->front;\r\n}\r\n\r\nvoid push(Queue *q, Type e) {\r\n    // \u5982\u679c\u961f\u5217\u5df2\u6ee1\u5219\u4e0d\u80fd\u6dfb\u52a0\r\n    if (isFull(q)) {\r\n        printf('Queue is full');\r\n        return;\r\n    }\r\n    q->data[q->rear] = e;\r\n    q->rear = (q->rear + 1) % MAX_SIZE;\r\n}\r\n\r\nType pop(Queue*q){\r\n    if(isEmpty(q)){\r\n        return -1;\r\n    }\r\n    Type t = q->data[q->front];\r\n    q->front = (q->front+1)%MAX_SIZE;\r\n    return t;\r\n}\r\n```\r\n\r\n> \u5728\u5224\u65ad\u961f\u5217\u662f\u5426\u5df2\u6ee1\uff0c\u6216\u662f\u5426\u7a7a\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u91c7\u7528\u4e0d\u540c\u7684\u65b9\u5f0f\uff0c\u4e00\u79cd\u5c31\u662f\u4e0a\u9762\u4ee3\u7801\u6240\u7528\u7684\u65b9\u5f0f\uff0c\u4e5f\u53ef\u4ee5\u6dfb\u52a0 size \u6210\u5458\uff0c\u8bb0\u5f55\u5f53\u524d\u961f\u5217\u7684\u6709\u6548\u5143\u7d20\u6570\u91cf\uff0c\u901a\u8fc7 size == MAX_SIZE \u548c size == 0 \u6765\u5224\u65ad\u961f\u5217\u72b6\u6001\uff1b\r\n> \u53e6\u4e00\u79cd\u6709\u6548\u7684\u65b9\u5f0f\u662f\u6dfb\u52a0 tag \u6807\u8bb0\uff0c0\u548c1\u5206\u522b\u8868\u793a\u4e0a\u6b21\u6210\u529f\u7684\u64cd\u4f5c\u4e3a\u51fa\u961f\u548c\u5165\u961f\uff0c\u5f53 front == rear && tag == 0\uff0c\u5c31\u4ee3\u8868\u961f\u5217\u7a7a\u4e86\uff0c front == rear && tag == 1\u5c31\u4ee3\u8868\u961f\u5217\u5df2\u6ee1\r\n## \u94fe\u5f0f\u961f\u5217\r\n\u94fe\u5f0f\u5b58\u50a8\u4f9d\u7136\u5206\u4e3a\u6709\u5934\u7ed3\u70b9\u548c\u65e0\u5934\u7ed3\u70b9\u4e24\u79cd\u65b9\u5f0f\uff0c\u94fe\u5f0f\u5b58\u50a8\u6ca1\u6709\u5224\u7a7a\u3001\u5224\u6ee1\u7684\u5fc5\u8981\r\n\u65e0\u5934\u7ed3\u70b9\uff1a\r\n```C\r\n#include <stdio.h>\r\n#include <malloc.h>\r\n#include <stdbool.h>\r\n\r\n#define Type int\r\n\r\ntypedef struct Node {\r\n    struct Node *next;\r\n    Type data;\r\n} Node;\r\ntypedef struct {\r\n    Node *front;\r\n    Node *rear;\r\n} Queue;\r\n\r\nvoid constructor(Queue *q) {\r\n    (*q).front = NULL;\r\n    (*q).rear = NULL;\r\n}\r\n\r\nbool isEmpty(Queue *q) {\r\n    return q->front == NULL;\r\n}\r\n\r\nvoid destructor(Queue *q) {\r\n    Node *p = (*q).front;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*q).front = NULL;\r\n    (*q).rear = NULL;  // \u786e\u4fdd\u961f\u5217\u7684 rear \u4e5f\u8bbe\u7f6e\u4e3a NULL\r\n}\r\n\r\nvoid push(Queue *q, Type e) {\r\n    if (q == NULL) {\r\n        printf('Queue is not initialized\\n');\r\n        return;\r\n    }\r\n    // \u63d2\u5165\u5230\u961f\u5c3e\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Can't allocate memory');\r\n        return;\r\n    }\r\n    newNode->next = NULL;\r\n    newNode->data = e;\r\n    // \u5982\u679c\u6ca1\u6709\u7ed3\u70b9\r\n    if (q->front == NULL) {\r\n        q->front = newNode;\r\n        q->rear = newNode;\r\n        printf('Inserted %d as the first element\\n', e);\r\n    } else {\r\n        q->rear->next = newNode;\r\n        q->rear = newNode;\r\n        printf('Inserted %d at the rear of the queue\\n', e);\r\n    }\r\n}\r\n\r\nType pop(Queue *q) {\r\n    if (isEmpty(q)) {\r\n        printf('Queue is empty, can't pop\\n');\r\n        return -1;\r\n    }\r\n    Node *popNode = q->front;\r\n    q->front = q->front->next;\r\n    Type v = popNode->data;\r\n    if (q->front == NULL) {\r\n        q->rear = NULL;\r\n        printf('Queue is now empty after popping %d\\n', v);\r\n    } else {\r\n        printf('Popped %d from the queue\\n', v);\r\n    }\r\n    free(popNode);\r\n    return v;\r\n}\r\n```\r\n\u5e26\u5934\u7ed3\u70b9:\r\n```C\r\n#define Type int\r\n\r\ntypedef struct Node {\r\n    struct Node *next;\r\n    Type data;\r\n} Node;\r\n\r\ntypedef struct {\r\n    Node *front;\r\n    Node *rear;\r\n} Queue;\r\n\r\nvoid constructor(Queue *q) {\r\n    // \u521b\u5efa\u5934\u7ed3\u70b9\r\n    q->front = q->rear = (Node *) malloc(sizeof(Node));\r\n    q->front->next = NULL;\r\n}\r\n\r\nvoid destructor(Queue *q) {\r\n    Node *p = q->front;\r\n    while (p != NULL) {\r\n        Node *temp = p;\r\n        p = p->next;\r\n        free(temp);\r\n    }\r\n    (*q).front = NULL;\r\n    (*q).rear = NULL;  // \u786e\u4fdd\u961f\u5217\u7684 rear \u4e5f\u8bbe\u7f6e\u4e3a NULL\r\n}\r\n\r\nbool isEmpty(Queue *q) {\r\n    return q->front == q->rear;\r\n}\r\n\r\nvoid push(Queue *q, Type e) {\r\n//    printf('Pushing element: %d\\n', e);  // \u65e5\u5fd7\u8bb0\u5f55\r\n    Node *newNode = (Node *) malloc(sizeof(Node));\r\n    if (newNode == NULL) {\r\n        printf('Can't allocate memory');\r\n        return;\r\n    }\r\n    newNode->next = NULL;\r\n    newNode->data = e;\r\n    q->rear->next = newNode;\r\n    q->rear = newNode;\r\n    printf('Element pushed: %d\\n', e);  // \u65e5\u5fd7\u8bb0\u5f55\r\n}\r\n\r\nType pop(Queue*q){\r\n    if(isEmpty(q)){\r\n        printf('Queue is empty, cannot pop.\\n');  // \u65e5\u5fd7\u8bb0\u5f55\r\n        return -1;\r\n    }\r\n    Node* popNode = q->front->next;\r\n    Type v = popNode->data;\r\n//    printf('Popping element: %d\\n', v);  // \u65e5\u5fd7\u8bb0\u5f55\r\n    q->front->next = popNode->next;\r\n    // \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u7ed3\u70b9\r\n    if(q->rear == popNode){\r\n        q->rear = q->front;\r\n    }\r\n    free(popNode);\r\n    printf('Element popped: %d\\n', v);  // \u65e5\u5fd7\u8bb0\u5f55\r\n    return v;\r\n}\r\n```\u3002", "top": 0, "createdAt": 1727419653, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-27", "dateLabelColor": "#bc4c00"}, "P13": {"htmlDir": "docs/post/OS_1\uff1a-jin-cheng-guan-li.html", "labels": ["\u64cd\u4f5c\u7cfb\u7edf"], "postTitle": "OS_1\uff1a\u8fdb\u7a0b\u7ba1\u7406", "postUrl": "post/OS_1%EF%BC%9A-jin-cheng-guan-li.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/13", "commentNum": 0, "wordCount": 4122, "description": "# \u8fdb\u7a0b\u7684\u6982\u5ff5\u3001\u7ec4\u6210\u3001\u7279\u5f81\r\n## \u6982\u5ff5\r\n\u8fdb\u7a0b\u53ef\u4ee5\u7406\u89e3\u4e3a\u7a0b\u5e8f\u7684\u4e00\u6b21\u6267\u884c\uff0c\u540c\u4e00\u4e2a\u7a0b\u5e8f\u53ef\u4ee5\u521b\u5efa\u591a\u4e2a\u8fdb\u7a0b\r\n## \u7ec4\u6210\r\n\u5f53\u8fdb\u7a0b\u88ab\u521b\u5efa\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4e3a\u8be5\u8fdb\u7a0b\u5206\u914d\u4e00\u4e2a\u552f\u4e00\u7684PID\uff08Process ID\uff0c\u8fdb\u7a0bID\uff09\uff0c\u64cd\u4f5c\u7cfb\u7edf\u8fd8\u4f1a\u8bb0\u5f55\u7ed9\u8fdb\u7a0b\u5206\u914d\u7684\u8d44\u6e90\u60c5\u51b5\u3001\u8fd0\u884c\u72b6\u51b5\u7b49\uff0c\u8fd9\u4e9b\u4fe1\u606f\u90fd\u88ab\u4fdd\u5b58\u5728\u4e00\u4e2a\u6570\u636e\u7ed3\u6784PCB\u4e2d\uff0c\u4e5f\u53eb\u8fdb\u7a0b\u63a7\u5236\u5757\r\n![image](https://github.com/user-attachments/assets/568e1105-9df3-4f30-af4a-54a0885708b6)\r\n\u800c\u8fdb\u7a0b\u7684\u7ec4\u6210\uff0c\u5219\u5982\u4e0b\u56fe\uff1a\r\n![image](https://github.com/user-attachments/assets/195c850a-cbcb-4398-9a1c-77ae05880fef)\r\n\u5176\u4e2d\uff0cPCB\u7531\u64cd\u4f5c\u7cfb\u7edf\u4f7f\u7528\uff0c\u7a0b\u5e8f\u6bb5\u548c\u6570\u636e\u6bb5\u7531\u8fdb\u7a0b\u4f7f\u7528\r\n## \u7279\u5f81\r\n1. \u52a8\u6001\u6027\uff1a\u8fdb\u7a0b\u662f\u7a0b\u5e8f\u7684\u4e00\u6b21\u6267\u884c\u8fc7\u7a0b\uff0c\u662f\u52a8\u6001\u5730\u4ea7\u751f\u3001\u53d8\u5316\u548c\u6d88\u4ea1\u7684\r\n2. \u5e76\u53d1\u6027\uff1a\u5185\u5b58\u4e2d\u6709\u591a\u4e2a\u8fdb\u7a0b\u5b9e\u4f53\uff0c\u5404\u8fdb\u7a0b\u53ef\u5e76\u53d1\u6267\u884c\r\n3. \u72ec\u7acb\u6027\uff1a\u8fdb\u7a0b\u662f\u80fd\u72ec\u7acb\u8fd0\u884c\u3001\u72ec\u7acb\u83b7\u5f97\u8d44\u6e90\u3001\u72ec\u7acb\u63a5\u6536\u8c03\u5ea6\u7684\u57fa\u672c\u5355\u4f4d\r\n4. \u5f02\u6b65\u6027\uff1a\u5404\u8fdb\u7a0b\u6309\u5404\u81ea\u7684\u901f\u5ea6\u63a8\u8fdb\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b**\u8fdb\u7a0b\u540c\u6b65\u673a\u5236**\u6765\u89e3\u51b3\u5f02\u6b65\u95ee\u9898\r\n5. \u7ed3\u6784\u6027\uff1a\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u4f1a\u914d\u7f6e\u4e00\u4e2aPCB\uff0c\u7ed3\u6784\u4e0a\u7531\u4e09\u6bb5\u7ec4\u6210\uff08\u5982\u4e0a\u56fe\uff09\r\n# \u8fdb\u7a0b\u7684\u7ec4\u7ec7\r\n\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u4f1a\u5b58\u5728\u5f88\u591a\u8fdb\u7a0b\uff0c\u6240\u4ee5\u9700\u8981\u4f7f\u7528\u9002\u5f53\u7684\u65b9\u5f0f\u5c06\u591a\u4e2a\u8fdb\u7a0b\u7684PCB\u8fdb\u884c\u7ec4\u7ec7\u7ba1\u7406\r\n## \u94fe\u63a5\u65b9\u5f0f\r\n\u6309\u7167\u8fdb\u7a0b\u72b6\u6001\u5c06PCB\u5206\u4e3a\u591a\u4e2a\u961f\u5217\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6301\u6709\u6307\u5411\u5404\u4e2a\u961f\u5217\u7684\u6307\u9488\r\n![image](https://github.com/user-attachments/assets/583f94a8-0fb0-4df4-8960-78e4651ba05b)\r\n## \u7d22\u5f15\u65b9\u5f0f\r\n\u6839\u636e\u8fdb\u7a0b\u72b6\u6001\u7684\u4e0d\u540c\uff0c\u5efa\u7acb\u51e0\u5f20\u7d22\u5f15\u8868\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6301\u6709\u6307\u5411\u5404\u4e2a\u7d22\u5f15\u8868\u7684\u6307\u9488\r\n![image](https://github.com/user-attachments/assets/615a052b-8780-418c-9dcf-2e7ba81e1e6d)\r\n# \u8fdb\u7a0b\u7684\u72b6\u6001\u4e0e\u8f6c\u6362\r\n\u8fdb\u7a0b\u7684\u72b6\u6001\u6709\uff1a\r\n1. \u8fd0\u884c\u72b6\u6001\r\n2. \u5c31\u7eea\u72b6\u6001\r\n3. \u963b\u585e\u72b6\u6001\r\n4. \u521b\u5efa\u72b6\u6001\r\n5. \u7ec8\u6b62\u72b6\u6001\r\n\u5176\u4e2d\uff0c\u8fd0\u884c\u3001\u5c31\u7eea\u3001\u963b\u585e\u662f\u4e09\u79cd\u6700\u57fa\u672c\u7684\u72b6\u6001\r\n\u72b6\u6001\u4e4b\u95f4\u7684\u8f6c\u6362:\r\n1. \u5c31\u7eea\u6001->\u8fd0\u884c\u6001\r\n2. \u8fd0\u884c\u6001->\u5c31\u7eea\u6001\r\n3. \u8fd0\u884c\u6001->\u963b\u585e\u6001\r\n4. \u963b\u585e\u6001->\u5c31\u7eea\u6001\r\n## \u521b\u5efa\u6001\u3001\u5c31\u7eea\u6001\r\n\u8fdb\u7a0b\u6b63\u5728\u88ab\u521b\u5efa\u65f6\uff0c\u5b83\u7684\u72b6\u6001\u662f\u201c\u521b\u5efa\u6001\u201d\uff0c\u5728\u8fd9\u4e2a\u9636\u6bb5\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4e3a\u8fdb\u7a0b\u5206\u914d\u8d44\u6e90\u3001\u521d\u59cb\u5316PCB\uff1b\u5f53\u8fdb\u7a0b\u521b\u5efa\u5b8c\u6210\u540e\uff0c\u4fbf\u8fdb\u5165\u201c\u5c31\u7eea\u6001\u201d\uff0c\u5904\u4e8e\u5c31\u7eea\u6001\u7684\u8fdb\u7a0b\u5df2\u7ecf\u5177\u5907\u8fd0\u884c\u6761\u4ef6\uff0c\u7b49\u5f85cpu\u7684\u6267\u884c\r\n## \u8fd0\u884c\u6001\r\ncpu\u6b63\u5728\u8fd0\u884c\u7684\u8fdb\u7a0b\r\n## \u963b\u585e\u6001\r\n\u5728\u8fdb\u7a0b\u8fd0\u884c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u53ef\u80fd\u4f1a\u8bf7\u6c42\u7b49\u5f85\u67d0\u4e2a\u4e8b\u4ef6\u7684\u53d1\u751f\uff08\u5982\u7b49\u5f85\u67d0\u79cd\u7cfb\u7edf\u8d44\u6e90\u7684\u5206\u914d\uff0c\u6216\u8005\u7b49\u5f85\u5176\u4ed6\u8fdb\u7a0b\u7684\u54cd\u5e94\uff09\u3002", "top": 0, "createdAt": 1727422623, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-27", "dateLabelColor": "#bc4c00"}, "P14": {"htmlDir": "docs/post/DS_3\uff1a-zi-fu-chuan.html", "labels": ["\u6570\u636e\u7ed3\u6784", "C\u8bed\u8a00"], "postTitle": "DS_3\uff1a\u5b57\u7b26\u4e32", "postUrl": "post/DS_3%EF%BC%9A-zi-fu-chuan.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/14", "commentNum": 0, "wordCount": 9429, "description": "# \u5b57\u7b26\u4e32\r\n\u7531\u96f6\u4e2a\u6216\u591a\u4e2a\u5b57\u7b26\u7ec4\u6210\u7684\u6709\u9650\u5e8f\u5217\r\n1. \u5b50\u4e32\uff1a\u4e32\u4e2d\u4efb\u610f\u4e2a\u8fde\u7eed\u7684\u5b57\u7b26\u7ec4\u6210\u7684\u5b50\u5e8f\u5217\r\n2. \u4e3b\u4e32\uff1a\u5305\u542b\u5b50\u4e32\u7684\u4e32\r\n3. \u5b57\u7b26\u5728\u4e3b\u4e32\u4e2d\u7684\u4f4d\u7f6e\uff1a\u5b57\u7b26\u5728\u4e32\u4e2d\u7684\u5e8f\u53f7\r\n4. \u5b50\u4e32\u5728\u4e3b\u4e32\u4e2d\u7684\u4f4d\u7f6e\uff1a\u5b50\u4e32\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5728\u4e3b\u4e32\u4e2d\u7684\u4f4d\u7f6e\r\n\u57fa\u672c\u64cd\u4f5c\uff1a\r\n1. \u8d4b\u503c\uff1aassign(str*t,str*s)\uff1at\u8d4b\u503c\u4e3as\r\n2. \u590d\u5236\uff1acopy(str*t,str*s)\uff1as\u590d\u5236\u7ed9t\r\n3. \u5224\u7a7a\r\n4. \u957f\u5ea6\r\n5. \u6e05\u7a7a\r\n6. \u91ca\u653e\u5185\u5b58\r\n7. \u62fc\u63a5\r\n8. \u5b50\u4e32\uff1asubstr(str*s,int pos,int len)\r\n9. \u5b9a\u4f4d\uff1a\u82e5\u4e3b\u4e32S\u4e2d\u5b58\u5728\u4e0e\u4e32T\u503c\u76f8\u540c\u7684\u5b50\u4e32\uff0c\u5219\u8fd4\u56de\u5b83\u5728\u4e3b\u4e32S\u4e2d\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\uff1b\u5426\u5219\u51fd\u6570\u503c\u4e3a0\r\n10. \u6bd4\u8f83\u5927\u5c0f\r\n\u5b9e\u73b0\u4f9d\u7136\u662f\u5206\u4e3a\u987a\u5e8f\u5b58\u50a8\u548c\u94fe\u5f0f\u5b58\u50a8\r\n## \u987a\u5e8f\u5b58\u50a8\u5b9e\u73b0\r\n\u987a\u5e8f\u5b58\u50a8\u5185\u90e8\u7684 char \u6570\u7ec4\uff0c\u53ef\u4ee5\u4f7f\u7528\u9759\u6001\u6570\u7ec4\uff0c\u4e5f\u53ef\u4ee5\u4f7f\u7528\u52a8\u6001\u5206\u914d\uff0c\u8fd9\u91cc\u4f7f\u7528\u9759\u6001\u6570\u7ec4\r\n\u987a\u5e8f\u5b58\u50a8\u6709\u51e0\u79cd\u4e0d\u540c\u7684\u5b9e\u73b0\u65b9\u6848:\r\n1. char\u6570\u7ec4\u4ece\u7d22\u5f150\u5f00\u59cb\u5b58\u653e\u5b57\u7b26\uff0c\u4f7f\u7528\u5355\u72ec\u7684\u53d8\u91cf\u5b58\u50a8\u5b57\u7b26\u4e32\u957f\u5ea6\r\n2. char\u6570\u7ec4\u7d22\u5f150\u5b58\u50a8\u957f\u5ea6\uff0c\u540e\u9762\u5b58\u653e\u5b57\u7b26\r\n3. \u6ca1\u6709\u957f\u5ea6\u53d8\u91cf\uff0c\u4ee5\\0\u4f5c\u4e3a\u5b57\u7b26\u4e32\u7ed3\u5c3e\r\n4. char\u6570\u7ec4\u7d22\u5f150\u4e0d\u4f7f\u7528\uff0c\u4f7f\u7528\u5355\u72ec\u7684\u53d8\u91cf\u5b58\u50a8\u5b57\u7b26\u4e32\u957f\u5ea6\r\n\u6211\u91c7\u7528\u7684\u662f\uff1a\u6700\u540e\u4e00\u4f4d\u662f'\\0'\uff0c\u540c\u65f6\u4f7f\u7528len\u53d8\u91cf\r\n```C\r\n#define MAX_LEN 10\r\n\r\ntypedef struct {\r\n    char data[MAX_LEN];\r\n    int length;\r\n} string;\r\n\r\nvoid constructor(string *s) {\r\n    s->length = 0;\r\n    s->data[0] = '\\0';\r\n}\r\n\r\nbool isEmpty(string *s) {\r\n    return s->length == 0;\r\n}\r\n\r\n// \u8d4b\u503c\r\nvoid assign(string *s, const char *t, int len) {\r\n    if (t[0] == '\\0') {\r\n        return;\r\n    }\r\n    if (len >= MAX_LEN ) {\r\n        len = MAX_LEN - 1;\r\n        printf('t is too long, use %d chars\\n', len);\r\n    }\r\n    for (int i = 0; i < len; i++) {\r\n        s->data[i] = t[i];\r\n    }\r\n    s->length = len;\r\n    s->data[len] = '\\0';\r\n}\r\n\r\nvoid copy(string *s, string *t) {\r\n    memcpy(s->data, t->data, t->length);\r\n    s->length = t->length;\r\n    s->data[s->length] = '\\0';\r\n}\r\n\r\nvoid clear(string *s) {\r\n    memset(s->data, '\\0', s->length);\r\n    s->length = 0;\r\n}\r\n\r\nvoid destructor(string *s) {\r\n\r\n}\r\n\r\nbool concat(string *dest, string *s, string *t) {\r\n    if (s->length + t->length > MAX_LEN) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < s->length; i++) {\r\n        dest->data[i] = s->data[i];\r\n    }\r\n    for(int j = 0;j< t->length;j++){\r\n        dest->data[j + s->length] = t->data[j];\r\n    }\r\n    dest->length = s->length + t->length;\r\n    dest->data[dest->length] = '\\0';\r\n    return true;\r\n}\r\n\r\nbool substr(string *dest, string *s, int pos, int len) {\r\n    if (pos + len > s->length) {\r\n        return false;\r\n    }\r\n\r\n    for (int i = pos; i < pos + len; i++) {\r\n        dest->data[i - pos] = s->data[i];\r\n    }\r\n    dest->length = len;\r\n    dest->data[len] = '\\0';\r\n    return true;\r\n}\r\n\r\n// s1>s2 \u8fd4\u56de\u503c\u5927\u4e8e0\r\nint compare(string*s1,string*s2){\r\n    for(int i = 0; i< s1->length && i < s2->length;i++){\r\n        if(s1->data[i] != s2->data[i]){\r\n            return s1->data[i] - s2->data[i];\r\n        }\r\n    }\r\n    // \u957f\u5ea6\u957f\u7684\u4e32\u5927\r\n    return s1->length -s2->length;\r\n}\r\n// \u8fd4\u56det\u5b50\u4e32\u5728 s \u4e2d\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\r\nint index(string*s,string* t){\r\n    int i = 0;\r\n    int n = s->length;\r\n    int m = t->length;\r\n    if(m > n){\r\n        return -1;\r\n    }\r\n    // \u622a\u53d6\u5b50\u4e32\r\n    string sub;\r\n    constructor(&sub);\r\n    while(i <= n-m){\r\n        substr(&sub,s,i,m);\r\n        // \u76f8\u7b49\u76f4\u63a5\u8fd4\u56de\r\n        if(compare(&sub,t) == 0){\r\n            return i;\r\n        }\r\n        i++;\r\n    }\r\n    return -1;\r\n}\r\n```\r\n## \u94fe\u5f0f\u5b58\u50a8\u5b9e\u73b0\r\n\u94fe\u5f0f\u5b58\u50a8\u7684\u6bcf\u4e2a\u8282\u70b9\u53ef\u4ee5\u653e1\u4e2a\u6216\u591a\u4e2a\u5b57\u7b26\uff0c\u8fd9\u91cc\u5b58\u653e4\u4e2a\u5b57\u7b26\r\n```C\r\n#define MAX_CHARS 4\r\ntypedef struct Node {\r\n    // \u6bcf\u4e2a\u8282\u70b9\u5b58\u653e4\u4e2a\u5b57\u7b26\r\n    char data[MAX_CHARS];\r\n    struct Node *next;\r\n} Node;\r\ntypedef Node *string;\r\n\r\nvoid constructor(string *s) {\r\n    *s = (Node *) malloc(sizeof(Node));\r\n    if (*s == NULL) {\r\n        printf('Failed to allocate memory\\n');\r\n        return;\r\n    }\r\n    (*s)->next = NULL;\r\n    for (int i = 0; i < MAX_CHARS; ++i) {\r\n        (*s)->data[i] = '\\0';\r\n    }\r\n}\r\n\r\nvoid destructor(string *s) {\r\n    Node *current = *s;\r\n    while (current != NULL) {\r\n        Node *temp = current;\r\n        current = current->next;\r\n        free(temp);\r\n    }\r\n    *s = NULL;\r\n}\r\n\r\nint size(string *s) {\r\n    Node *current = *s;\r\n    int totalLen = 0;\r\n    while (current != NULL) {\r\n        for (int i = 0; i < MAX_CHARS; i++) {\r\n            if (current->data[i] == '\\0') {\r\n                return totalLen;\r\n            }\r\n            totalLen++;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return totalLen;\r\n}\r\n\r\nbool isEmpty(string *s) {\r\n    return (*s == NULL || (*s)->data[0] == '\\0');\r\n}\r\n\r\nvoid assign(string *s, const char *t, int len) {\r\n    if (t[0] == '\\0') {\r\n        return;\r\n    }\r\n    destructor(s);\r\n    constructor(s);\r\n    Node *current = *s;\r\n    for (int i = 0; i < len; i++) {\r\n        if (i != 0 && i % MAX_CHARS == 0) {\r\n            // \u521b\u5efa\u65b0\u8282\u70b9\r\n            Node *newNode = (Node *) malloc(sizeof(Node));\r\n            if (newNode == NULL) {\r\n                printf('Failed to allocate memory\\n');\r\n                return;\r\n            }\r\n            newNode->next = NULL;\r\n            for (int k = 0; k < MAX_CHARS; ++k) {\r\n                newNode->data[k] = '\\0';\r\n            }\r\n            current->next = newNode;\r\n            current = newNode;\r\n        }\r\n        current->data[i % MAX_CHARS] = t[i];\r\n    }\r\n}\r\n\r\nvoid printStr(string *s) {\r\n    Node *current = *s;\r\n    while (current != NULL) {\r\n        for (int i = 0; i < MAX_CHARS; i++) {\r\n            if (current->data[i] != '\\0') {\r\n                printf('%c', current->data[i]);\r\n            }\r\n        }\r\n        current = current->next;\r\n    }\r\n    printf('\\n');\r\n}\r\n\r\nbool concat(string *dest, string *s, string *t) {\r\n    destructor(dest);\r\n    constructor(dest);\r\n    Node *current = *s;\r\n    Node *destCurrent = *dest;\r\n    int i = 0;\r\n    // s \u62fc\u5230 dest\r\n    while (current != NULL) {\r\n        for (int j = 0; j < MAX_CHARS; j++) {\r\n            if (current->data[j] == '\\0') {\r\n                break;\r\n            }\r\n            destCurrent->data[i++] = current->data[j];\r\n            if (i == MAX_CHARS) {\r\n                // \u521b\u5efa\u65b0\u8282\u70b9\r\n                Node *newNode = (Node *) malloc(sizeof(Node));\r\n                if (newNode == NULL) {\r\n                    printf('Failed to allocate memory\\n');\r\n                    return false;\r\n                }\r\n                newNode->next = NULL;\r\n                for (int k = 0; k < MAX_CHARS; ++k) {\r\n                    newNode->data[k] = '\\0';\r\n                }\r\n                destCurrent->next = newNode;\r\n                destCurrent = newNode;\r\n                i = 0;\r\n            }\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    // \u62fc\u63a5\u5b8c\u4e86 s\uff0c\u4ece dest\u5f53\u524d\u8282\u70b9\u7684\u7b2c i\u4f4d\u62fc\u63a5 t\r\n    current = *t;\r\n    while (current != NULL) {\r\n        for (int j = 0; j < MAX_CHARS; j++) {\r\n            if (current->data[j] == '\\0') {\r\n                break;\r\n            }\r\n            destCurrent->data[i++] = current->data[j];\r\n            // dest\u7684\u8282\u70b9\u6ee1\u4e86\uff0c\u521b\u5efa\u65b0\u8282\u70b9\r\n            if (i == MAX_CHARS) {\r\n                Node *newNode = (Node *) malloc(sizeof(Node));\r\n                if (newNode == NULL) {\r\n                    printf('Failed to allocate memory\\n');\r\n                    return false;\r\n                }\r\n                newNode->next = NULL;\r\n                for (int k = 0; k < MAX_CHARS; ++k) {\r\n                    newNode->data[k] = '\\0';\r\n                }\r\n                destCurrent->next = newNode;\r\n                destCurrent = newNode;\r\n                i = 0;\r\n            }\r\n        }\r\n        current = current->next;\r\n    }\r\n    return true;\r\n}\r\n\r\nbool substr(string *dest, string *s, int pos, int len) {\r\n    destructor(dest);\r\n    constructor(dest);\r\n    int strLen = size(s);\r\n    if (pos + len > strLen) {\r\n        return false;\r\n    }\r\n    // \u4ece\u7b2c\u51e0\u4e2a\u8282\u70b9\u5f00\u59cb\u622a\u53d6\r\n    int i = pos / MAX_CHARS;\r\n    // \u4ece\u8282\u70b9\u7684\u7b2c\u51e0\u4f4d\u5f00\u59cb\u622a\u53d6\r\n    int j = pos % MAX_CHARS;\r\n    Node *current = *s;\r\n    // \u79fb\u52a8\u5230\u7b2c i \u4e2a\u8282\u70b9\r\n    while (i > 0 && current != NULL) {\r\n        current = current->next;\r\n        i--;\r\n    }\r\n\r\n    if (current == NULL) {\r\n        return false; // \u5982\u679c\u6ca1\u6709\u8db3\u591f\u7684\u8282\u70b9\r\n    }\r\n\r\n    Node *destCurrent = *dest;\r\n    int destIndex = 0;\r\n\r\n    // \u5f00\u59cb\u5411 dest \u4e2d\u6dfb\u52a0\u5b57\u7b26\r\n    for (int k = 0; k < len; k++) {\r\n        // \u622a\u53d6\u5b8c\u4e86\u4e00\u4e2a\u8282\u70b9\r\n        if (j == MAX_CHARS) {\r\n            current = current->next;\r\n            j = 0;\r\n        }\r\n        // dest\u7684\u8282\u70b9\u653e\u6ee1\u4e86\r\n        if (destIndex == MAX_CHARS) {\r\n            // \u521b\u5efa\u65b0\u8282\u70b9\r\n            Node *newNode = (Node *) malloc(sizeof(Node));\r\n            if (newNode == NULL) {\r\n                printf('Failed to allocate memory\\n');\r\n                return false;\r\n            }\r\n            newNode->next = NULL;\r\n            for (int l = 0; l < MAX_CHARS; ++l) {\r\n                newNode->data[l] = '\\0';\r\n            }\r\n            destCurrent->next = newNode;\r\n            destCurrent = newNode;\r\n            destIndex = 0;\r\n        }\r\n        destCurrent->data[destIndex++] = current->data[j++];\r\n    }\r\n    return true;\r\n}\r\n\r\n// s1>s2 \u8fd4\u56de\u503c\u5927\u4e8e0\r\nint compare(string *s1, string *s2) {\r\n    Node *current1 = *s1;\r\n    Node *current2 = *s2;\r\n    while (current1 != NULL && current2 != NULL) {\r\n        for (int i = 0; i < MAX_CHARS; i++) {\r\n            if (current1->data[i] == '\\0' || current2->data[i] == '\\0') {\r\n                return current1->data[i] - current2->data[i];\r\n            }\r\n\r\n            if (current1->data[i] != current2->data[i]) {\r\n                return current1->data[i] - current2->data[i];\r\n            }\r\n        }\r\n        current1 = current1->next;\r\n        current2 = current2->next;\r\n    }\r\n    return size(s1) - size(s2);\r\n}\r\n\r\nint indexOfString(string *s, string *t) {\r\n    int sSize = size(s);\r\n    int tSize = size(t);\r\n    if (tSize > sSize) {\r\n        return -1;\r\n    }\r\n\r\n    string sub = NULL;\r\n    int i = 0;\r\n    while (i <= sSize - tSize) {\r\n        if (!substr(&sub, s, i, tSize)) {\r\n            destructor(&sub);\r\n            return -1;\r\n        };\r\n        if (compare(&sub, t) == 0) {\r\n            destructor(&sub);\r\n            return i;\r\n        }\r\n        i++;\r\n    }\r\n    destructor(&sub);\r\n    return -1;\r\n}\r\n```\r\n\u521d\u59cb\u5316\u7684\u65f6\u5019\u53ef\u80fd\u521d\u59cb\u5316\u4e3aNULL\u6bd4\u8f83\u597d\uff0c\u8fd9\u91cc\u5c31\u4e0d\u4f5c\u66f4\u6539\u4e86\u3002", "top": 0, "createdAt": 1727508472, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-09-28", "dateLabelColor": "#bc4c00"}, "P15": {"htmlDir": "docs/post/QT-shi-xian-ju-yu-wang-wen-jian-chuan-shu-ruan-jian.html", "labels": ["QT", "C++"], "postTitle": "QT\u5b9e\u73b0\u5c40\u57df\u7f51\u6587\u4ef6\u4f20\u8f93\u8f6f\u4ef6", "postUrl": "post/QT-shi-xian-ju-yu-wang-wen-jian-chuan-shu-ruan-jian.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/15", "commentNum": 0, "wordCount": 20710, "description": "# \u603b\u4f53\u67b6\u6784\r\n\u8f6f\u4ef6\u901a\u8fc7 UDP \u7ec4\u64ad\u67e5\u8be2\u5c40\u57df\u7f51\u5185\u7684\u8bbe\u5907\uff0c\u6bcf\u4e2a\u8bbe\u5907\u53ef\u4ee5\u9009\u62e9\u6307\u5b9a\u7528\u6237\u8fdb\u884c\u53d1\u9001\u6587\u4ef6\uff1b\u63a5\u6536\u6587\u4ef6\u65f6\u53ef\u4ee5\u6307\u5b9a\u4fdd\u5b58\u8def\u5f84\uff1b\u7cfb\u7edf\u652f\u6301\u591a\u7ebf\u7a0b\r\n\r\n# \u5b9e\u73b0\u601d\u8def\r\n## \u51c6\u5907\u5de5\u4f5c\r\n\u624b\u52a8\u5b9e\u73b0 clickedLabel\uff0c\u5728\u70b9\u51fb\u65f6\u53ef\u4ee5\u5207\u6362\u5230 stackedWidget \u7684\u4e0d\u540c\u9875\r\n![image](https://github.com/user-attachments/assets/bb3513d2-d74e-4f81-ab95-16bec9c14182)\r\n```C++\r\nenum ClickedLabelState {\r\n    Normal = 1,\r\n    // Hover = 2,\r\n    Selected = 3\r\n};\r\n\r\nclass ClickedLabel : public QLabel {\r\n    Q_OBJECT\r\n  public:\r\n    explicit ClickedLabel(QWidget* parent = nullptr);\r\n    void setInfo(const QString& normalPath, const QString& selectedPath, const QString& text);\r\n    ClickedLabelState getCurState() const;\r\n    void setSelected(bool selected);\r\n\r\n  private:\r\n    ClickedLabelState _curstate;\r\n    void setImage(const QString& path);\r\n    // \u4e24\u79cd\u72b6\u6001\u7684\u56fe\u7247\u8def\u5f84\r\n    QString _normal_path;\r\n    QString _selected_path;\r\n    QString _text;\r\n  signals:\r\n    void clicked();\r\n\r\n  protected:\r\n    // \u9f20\u6807\u70b9\u51fb\r\n    virtual void mousePressEvent(QMouseEvent* event) override;\r\n    // \u9f20\u6807\u677e\u5f00\r\n    virtual void mouseReleaseEvent(QMouseEvent* event) override;\r\n    // \u9f20\u6807\u60ac\u6d6e\r\n    virtual void enterEvent(QEnterEvent* event) override;\r\n    // \u9f20\u6807\u79fb\u8d70\r\n    virtual void leaveEvent(QEvent* event) override;\r\n};\r\n```\r\n```C++\r\nClickedLabel::ClickedLabel(QWidget* parent) : QLabel(parent), _curstate(ClickedLabelState::Normal) {\r\n\r\n}\r\n\r\nvoid ClickedLabel::setInfo(const QString& normalPath, const QString& selectedPath, const QString& text) {\r\n    _normal_path = normalPath;\r\n    _selected_path = selectedPath;\r\n    _text = text;\r\n}\r\n\r\nClickedLabelState ClickedLabel::getCurState() const {\r\n    return _curstate;\r\n}\r\n\r\n\r\nvoid ClickedLabel::setSelected(bool selected) {\r\n    if (selected) {\r\n        _curstate = ClickedLabelState::Selected;\r\n        setImage(_selected_path);\r\n    } else {\r\n        _curstate = ClickedLabelState::Normal;\r\n        setImage(_normal_path);\r\n    }\r\n}\r\n\r\nvoid ClickedLabel::setImage(const QString& path) {\r\n    int imageWidth = 20;   // \u56fe\u50cf\u5bbd\u5ea6\r\n    int imageHeight = 20;  // \u56fe\u50cf\u9ad8\u5ea6\r\n\r\n    // \u4f7f\u7528 HTML \u6807\u7b7e\u8bbe\u7f6e\u56fe\u50cf\u548c\u6587\u5b57\r\n    QString labelText =\r\n        QString('<img src='%1' width='%2' height='%3'> %4').arg(path).arg(imageWidth).arg(imageHeight).arg(_text);\r\n    setText(labelText);\r\n}\r\n\r\nvoid ClickedLabel::mousePressEvent(QMouseEvent* event) {\r\n    if (event->button() == Qt::LeftButton) {\r\n        // \u6309\u4e0b\u5de6\u952e\uff0c\u5207\u6362\u72b6\u6001\r\n        if (_curstate == ClickedLabelState::Normal) {\r\n            // qInfo() << 'Mouse press event, set state selected';\r\n            _curstate = ClickedLabelState::Selected;\r\n        }else{\r\n            qInfo()<<'This label is already selected';\r\n        }\r\n        return;\r\n    }\r\n    QLabel::mousePressEvent(event);\r\n}\r\n\r\nvoid ClickedLabel::mouseReleaseEvent(QMouseEvent* event) {\r\n    if (event->button() == Qt::LeftButton) {\r\n        if (_curstate == ClickedLabelState::Selected) {\r\n            setImage(_selected_path);\r\n            emit clicked();\r\n        }else{\r\n            qInfo()<<'This label is already selected';\r\n        }\r\n        return;\r\n    }\r\n    // \u8c03\u7528\u57fa\u7c7b\u7684mousePressEvent\u4ee5\u4fdd\u8bc1\u6b63\u5e38\u7684\u4e8b\u4ef6\u5904\u7406\r\n    QLabel::mousePressEvent(event);\r\n}\r\n\r\nvoid ClickedLabel::enterEvent(QEnterEvent* event) {\r\n    setCursor(Qt::PointingHandCursor);\r\n    QLabel::enterEvent(event);\r\n}\r\n\r\nvoid ClickedLabel::leaveEvent(QEvent* event) {\r\n    setCursor(Qt::ArrowCursor);\r\n    QLabel::leaveEvent(event);\r\n}\r\n```\r\n## \u8bbe\u5907\u4fe1\u606f\r\n\u521b\u5efa DeviceInfo \u5934\u6587\u4ef6\uff0c\u5b58\u50a8\u8bbe\u5907\u7684\u4e00\u4e9b\u4fe1\u606f\uff0c\u4e3a\u4e86\u53d1\u9001\u4e0e\u63a5\u6536\u7684\u65f6\u5019\u65b9\u4fbf\u89e3\u6790\uff0c\u6dfb\u52a0\u8f6c\u6362\u51fd\u6570\r\n```C++\r\nstruct DeviceInfo {\r\n    QString deviceName;\r\n    QString ip;\r\n    // tcp \u76d1\u542c\u7684\u7aef\u53e3\r\n    QString port;]\r\n    // \u662f\u5426\u5df2\u7ecf\u9000\u51fa\r\n    bool isQuit = false;\r\n    // \u91cd\u8f7d\u8fd0\u7b97\u7b26\u7528\u4e8e\u5e8f\u5217\u5316\r\n    friend QDataStream& operator<<(QDataStream& out, const DeviceInfo& device) {\r\n        out << device.deviceName << device.ip << device.port << device.isQuit;\r\n        return out;\r\n    }\r\n\r\n    // \u91cd\u8f7d\u8fd0\u7b97\u7b26\u7528\u4e8e\u53cd\u5e8f\u5217\u5316\r\n    friend QDataStream& operator>>(QDataStream& in, DeviceInfo& device) {\r\n        in >> device.deviceName >> device.ip >> device.port >> device.isQuit;\r\n        return in;\r\n    }\r\n};\r\n\r\n// \u5c06\u7ed3\u6784\u4f53\u8f6c\u6362\u4e3aQByteArray\r\nstatic QByteArray deviceInfoToByteArray(const DeviceInfo& device) {\r\n    QByteArray byteArray;\r\n    QDataStream out(&byteArray, QIODevice::WriteOnly);\r\n    out.setVersion(QDataStream::Qt_6_5);  // \u8bbe\u7f6e\u7248\u672c\uff0c\u786e\u4fdd\u517c\u5bb9\u6027\r\n    out << device;                        // \u4f7f\u7528\u91cd\u8f7d\u7684<<\u8fd0\u7b97\u7b26\r\n    return byteArray;\r\n}\r\n\r\n// \u4eceQByteArray\u6062\u590d\u7ed3\u6784\u4f53\r\nstatic DeviceInfo byteArrayToDeviceInfo(const QByteArray& byteArray) {\r\n    DeviceInfo device;\r\n    QDataStream in(byteArray);\r\n    in.setVersion(QDataStream::Qt_6_5);  // \u8bbe\u7f6e\u7248\u672c\uff0c\u786e\u4fdd\u517c\u5bb9\u6027\r\n    in >> device;                        // \u4f7f\u7528\u91cd\u8f7d\u7684>>\u8fd0\u7b97\u7b26\r\n    return device;\r\n}\r\n```\r\n## \u7ec4\u64ad\u529f\u80fd\r\n\u521b\u5efa DiscoveryService \u5355\u4f8b\u7c7b\uff0c\u8fdb\u884c\u7ec4\u64ad\uff0c\u91c7\u7528\u5b9a\u65f6\u5668\u5b9a\u65f6\u7ec4\u64ad\uff0c\u67e5\u8be2\u5230\u7684\u8bbe\u5907\u5b58\u653e\u5230 QMap \u4e2d\u8fdb\u884c\u7ba1\u7406\r\n### \u6210\u5458\u53d8\u91cf\r\n```C++\r\nclass DiscoveryService : public QObject {\r\n    Q_OBJECT\r\n  public:\r\n    static DiscoveryService* getInstance();\r\n    // \u5f00\u542f\u7ec4\u64ad\u670d\u52a1\r\n    void startDiscovery();\r\n    DiscoveryService& operator=(const DiscoveryService&) = delete;\r\n    DiscoveryService(const DiscoveryService&) = delete;\r\n    void setDeivceName(const QString& name);\r\n    ~DiscoveryService();\r\n    void stopDiscovery();\r\n  signals:\r\n    // \u53d1\u73b0\u4e86\u65b0\u8bbe\u5907\r\n    void deviceDiscovered(const DeviceInfo& receiveDevice);\r\n    // \u66f4\u65b0\u8bbe\u5907\u540d\u79f0\r\n    void deviceNameChanged(const DeviceInfo& receiveDevice);\r\n    void deviceRemoved(const DeviceInfo& removeDevice);\r\n\r\n  private:\r\n    explicit DiscoveryService(QObject* parent = nullptr);\r\n    // \u7ec4\u64ad\u9891\u7387\r\n    const int DISCOVERY_INTERVAL_MS = 500;\r\n    // \u7ec4\u64ad\u7684\u7aef\u53e3\u53f7\r\n    const quint16 multicastPort;\r\n    // \u7ec4\u64ad\u5730\u5740\r\n    const QHostAddress multicastAddress;\r\n    QUdpSocket* _udp_socket;\r\n    QTimer* _discovery_timer;\r\n    // \u5b58\u653e\u672c\u673a\u8bbe\u5907\u4fe1\u606f\r\n    DeviceInfo _device;\r\n    // \u7ec4\u64ad\u67e5\u8be2\u5230\u7684\u8bbe\u5907\u5217\u8868\r\n    QMap<QString, DeviceInfo> _devices;\r\n    // \u83b7\u53d6\u672c\u673aIP\u5730\u5740\r\n    const QString getLocalAddress();\r\n\r\n  private slots:\r\n    void processPendingDatagrams();\r\n};\r\n```\r\n### \u6784\u9020\u51fd\u6570\r\n\u521d\u59cb\u5316UDPSocket\u3001\u7ed1\u5b9a\u7ec4\u64ad\u7aef\u53e3\u3001\u5730\u5740\u3001\u8bbe\u5907\u7684ip\uff0c\u7ed1\u5b9a\u4fe1\u53f7\u548c\u69fd\u51fd\u6570\r\n```C++\r\nDiscoveryService::DiscoveryService(QObject* parent) :\r\n    QObject{parent}, multicastPort(45454), multicastAddress(QHostAddress('239.255.255.250')) {\r\n    _udp_socket = new QUdpSocket(this);\r\n    _discovery_timer = new QTimer(this);\r\n    _device.ip = getLocalAddress();\r\n    // \u7ed1\u5b9a\u672c\u5730\u7aef\u53e3\r\n    _udp_socket->bind(QHostAddress::AnyIPv4, multicastPort);\r\n    // \u52a0\u5165\u7ec4\u64ad\u7ec4\r\n    _udp_socket->joinMulticastGroup(multicastAddress);\r\n    // \u5f00\u59cb\u63a5\u53d7\u6570\u636e\u5305\r\n    connect(_udp_socket, &QUdpSocket::readyRead, this, &DiscoveryService::processPendingDatagrams);\r\n}\r\nconst QString DiscoveryService::getLocalAddress() {\r\n    QStringList ipAddressesList;  // \u521b\u5efa\u4e00\u4e2a\u5b57\u7b26\u4e32\u5217\u8868\u6765\u5b58\u50a8\u672c\u673a\u7684\u6240\u6709 IP \u5730\u5740\r\n    // \u83b7\u53d6\u6240\u6709\u7f51\u7edc\u63a5\u53e3\u7684 IP \u5730\u5740\u5217\u8868\r\n    const QList<QHostAddress>& allAddresses = QNetworkInterface::allAddresses();\r\n    // \u904d\u5386\u6240\u6709 IP \u5730\u5740\uff0c\u7b5b\u9009\u51fa\u6709\u6548\u7684 IPv4 \u5730\u5740\uff08\u5ffd\u7565\u56de\u73af\u5730\u5740\u548c\u672c\u5730\u94fe\u8def\u5730\u5740\uff09\r\n    for (const QHostAddress& address : allAddresses) {\r\n        if (address.protocol() == QAbstractSocket::IPv4Protocol &&  // \u53ea\u9009\u62e9 IPv4 \u5730\u5740\r\n            !address.isLoopback()) {                                // \u5ffd\u7565\u56de\u73af\u5730\u5740\uff08\u5982 127.0.0.1\uff09\r\n            ipAddressesList.append(address.toString());             // \u5c06\u7b26\u5408\u6761\u4ef6\u7684\u5730\u5740\u6dfb\u52a0\u5230\u5217\u8868\u4e2d\r\n        }\r\n    }\r\n    // \u5982\u679c\u627e\u5230\u81f3\u5c11\u4e00\u4e2a\u6709\u6548\u7684\u672c\u673a IP \u5730\u5740\uff0c\u8fd4\u56de\u7b2c\u4e00\u4e2a\r\n    if (!ipAddressesList.isEmpty()) {\r\n        qDebug() << 'Local address is ' << ipAddressesList.first();\r\n        return ipAddressesList.first();  // \u8fd4\u56de\u7b2c\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u672c\u673a IP \u5730\u5740\r\n    } else {\r\n        qWarning() << 'Fail to find local address';\r\n        return '0.0.0.0';  // \u5982\u679c\u6ca1\u6709\u627e\u5230\u6709\u6548\u5730\u5740\uff0c\u8fd4\u56de '0.0.0.0'\r\n    }\r\n}\r\n```\r\n### \u53d1\u9001\u4e0e\u5904\u7406\u7ec4\u64ad\u6d88\u606f\u7684\u69fd\u51fd\u6570\r\n\u53d1\u9001\uff1a\u5c06\u672c\u673a\u7684\u4fe1\u606f\u8fdb\u884c\u7ec4\u64ad\uff0c\u4f7f\u7528\u5b9a\u65f6\u5668\u5b9a\u65f6\u53d1\u9001\r\n```C++\r\nvoid DiscoveryService::startDiscovery() {\r\n    connect(_discovery_timer, &QTimer::timeout, this, [this]() {\r\n        // \u53d1\u9001\u7ec4\u64ad\u8bf7\u6c42\r\n        // TODO \u672c\u673a\u5206\u914d\u7ed9tcp\u7684\u7aef\u53e3\u83b7\u53d6\r\n        QByteArray datagram = deviceInfoToByteArray(_device);  // \u7ec4\u64ad\u8bf7\u6c42\u5185\u5bb9\r\n        // qDebug() << 'Sending datagram:' << datagram.toHex();   // \u6253\u5370\u6570\u636e\u5305\u5185\u5bb9\r\n        _udp_socket->writeDatagram(datagram, multicastAddress, multicastPort);\r\n    });\r\n    _discovery_timer->start(DISCOVERY_INTERVAL_MS);\r\n}\r\n```\r\n\u63a5\u6536\uff1a\u89e3\u6790\u6536\u5230\u7684\u8bbe\u5907\u4fe1\u606f\r\n1. \u672c\u673a\u8bbe\u5907\u5c31\u76f4\u63a5return\r\n2. isQuit\u4e3atrue\u5c31\u79fb\u9664\u8be5\u8bbe\u5907\r\n3. \u5df2\u7ecf\u5b58\u5728\u4e8e\u8bbe\u5907\u5217\u8868\u4e2d\u5e76\u4e14\u8bbe\u5907\u540d\u5b57\u4e5f\u6ca1\u66f4\u6539\u4e5f\u76f4\u63a5\u8df3\u8fc7\r\n4. \u5df2\u7ecf\u5b58\u5728\u4e8e\u8bbe\u5907\u5217\u8868\u4e2d\u4f46\u662f\u8bbe\u5907\u540d\u5b57\u66f4\u6539\u4e86\u5c31\u53d1\u9001deviceNameChanged\u4fe1\u53f7\u901a\u77e5ui\u66f4\u65b0\r\n5. \u4e0d\u5b58\u5728\u4e8e\u8bbe\u5907\u5217\u8868\u4e2d\u5c31\u53d1\u9001deviceDiscovered\u4fe1\u53f7\u901a\u77e5ui\u66f4\u65b0\r\n```C++\r\nvoid DiscoveryService::processPendingDatagrams() {\r\n    while (_udp_socket->hasPendingDatagrams()) {\r\n        QByteArray datagram;\r\n        // \u63a5\u6536\u5230\u7684\u8bbe\u5907\u4fe1\u606f\r\n        QHostAddress sender;\r\n        quint16 senderPort;\r\n        // \u63a5\u6536\u6570\u636e\u5305\r\n        datagram.resize(_udp_socket->pendingDatagramSize());\r\n        _udp_socket->readDatagram(datagram.data(), datagram.size(), &sender, &senderPort);\r\n\r\n        DeviceInfo receiveDevice = byteArrayToDeviceInfo(datagram);\r\n        // \u5904\u7406\u63a5\u6536\u5230\u7684\u6570\u636e\u5305\r\n        QString ip = receiveDevice.ip;\r\n        QString port = receiveDevice.port;\r\n        QString name = receiveDevice.deviceName;\r\n        bool quit = receiveDevice.isQuit;\r\n        // \u53d1\u73b0\u7684\u662f\u672c\u673a\r\n        if (name == _device.deviceName && ip == _device.ip) {\r\n            return;\r\n        }\r\n        if (quit) {\r\n            qDebug() << 'Device removed: ' << name;\r\n            // \u9000\u51fa\u4e86\r\n            _devices.remove(ip);\r\n            emit deviceRemoved(receiveDevice);\r\n            return;\r\n        }\r\n        // \u7b2c\u4e00\u6b21\u7ec4\u64ad\u5230\u8be5\u8bbe\u5907\r\n        if (!_devices.contains(ip)) {\r\n            // \u66f4\u65b0\u8bbe\u5907\u5217\u8868\r\n            _devices[ip] = receiveDevice;\r\n            qDebug() << 'New device discovered:' << ip << ', Tcp port:' << port << ', name: ' << name;\r\n            // \u53d1\u73b0\u65b0\u8bbe\u5907\r\n            emit deviceDiscovered(receiveDevice);\r\n        } else {\r\n            // \u5df2\u7ecf\u52a0\u5230\u5217\u8868\u91cc\u4e86\r\n            QString exist_name = _devices[ip].deviceName;\r\n            if (exist_name == name) {\r\n                // \u5982\u679c\u540d\u5b57\u4e00\u6837\u5c31\u4e0d\u66f4\u65b0\r\n                return;\r\n            } else {\r\n                _devices[ip] = receiveDevice;\r\n                // \u66f4\u65b0\u540d\u5b57\r\n                emit deviceNameChanged(receiveDevice);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\u505c\u6b62\u7ec4\u64ad\u4e0e\u6790\u6784\uff1a\u5148\u5c06\u5b9a\u65f6\u5668\u5173\u95ed\uff0c\u5c06isQuit\u8bbe\u7f6e\u4e3atrue\u518d\u8fdb\u884c\u4e00\u6b21\u7ec4\u64ad\uff0c\u5176\u5b83\u8bbe\u5907\u63a5\u53d7\u5230\u540e\u5c31\u4f1a\u5728\u4e0a\u9762\u7684\u51fd\u6570\u4e2d\u6267\u884c\u4ece\u8bbe\u5907\u5217\u8868\u4e2d\u79fb\u9664\u8be5\u8bbe\u5907\u7684\u903b\u8f91\r\n```C++\r\nDiscoveryService::~DiscoveryService() {\r\n    _udp_socket->leaveMulticastGroup(multicastAddress);\r\n    _udp_socket->abort();\r\n    qDebug() << 'Exit multicast';\r\n}\r\n\r\nvoid DiscoveryService::stopDiscovery() {\r\n    _discovery_timer->stop();\r\n    //  \u79fb\u9664\u8be5\u8bbe\u5907\r\n    _device.isQuit = true;\r\n    QByteArray datagram = deviceInfoToByteArray(_device);  // \u7ec4\u64ad\u8bf7\u6c42\u5185\u5bb9\r\n    // qDebug() << 'Sending datagram:' << datagram.toHex();   // \u6253\u5370\u6570\u636e\u5305\u5185\u5bb9\r\n    _udp_socket->writeDatagram(datagram, multicastAddress, multicastPort);\r\n}\r\n```\r\n### MainWindow\u4e2d\u5bf9\u4e0a\u9762\u7684\u5404\u4e2a\u4fe1\u53f7\u7684\u5904\u7406\u3001\u521d\u59cb\u5316\uff1a\r\n\u6784\u9020\u51fd\u6570\u4e2d\uff0c\u521d\u59cb\u5316\u5404\u4e2a\u56fe\u6807\uff0c\u8bbe\u7f6e\u672c\u673a\u7684\u8bbe\u5907\u540d\uff0c\u5f00\u59cb\u8fdb\u884c\u7ec4\u64ad\uff0c\u5e76\u8fde\u63a5\u4fe1\u53f7\u4e0e\u69fd\r\n```C++\r\nMainWindow::MainWindow(QWidget* parent) : QMainWindow(parent), ui(new Ui::MainWindow) {\r\n    ui->setupUi(this);\r\n\r\n    // .... \u8bbe\u7f6eui \u7684\u64cd\u4f5c.....\u7565\r\n    // \u83b7\u53d6\u672c\u673a\u8bbe\u5907\u540d\r\n    ui->edit_device_name->setText(QHostInfo::localHostName());\r\n    DiscoveryService::getInstance()->setDeivceName(ui->edit_device_name->text());\r\n    DiscoveryService::getInstance()->startDiscovery();\r\n    // \u53d1\u73b0\u65b0\u8bbe\u5907\r\n    connect(DiscoveryService::getInstance(), &DiscoveryService::deviceDiscovered, this, &MainWindow::updateDeviceList);\r\n    // \u66f4\u65b0\u8bbe\u5907\u5217\u8868\u7684\u540d\u5b57\r\n    connect(DiscoveryService::getInstance(), &DiscoveryService::deviceNameChanged, this, &MainWindow::updateDeviceName);\r\n    // \u79fb\u9664\u8bbe\u5907\r\n    connect(DiscoveryService::getInstance(), &DiscoveryService::deviceRemoved, this, &MainWindow::removeDevice);\r\n}\r\n```\r\n\u53d1\u73b0\u4e86\u65b0\u8bbe\u5907\u7684\u69fd\u51fd\u6570\uff1a\u5c06\u8bbe\u5907\u540d\u79f0\u7528\u4e8e\u663e\u793a\uff0cip\u7b49\u4fe1\u606f\u4fdd\u5b58\u5230data\u4e2d\u5373\u53ef\r\n```C++\r\nvoid MainWindow::updateDeviceList(const DeviceInfo& receiveDevice) {\r\n    QListWidgetItem* item = new QListWidgetItem(receiveDevice.deviceName);\r\n    QByteArray data;\r\n    QDataStream stream(&data, QIODevice::WriteOnly);\r\n    stream << receiveDevice.ip << receiveDevice.port;\r\n    // \u5b58\u50a8ip \u548c\u7aef\u53e3\r\n    item->setData(Qt::UserRole, data);\r\n    ui->deviceListWidget->addItem(item);\r\n}\r\n```\r\n\u66f4\u65b0\u8bbe\u5907\u540d\u79f0\u7684\u69fd\u51fd\u6570\uff1a\u627e\u5230ip\u4e00\u6837\u7684\uff0c\u8fdb\u884c\u66f4\u65b0\u754c\u9762\u5373\u53ef\r\n```C++\r\nvoid MainWindow::updateDeviceName(const DeviceInfo& receiveDevice) {\r\n    for (int i = ui->deviceListWidget->count() - 1; i >= 0; i--) {\r\n        QListWidgetItem* item = ui->deviceListWidget->item(i);\r\n        QByteArray data = item->data(Qt::UserRole).toByteArray();\r\n        QDataStream stream(&data, QIODevice::ReadOnly);\r\n        QString ip;\r\n        // \u8bfb\u53d6 ip\r\n        stream >> ip;\r\n        if (ip == receiveDevice.ip) {\r\n            qDebug() << 'Found devices that name changed ip: ' << ip;\r\n            // \u66f4\u65b0\u8bbe\u5907\u540d\u79f0\r\n            qDebug() << 'Updating device name to: ' << receiveDevice.deviceName;\r\n            item->setText(receiveDevice.deviceName);\r\n            ui->deviceListWidget->update();\r\n            return;\r\n        }\r\n    }\r\n}\r\n```\r\n\u79fb\u9664\u8bbe\u5907\u7684\u69fd\u51fd\u6570\uff1a\u627e\u5230\u8bbe\u5907\u540d\u79f0\u4e00\u6837\u7684item\u8fdb\u884c\u79fb\u9664\u5373\u53ef\r\n```C++\r\nvoid MainWindow::removeDevice(const DeviceInfo& removeDevice) {\r\n    for (int i = ui->deviceListWidget->count() - 1; i >= 0; i--) {\r\n        QListWidgetItem* item = ui->deviceListWidget->item(i);\r\n        if (item->text() == removeDevice.deviceName) {\r\n            qDebug() << 'Remove device: ' << item->text();\r\n            ui->deviceListWidget->removeItemWidget(item);\r\n            delete ui->deviceListWidget->takeItem(ui->deviceListWidget->row(item));\r\n            return;\r\n        }\r\n    }\r\n}\r\n```\r\n\u6dfb\u52a0\u4fe1\u53f7\u4e0e\u69fd\uff1a\u5728\u8bbe\u5907\u540d\u79f0\u7684\u8f93\u5165\u6846\u4fee\u6539\u540e\uff0c\u540c\u6b65\u66f4\u6539DiscoveryService\u4e2d\u7684\u672c\u673a\u8bbe\u5907\u4fe1\u606f\r\n```C++\r\nvoid MainWindow::on_edit_device_name_editingFinished() {\r\n    qDebug() << 'Editing finished slot';\r\n    DiscoveryService::getInstance()->setDeivceName(ui->edit_device_name->text());\r\n}\r\n```\r\n\u5728MainWindow\u7684\u6790\u6784\u51fd\u6570\u4e2d\uff0c\u505c\u6b62\u7ec4\u64ad\u5373\u53ef\uff1a\r\n```C++\r\nMainWindow::~MainWindow() {\r\n    DiscoveryService::getInstance()->stopDiscovery();\r\n    delete ui;\r\n}\r\n```\r\n## \u6587\u4ef6\u7c7b\r\n\u4e3a\u4e86\u6587\u4ef6\u4f20\u8f93\u7684\u5b8c\u6574\u6027\u3001\u4fdd\u5b58\u4f4d\u7f6e\u7684\u7075\u6d3b\u6027\uff0c\u5c06\u53d1\u9001\u7684\u6587\u4ef6\u5c01\u88c5\u6210\u4e00\u4e2a\u7c7b\uff1a\r\n```C++\r\nclass TLVFile {\r\n  public:\r\n    enum MessageType { ID_FILE = 1, ID_TEXT = 2, ID_FOLDER = 3 };\r\n    TLVFile(MessageType type, const QString& fileName, const QByteArray& content);\r\n    // \u5e8f\u5217\u5316\r\n    QByteArray toByteArray() const;\r\n    // \u53cd\u5e8f\u5217\u5316\r\n    static TLVFile fromByteArray(const QByteArray& data);\r\n    // \u83b7\u53d6\u6d88\u606f\u7c7b\u578b\r\n    MessageType getType() const;\r\n    // \u83b7\u53d6\u6587\u4ef6\u957f\u5ea6\r\n    qint32 getLength() const;\r\n    // \u83b7\u53d6\u5185\u5bb9\r\n    QByteArray getContent() const;\r\n    // \u83b7\u53d6\u6587\u4ef6\u540d\u79f0\r\n    QString getFileName() const;\r\n\r\n  private:\r\n    MessageType _type;\r\n    qint32 _length;       // \u6d88\u606f\u957f\u5ea6\r\n    QByteArray _content;  // \u6d88\u606f\u5185\u5bb9\r\n    QString _fileName;    // \u6587\u4ef6\u540d\u79f0\r\n};\r\n```\r\n```C++\r\nTLVFile::TLVFile(MessageType type, const QString& fileName, const QByteArray& content) :\r\n    _type(type), _fileName(fileName), _content(content) {\r\n    _length = content.size();\r\n}\r\n\r\n// \u83b7\u53d6\u6587\u4ef6\u540d\u79f0\r\nQString TLVFile::getFileName() const { return _fileName; }\r\n\r\n// \u5e8f\u5217\u5316\u5b9e\u73b0\r\nQByteArray TLVFile::toByteArray() const {\r\n    QByteArray result;\r\n    QDataStream stream(&result, QIODevice::WriteOnly);\r\n    stream << static_cast<qint32>(_type);\r\n    stream << _length;\r\n    stream << _fileName;\r\n    stream << _content;\r\n    return result;\r\n}\r\n\r\n// \u53cd\u5e8f\u5217\u5316\u5b9e\u73b0\r\nTLVFile TLVFile::fromByteArray(const QByteArray& data) {\r\n    QDataStream stream(data);\r\n    qint32 type;\r\n    qint32 length;\r\n    QString fileName;\r\n    QByteArray content;\r\n\r\n    stream >> type >> length >> fileName >> content;\r\n\r\n    return TLVFile(static_cast<MessageType>(type), fileName, content);\r\n}\r\n\r\nTLVFile::MessageType TLVFile::getType() const { return _type; }\r\n\r\nqint32 TLVFile::getLength() const { return _length; }\r\n\r\nQByteArray TLVFile::getContent() const { return _content; }\r\n```\r\n## \u521b\u5efaTCP\u670d\u52a1\u5668\r\n\u4e00\u4e2a\u5ba2\u6237\u7aef\u53ea\u80fd\u6709\u4e00\u4e2aTCP\u670d\u52a1\u5668\uff0c\u76f4\u63a5\u91c7\u7528\u5355\u4f8b\u6a21\u5f0f\u5373\u53ef\uff0c\u7aef\u53e3\u53f7\u81ea\u52a8\u5206\u914d\uff0c\u5728\u7ec4\u64ad\u65f6\u5c06\u83b7\u53d6\u7684TCP\u7aef\u53e3\u53f7\u8fdb\u884c\u8bbe\u7f6e\uff0c\u5728\u63a5\u6536\u5230\u8fde\u63a5\u540e\uff0c\u5c06\u63a5\u6536\u4efb\u52a1\u4ea4\u7ed9\u7ebf\u7a0b\u6c60\u6765\u5904\u7406\r\n```C++\r\nclass FileTransferServer : public QObject {\r\n    Q_OBJECT\r\n  public:\r\n    static FileTransferServer* getInstance();\r\n    FileTransferServer(const FileTransferServer&) = delete;\r\n    FileTransferServer& operator=(const FileTransferServer&) = delete;\r\n    ~FileTransferServer();\r\n    // \u5f00\u542f\u670d\u52a1\u5668\r\n    void startServer();\r\n    // \u83b7\u53d6\u670d\u52a1\u5668\u7aef\u53e3\r\n    quint16 getPort();\r\n\r\n  private:\r\n    explicit FileTransferServer(QObject* parent = nullptr);\r\n    QTcpServer* _server;\r\n    quint16 _port;\r\n  private slots:\r\n    // \u5904\u7406\u65b0\u8fde\u63a5\r\n    void acceptConnection();\r\n  signals:\r\n};\r\n```\r\n```C++\r\nFileTransferServer* FileTransferServer::getInstance() {\r\n    static FileTransferServer instance;\r\n    return &instance;\r\n}\r\n\r\nFileTransferServer::FileTransferServer(QObject* parent) : QObject{parent}, _server(nullptr) {\r\n    // \u9650\u5236\u4e3a5\u4e2a\u7ebf\u7a0b\r\n    QThreadPool::globalInstance()->setMaxThreadCount(5);\r\n}\r\n\r\nvoid FileTransferServer::acceptConnection() {\r\n    QTcpSocket* clientSocket = _server->nextPendingConnection();\r\n    qDebug() << 'New connection from ' << clientSocket->peerAddress().toString();\r\n    // \u63a5\u6536\u8fde\u63a5\u540e\u7684\u4efb\u52a1\u5904\u7406\u4ea4\u7ed9\u7ebf\u7a0b\u6c60\r\n    // TODO \u63a5\u6536\u529f\u80fd\u5b9e\u73b0\r\n    FileReceiver* receiver = new FileReceiver(clientSocket);\r\n    QThreadPool::globalInstance()->start(receiver);  // \u5c06\u4efb\u52a1\u52a0\u5165\u7ebf\u7a0b\u6c60\r\n}\r\n\r\nFileTransferServer::~FileTransferServer() {\r\n    if (_server) {\r\n        _server->close();\r\n    }\r\n}\r\n\r\nvoid FileTransferServer::startServer() {\r\n    if (!_server) {\r\n        _server = new QTcpServer(this);\r\n        connect(_server, &QTcpServer::newConnection, this, &FileTransferServer::acceptConnection);\r\n        // \u81ea\u52a8\u5206\u914d\u7aef\u53e3\r\n        if (!_server->listen(QHostAddress::AnyIPv4, 0)) {\r\n            qWarning() << 'Server failed to start!';\r\n        } else {\r\n            _port = _server->serverPort();\r\n            qDebug() << 'Server started on port' << _port;\r\n        }\r\n    }\r\n}\r\n\r\nquint16 FileTransferServer::getPort() { return _port; }\r\n```\r\n## TCP\u53d1\u9001\u7aef\r\n\u53d1\u9001\u7aef\u83b7\u53d6\u670d\u52a1\u7aefip\u3001\u7aef\u53e3\u548c\u672c\u5730\u7684\u6587\u4ef6\u8def\u5f84\uff0c\u5305\u88c5\u6210TLVFile\u7c7b\u578b\u8fdb\u884c\u53d1\u9001\u5373\u53ef\r\n```C++\r\nclass FileTransferClient : public QObject {\r\n    Q_OBJECT\r\n  public:\r\n    explicit FileTransferClient(QObject* parent = nullptr);\r\n    void sendFile(const QString& serverIp, quint16 serverPort, const QString& filePath);\r\n\r\n  private:\r\n    QTcpSocket* _socket;\r\n  signals:\r\n};\r\n```C++\r\nFileTransferClient::FileTransferClient(QObject* parent) : QObject{parent}, _socket(new QTcpSocket(this)) {}\r\n\r\nvoid FileTransferClient::sendFile(const QString& serverIp, quint16 serverPort, const QString& filePath) {\r\n    QFile file(filePath);\r\n    if (!file.open(QIODevice::ReadOnly)) {\r\n        qDebug() << 'Failed to open file';\r\n        return;\r\n    }\r\n    QByteArray fileContent = file.readAll();\r\n    TLVFile tlvFile(TLVFile::ID_FILE, QFileInfo(file).fileName(), fileContent);\r\n    // \u8fde\u63a5\u5230\u670d\u52a1\u5668\r\n    _socket->connectToHost(serverIp, serverPort);\r\n    connect(_socket, &QTcpSocket::connected, this, [=]() {\r\n        // \u8fde\u63a5\u6210\u529f\u8fdb\u884c\u53d1\u9001\r\n        _socket->write(tlvFile.toByteArray());\r\n        _socket->disconnectFromHost();\r\n    });\r\n}\r\n```\r\n## \u591a\u7ebf\u7a0b\u63a5\u6536\r\n\u5728\u670d\u52a1\u7aef\u4e2d\uff0c\u5bf9\u8fde\u63a5\u7684\u5904\u7406\u653e\u5230\u4e86FileReceiver\u4e2d\u8fdb\u884c\u5904\u7406\uff0c\u5b9e\u73b0\u5982\u4e0b\uff1a\r\n```C++\r\nclass FileReceiver : public QRunnable {\r\n  public:\r\n    FileReceiver(QTcpSocket* socket);\r\n    void run() override;\r\n\r\n  private:\r\n    QTcpSocket* _socket;\r\n};\r\n```\r\n```C++\r\nFileReceiver::FileReceiver(QTcpSocket* socket) : _socket(socket) {}\r\n\r\nvoid FileReceiver::run() {\r\n    qDebug() << 'FileReceiver thread started.';\r\n\r\n    while (_socket->waitForReadyRead()) {\r\n        QByteArray data = _socket->readAll();\r\n\r\n        // \u53cd\u5e8f\u5217\u5316 TLV \u6570\u636e\r\n        TLVFile tlvFile = TLVFile::fromByteArray(data);\r\n\r\n        if (tlvFile.getType() == TLVFile::ID_FILE) {\r\n            QString fileName = tlvFile.getFileName();\r\n            // \u9a8c\u8bc1\u5e76\u4fdd\u5b58\u6587\u4ef6\r\n            // \u8ba9\u7528\u6237\u9009\u62e9\u4fdd\u5b58\u8def\u5f84\r\n            QString savePath = QFileDialog::getSaveFileName(nullptr, 'Save File', fileName);\r\n            if (!savePath.isEmpty()) {\r\n                QFile file(savePath);\r\n                if (file.open(QIODevice::WriteOnly)) {\r\n                    file.write(tlvFile.getContent());\r\n                    file.close();\r\n                    qDebug() << 'File saved to' << savePath;\r\n                }\r\n            } else {\r\n                qWarning() << 'Didn't choose right save path';\r\n            }\r\n        }\r\n    }\r\n\r\n    _socket->close();\r\n    delete _socket;\r\n}\r\n```\r\n## \u754c\u9762\u64cd\u4f5c\r\n\u70b9\u51fb\u8bbe\u5907\u5217\u8868\u4e2d\u7684\u8bbe\u5907\u65f6\uff0c\u7f13\u5b58\u5176ip\u3001\u7aef\u53e3\uff0c_peer_data \u662f\u589e\u52a0\u7684QByteArray\u578b\u6210\u5458\u53d8\u91cf\r\n```C++\r\nvoid MainWindow::on_deviceListWidget_itemClicked(QListWidgetItem* item) {\r\n    // \u83b7\u53d6\u9009\u4e2d\u7684 item \u7684ip\u3001\u7aef\u53e3\r\n    _peer_data = item->data(Qt::UserRole).toByteArray();\r\n    if (_peer_data.isEmpty()) {\r\n        qWarning() << 'Selected ip port is null';\r\n    }\r\n}\r\n```\r\n\u70b9\u51fb\u4e0a\u4f20\u6587\u4ef6\u65f6\uff0c\u9009\u62e9\u6587\u4ef6\u8def\u5f84\r\n```C++\r\nvoid MainWindow::on_btn_add_file_clicked() {\r\n    QString fileName = QFileDialog::getOpenFileName(this, '\u9009\u62e9\u6587\u4ef6', '',\r\n                                                    '\u6240\u6709\u6587\u4ef6 (*.*);;\u6587\u672c\u6587\u4ef6 (*.txt);;\u56fe\u50cf\u6587\u4ef6 (*.png *.jpg*.bmp) ');\r\n    if (!fileName.isEmpty()) {\r\n        _selected_file_path = fileName;  // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\r\n        qDebug() << 'Selected file path is: ' << _selected_file_path;\r\n        ui->btn_send->setEnabled(true);\r\n    }\r\n}\r\n```\r\n\u70b9\u51fb\u53d1\u9001\u8fdb\u884c\u6587\u4ef6\u53d1\u9001\r\n```C++\r\nvoid MainWindow::on_btn_send_clicked() {\r\n    // \u53d1\u9001\u6587\u4ef6\r\n    if (!ui->deviceListWidget->currentItem()) {\r\n        QMessageBox::warning(this, '\u8b66\u544a', '\u672a\u9009\u62e9\u63a5\u6536\u8bbe\u5907\uff01');\r\n        return;\r\n    }\r\n    if (_selected_file_path.isEmpty()) {\r\n        QMessageBox::warning(this, '\u8b66\u544a', '\u672a\u9009\u62e9\u6587\u4ef6');\r\n        return;\r\n    }\r\n    QDataStream stream(&_peer_data, QIODevice::ReadOnly);\r\n    QString ip;\r\n    quint16 port;\r\n    stream >> ip >> port;\r\n    if (ip.isEmpty() || port == 0) {\r\n        qWarning() << 'Failed to parse peer ip, port';\r\n    }\r\n    _client->sendFile(ip, port, _selected_file_path);\r\n}\r\n```\u3002", "top": 0, "createdAt": 1727769903, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-10-01", "dateLabelColor": "#bc4c00"}, "P16": {"htmlDir": "docs/post/C++-bing-fa-bian-cheng.html", "labels": ["C++", "\u5e76\u53d1"], "postTitle": "C++\u5e76\u53d1\u7f16\u7a0b", "postUrl": "post/C%2B%2B-bing-fa-bian-cheng.html", "postSourceUrl": "https://github.com/proacane/proacane.github.io/issues/16", "commentNum": 0, "wordCount": 3909, "description": "\u8bb0\u5f55\u300aC++Concurrency In Action\u300b\u7684\u5b66\u4e60\u8fc7\u7a0b\r\n# \u5e76\u53d1\r\n\u5e76\u53d1\u7684\u4e24\u79cd\u65b9\u5f0f\uff1a\u771f\u6b63\u7684\u5e76\u884c\u4e0e\u4efb\u52a1\u5207\u6362\r\n![image](https://github.com/user-attachments/assets/11994029-b407-4a19-9374-de8ad04bc5de)\r\n## \u591a\u8fdb\u7a0b\u5e76\u53d1\r\n\u5c06\u5e94\u7528\u7a0b\u5e8f\u5206\u4e3a\u591a\u4e2a\u72ec\u7acb\u7684\u8fdb\u7a0b\u540c\u65f6\u8fd0\u884c\uff1b\u4e0d\u540c\u7684\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7\u4fe1\u53f7\u3001\u5957\u63a5\u5b57\u7b49\u6e20\u9053\u8fdb\u884c\u901a\u4fe1\uff0c\u4f46\u662f\u8fd9\u79cd\u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\u590d\u6742\uff0c\u4e14\u901f\u5ea6\u6162\u3002", "top": 0, "createdAt": 1728539751, "style": "", "script": "<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>", "head": "", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "createdDate": "2024-10-10", "dateLabelColor": "#bc4c00"}}, "singeListJson": {}, "labelColorDict": {"C++": "#89D2DF", "C\u8bed\u8a00": "#006b75", "QT": "#bfdadc", "question": "#d876e3", "\u5e76\u53d1": "#e99695", "\u64cd\u4f5c\u7cfb\u7edf": "#f9d0c4", "\u6570\u636e\u7ed3\u6784": "#fbca04", "\u7f51\u7edc\u7f16\u7a0b": "#158E9B"}, "displayTitle": "Proacane\u7684\u4e2a\u4eba\u5fae\u535a", "ogImage": "https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://proacane.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}