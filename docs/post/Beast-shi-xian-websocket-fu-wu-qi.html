<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 流对象

WebSocket连接需要一个有状态对象，由Beast中的一个类模板websocket::stream表示。">
<meta property="og:title" content="Beast实现websocket服务器">
<meta property="og:description" content="# 流对象

WebSocket连接需要一个有状态对象，由Beast中的一个类模板websocket::stream表示。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://proacane.github.io/post/Beast-shi-xian-websocket-fu-wu-qi.html">
<meta property="og:image" content="https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true">
<title>Beast实现websocket服务器</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Beast实现websocket服务器</h1>
<div class="title-right">
    <a href="https://proacane.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/proacane/proacane.github.io/issues/6" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>流对象</h1>
<p>WebSocket连接需要一个有状态对象，由Beast中的一个类模板websocket::stream表示。该接口使用分层流模型。一个websocket stream对象包含另一个流对象，称为“下一层”，它用于执行I/O操作。以下是每个模板参数的描述：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">namespace</span> <span class="pl-en">boost</span> {
<span class="pl-k">namespace</span> <span class="pl-en">beast</span> {
<span class="pl-k">namespace</span> <span class="pl-en">websocket</span> {
<span class="pl-k">template</span>&lt;
    <span class="pl-k">class</span> <span class="pl-en">NextLayer</span>,
    <span class="pl-k">bool</span> deflateSupported = <span class="pl-c1">true</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">stream</span>;
} <span class="pl-c"><span class="pl-c">//</span> websocket</span>
} <span class="pl-c"><span class="pl-c">//</span> beast</span>
} <span class="pl-c"><span class="pl-c">//</span> boost</span></pre></div>
<p><code class="notranslate">websocket</code>命名空间下包含一个模板类<code class="notranslate">stream</code>，用于表示WebSocket连接。</p>
<p><code class="notranslate">stream</code>类有两个模板参数：<code class="notranslate">NextLayer</code>和<code class="notranslate">deflateSupported</code>。其中，<code class="notranslate">NextLayer</code>表示WebSocket连接使用的下一层流类型，例如TCP套接字或TLS握手后的数据流；而<code class="notranslate">deflateSupported</code>则是一个bool值，表示是否支持WebSocket协议内置的压缩功能。</p>
<p><strong>创建一个基于 tcp/ip socket 和 io_context 的 websocket 流对象</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate">stream&lt;tcp_stream&gt; <span class="pl-en">ws</span>(ioc);</pre></div>
<p>stream是Beast库中WebSocket流类模板的别名，其下一层流类型为tcp_stream</p>
<p>websocket内置超时检测，使用 websocket 时需要禁用其他层的超时设置； websocket 的超时时间可以用流对象的 <code class="notranslate">set_option</code> 来设置</p>
<p><strong>创建线程安全的流对象</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate">stream&lt;tcp_stream&gt; <span class="pl-en">ws</span>(net::make_strand(ioc));</pre></div>
<p><strong>也可以通过右值来进行构造</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate">stream&lt;tcp_stream&gt; <span class="pl-en">ws</span>(std::move(sock));</pre></div>
<p>通过调用 next_layer 来访问下一层流对象</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">ws.next_layer().close();</pre></div>
<h1>使用 ssl</h1>
<p>使用<code class="notranslate">net::ssl::stream</code>类模板作为流的模板类型，并且将<code class="notranslate">net::io_context</code>和<code class="notranslate">net::ssl::context</code>参数传递给包装流的构造函数</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">stream&lt;ssl_stream&lt;tcp_stream&gt;&gt; <span class="pl-en">wss</span>(net::make_strand(ioc), ctx);</pre></div>
<p><code class="notranslate">get_lowest_layer</code> 可以获取最底层流</p>
<h1>连接</h1>
<p>首先连接 WebSocket 流，然后执行 WebSocket 握手。WebSocket 流将建立连接的任务委托给下一层流，下面是客户端的示例代码：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">stream&lt;tcp_stream&gt; <span class="pl-en">ws</span>(ioc);
net::ip::tcp::resolver <span class="pl-en">resolver</span>(ioc);
<span class="pl-en">get_lowest_layer</span>(ws).connect(resolver.resolve(<span class="pl-s"><span class="pl-pds">"</span>example.com<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>ws<span class="pl-pds">"</span></span>));</pre></div>
<p>对于服务器接收连接，在WebSocket服务器中使用一个acceptor来接受传入的连接。当建立了一个传入连接时，可以从acceptor返回的socket构造WebSocket流</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">net::ip::tcp::acceptor <span class="pl-en">acceptor</span>(ioc);
acceptor.bind(net::ip::tcp::endpoint(net::ip::tcp::v4(), <span class="pl-c1">0</span>));
acceptor.listen();
stream&lt;tcp_stream&gt; <span class="pl-en">ws</span>(acceptor.accept());</pre></div>
<p>也可以通过使用acceptor成员函数的另一个重载，将传入连接直接接受到WebSocket流拥有的socket中</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">stream&lt;tcp_stream&gt; <span class="pl-en">ws</span>(net::make_strand(ioc));
acceptor.accept(get_lowest_layer(ws).socket());</pre></div>
<h1>握手</h1>
<p>websocket通过握手将http升级为websocket协议，一个websocket协议如下</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">GET / HTTP/<span class="pl-c1">1.1</span>
Host: www.example.com
Upgrade: websocket
Connection: upgrade
Sec-WebSocket-Key: 2pGeTR0DsE4dfZs2pH+8MA==
Sec-WebSocket-Version: <span class="pl-c1">13</span>
User-Agent: Boost.Beast/<span class="pl-c1">216</span></pre></div>
<h2>客户端升级流程</h2>
<p>使用流对象的 <code class="notranslate">handshake</code> 函数（或async_handshake），用于使用所需的主机名和目标字符串发送请求。该代码连接到从主机名查找返回的IP地址，然后在客户端角色中执行WebSocket握手；</p>
<p>如果传入了 <code class="notranslate">response_type</code> 类型的参数，那么响应结果会存储在这个参数里</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">stream&lt;tcp_stream&gt; <span class="pl-en">ws</span>(ioc);
<span class="pl-c"><span class="pl-c">//</span> 接收到的消息类型，可选参数</span>
response_type res;
net::ip::tcp::resolver <span class="pl-en">resolver</span>(ioc);
<span class="pl-en">get_lowest_layer</span>(ws).connect(resolver.resolve(<span class="pl-s"><span class="pl-pds">"</span>www.example.com<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>ws<span class="pl-pds">"</span></span>));
ws.handshake(
    res,
    <span class="pl-s"><span class="pl-pds">"</span>www.example.com<span class="pl-pds">"</span></span>,  <span class="pl-c"><span class="pl-c">//</span> The Host field</span>
    <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>                 <span class="pl-c"><span class="pl-c">//</span> The request-target</span>
);</pre></div>
<h2>服务器升级流程</h2>
<p>对于接受传入连接的服务器，websocket::stream可以读取传入的升级请求并自动回复。如果握手符合要求，流将发送带有101切换协议状态码的升级响应。如果握手不符合要求，或者超出了调用者之前设置的流选项允许的参数范围，流将发送一个带有表示错误的状态码的HTTP响应。根据保持活动设置，连接可能保持打开状态，以进行后续握手尝试。在接收到升级请求握手后，由实现创建和发送的典型HTTP升级响应如下所示：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">HTTP/<span class="pl-c1">1.1</span> <span class="pl-c1">101</span> Switching Protocols
Upgrade: websocket
Connection: upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Server: Boost.Beast</pre></div>
<p>流对象的<code class="notranslate">accept</code>和<code class="notranslate">async_accept</code>用于从已连接到传入对等方的流中读取WebSocket HTTP升级请求握手，然后发送WebSocket HTTP升级响应</p>
<p><strong>实现支持 websocket 的http 服务器</strong></p>
<p>服务器检测传入的 http 请求是否为 websocket 请求即可，可以使用 is_upgrade；</p>
<p>一旦调用者确定HTTP请求是WebSocket升级请求，就会提供额外的accept和async_accept重载版本，这些版本接收整个HTTP请求头作为一个对象，以进行握手处理。通过手动读取请求，程序可以处理普通的HTTP请求以及升级请求。程序还可以根据HTTP字段强制执行策略，例如基本身份验证。在这个示例中，首先使用HTTP算法读取请求，然后将其传递给新构建的流：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">flat_buffer buffer;
http::request&lt;http::string_body&gt; req;
<span class="pl-en">http::read</span>(sock, buffer, req);
<span class="pl-k">if</span>(websocket::is_upgrade(req))
{
    stream&lt;tcp_stream&gt; <span class="pl-c1">ws</span>(<span class="pl-c1">std::move</span>(sock));
    <span class="pl-c1">BOOST_ASSERT</span>(buffer.<span class="pl-c1">size</span>() == <span class="pl-c1">0</span>);
    ws.<span class="pl-c1">accept</span>(req);
}
<span class="pl-k">else</span>
{
    <span class="pl-c"><span class="pl-c">//</span> 执行 http 处理</span>
}</pre></div>
<h1>收发数据</h1>
<p>同步读写，同时根据接收消息的类型设置 WebSocket 连接的模式</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">flat_buffer buffer;
ws.read(buffer);
ws.text(ws.got_text());
ws.write(buffer.data());
buffer.consume(buffer.size());</pre></div>
<p>如果遇到了不能通过 buffer 一次性读完的情况，例如：</p>
<ol>
<li>向终端流式传输多媒体：在流式传输多媒体到终端时，通常不适合或不可能预先缓冲整个消息。例如，在实时视频流或音频流的传输过程中，数据可能以非常大的速率产生，并且需要立即传输给接收端进行实时播放。由于数据量巨大且需即时传输，预先缓冲整个消息可能会导致延迟或资源耗尽。</li>
<li>发送超出内存容量的消息：有时候需要发送的消息太大，无法一次性完全存储在内存中。这可能发生在需要传输大型文件或大量数据的情况下。如果尝试将整个消息加载到内存中，可能会导致内存溢出或系统性能下降。在这种情况下，需要通过分块或逐步读取的方式来发送消息，以便逐步加载和传输数据。</li>
<li>提供增量结果：在某些情况下，需要在处理过程中提供增量的结果，而不是等待整个处理完成后再返回结果。这可以在长时间运行的计算、搜索或处理任务中发生。通过逐步提供部分结果，可以让用户或应用程序更早地获得一些数据，并可以在处理过程中进行进一步的操作或显示。这种方式可以改善用户体验，并减少等待时间。</li>
</ol>
<p>则需要采用逐步处理、流式传输或增量输出的方式</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span>存储读取的 WebSocket 数据</span>
multi_buffer buffer;
<span class="pl-c"><span class="pl-c">//</span> 连续调用 ws.read_some 方法从 WebSocket 连接中读取数据，并将其存储到 buffer 中，直到 WebSocket 消息全部接收完成</span>
<span class="pl-k">do</span>
{
    ws.<span class="pl-c1">read_some</span>(buffer, <span class="pl-c1">512</span>);
}
<span class="pl-k">while</span>(! ws.is_message_done());
<span class="pl-c"><span class="pl-c">//</span>将 WebSocket 连接设置为二进制模式，以便在后续的写入操作中正确处理二进制数据</span>
ws.binary(ws.got_binary());
<span class="pl-c"><span class="pl-c">//</span>创建了一个 cb 对象，它是 buffer 的后缀子序列。它提供了对 buffer 中已接收数据的访问</span>
buffers_suffix&lt;multi_buffer::const_buffers_type&gt; cb{buffer.<span class="pl-c1">data</span>()};
<span class="pl-k">for</span>(;;)
{
    <span class="pl-k">if</span>(<span class="pl-c1">buffer_bytes</span>(cb) &gt; <span class="pl-c1">512</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span>发送 cb 的前缀（前 512 字节）到 WebSocket 连接中，并保留剩余的数据</span>
        ws.<span class="pl-c1">write_some</span>(<span class="pl-c1">false</span>, <span class="pl-c1">buffers_prefix</span>(<span class="pl-c1">512</span>, cb));
        <span class="pl-c"><span class="pl-c">//</span>消耗了前 512 字节的数据</span>
        cb.<span class="pl-c1">consume</span>(<span class="pl-c1">512</span>);
    }
    <span class="pl-k">else</span>
    {	<span class="pl-c"><span class="pl-c">//</span>发送 cb 中的所有数据到 WebSocket 连接中</span>
        ws.<span class="pl-c1">write_some</span>(<span class="pl-c1">true</span>, cb);
        <span class="pl-k">break</span>;
    }
}
<span class="pl-c"><span class="pl-c">//</span>清空 buffer 中存储的数据</span>
buffer.consume(buffer.size());</pre></div>
<h1>关闭连接</h1>
<p>close 或 async_close</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-en">get_lowest_layer</span>(wss).close();</pre></div>
<h1>TCP升级websocket的demo</h1>
<p>WebSocketServer 类创建并接收连接；</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>ConnectionMgr.h<span class="pl-pds">"</span></span>

<span class="pl-k">class</span> <span class="pl-en">WebSocketServer</span> {
<span class="pl-k">public:</span>
    <span class="pl-en">WebSocketServer</span>(<span class="pl-k">const</span> WebSocketServer &amp;) = <span class="pl-k">delete</span>;

    WebSocketServer &amp;<span class="pl-k">operator</span>=(<span class="pl-k">const</span> WebSocketServer &amp;) = <span class="pl-k">delete</span>;

    <span class="pl-en">WebSocketServer</span>(net::io_context &amp;ioc, <span class="pl-k">unsigned</span> <span class="pl-k">short</span> port);

    <span class="pl-c"><span class="pl-c">//</span> tcp 层接收连接</span>
    <span class="pl-k">void</span> <span class="pl-en">startAccept</span>();

<span class="pl-k">private:</span>
    net::ip::tcp::acceptor _acceptor;
    net::io_context &amp;_ioc;
};</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>../include/WebSocketServer.h<span class="pl-pds">"</span></span>

<span class="pl-en">WebSocketServer::WebSocketServer</span>(net::io_context &amp;ioc, <span class="pl-k">unsigned</span> <span class="pl-k">short</span> port) : _ioc(ioc), _acceptor(ioc,
                                                                                                   <span class="pl-en">net::ip::tcp::endpoint</span>(
                                                                                                           <span class="pl-en">net::ip::tcp::v4</span>(),
                                                                                                           port)) {
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Server start on port: <span class="pl-pds">"</span></span> &lt;&lt; port &lt;&lt; std::endl;
}

<span class="pl-k">void</span> <span class="pl-en">WebSocketServer::startAccept</span>() {
    <span class="pl-k">auto</span> connection_ptr = std::make_shared&lt;Connection&gt;(_ioc);
    _acceptor.<span class="pl-c1">async_accept</span>(connection_ptr-&gt;<span class="pl-c1">getSocket</span>(), [<span class="pl-c1">this</span>, connection_ptr](error_code ec) {
        <span class="pl-k">try</span> {
            <span class="pl-k">if</span>(!ec){
                <span class="pl-c"><span class="pl-c">//</span> 升级成 websocket</span>
                connection_ptr-&gt;<span class="pl-c1">asyncAccept</span>();
            }<span class="pl-k">else</span>{
                std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>async_accept failed: <span class="pl-pds">"</span></span> &lt;&lt; ec.<span class="pl-c1">what</span>() &lt;&lt; std::endl;
            }

            <span class="pl-c1">this</span>-&gt;<span class="pl-c1">startAccept</span>();
        } <span class="pl-k">catch</span> (std::<span class="pl-c1">exception</span> &amp;e) {
            std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>async_accept error: <span class="pl-pds">"</span></span> &lt;&lt; e.<span class="pl-c1">what</span>() &lt;&lt; std::endl;
        }
    });
}</pre></div>
<p>Connection 为 websocket 连接类，其成员函数流对象使用智能指针管理，职能类似 socket；只不过是对 socket 又进行了封装；创建的 Connection 对象交给管理类统一管理；首次接收时进行异步读，读完后再写回客户端</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/beast.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/beast/ssl.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/asio.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/asio/ssl.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>memory<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/uuid/uuid.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/uuid/uuid_io.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/uuid/uuid_generators.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>queue<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>mutex<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">namespace</span> <span class="pl-en">net</span> <span class="pl-k">=</span> boost::asio;
<span class="pl-k">namespace</span> <span class="pl-en">beast</span> <span class="pl-k">=</span> boost::beast;
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">boost</span>::beast<span class="pl-k">;</span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">boost</span>::beast::websocket<span class="pl-k">;</span>

<span class="pl-k">class</span> <span class="pl-en">Connection</span> : <span class="pl-k">public</span> <span class="pl-en">std</span>::enable_shared_from_this&lt;Connection&gt; {
<span class="pl-k">public:</span>
    <span class="pl-k">explicit</span> <span class="pl-en">Connection</span>(net::io_context &amp;ioc);

    std::string <span class="pl-en">getUuid</span>() <span class="pl-k">const</span> {
        <span class="pl-k">return</span> _uuid;
    }

    <span class="pl-c"><span class="pl-c">//</span> 返回 tcp 层的 socket</span>
    net::ip::tcp::socket &amp;<span class="pl-en">getSocket</span>();

    <span class="pl-c"><span class="pl-c">//</span> websocket 层升级</span>
    <span class="pl-k">void</span> <span class="pl-en">asyncAccept</span>();

    <span class="pl-c"><span class="pl-c">//</span> 接收数据，进行处理</span>
    <span class="pl-k">void</span> <span class="pl-en">start</span>();

    <span class="pl-k">void</span> <span class="pl-en">asyncSend</span>(std::string msg);

<span class="pl-k">private:</span>
    <span class="pl-c"><span class="pl-c">//</span> websocket</span>
    std::unique_ptr&lt;stream&lt;tcp_stream &gt;&gt; _ws_ptr;
    <span class="pl-c"><span class="pl-c">//</span> 唯一 id</span>
    std::string _uuid;
    net::io_context &amp;_ioc;
    <span class="pl-c"><span class="pl-c">//</span> 存储</span>
    flat_buffer _rec_buffer;
    <span class="pl-c"><span class="pl-c">//</span> 发送队列</span>
    std::queue&lt;std::string&gt; _send_que;
    std::mutex _send_mutex;
};</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>../include/connection.h<span class="pl-pds">"</span></span>
#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">"</span>../include/ConnectionMgr.h<span class="pl-pds">"</span></span>

<span class="pl-en">Connection::Connection</span>(net::io_context &amp;ioc) : _ioc(ioc),
                                               _ws_ptr(std::make_unique&lt;stream&lt;tcp_stream&gt;&gt;(net::make_strand(ioc))) {
    <span class="pl-c"><span class="pl-c">//</span> 生成uuid</span>
    boost::uuids::random_generator generator;
    boost::uuids::uuid uuid = <span class="pl-c1">generator</span>();
    _uuid = <span class="pl-c1">boost::uuids::to_string</span>(uuid);
}

net::ip::tcp::socket &amp;<span class="pl-en">Connection::getSocket</span>() {
    <span class="pl-c"><span class="pl-c">//</span> 获取最底层 tcp 的 socket</span>
    <span class="pl-k">return</span> <span class="pl-c1">boost::beast::get_lowest_layer</span>(*_ws_ptr).<span class="pl-c1">socket</span>();
}

<span class="pl-k">void</span> <span class="pl-en">Connection::asyncAccept</span>() {
    <span class="pl-k">auto</span> self = <span class="pl-c1">shared_from_this</span>();
    <span class="pl-c"><span class="pl-c">//</span> tcp 升级成 websocket，捕获 self 增加引用计数，防止回调之前 Connection 被析构</span>
    _ws_ptr-&gt;<span class="pl-c1">async_accept</span>([self](error_code ec) {
        <span class="pl-k">try</span> {
            <span class="pl-k">if</span> (!ec) {
                <span class="pl-c"><span class="pl-c">//</span> 添加连接</span>
                <span class="pl-c1">ConnectionMgr::getInstance</span>().<span class="pl-c1">addConnection</span>(self);
                <span class="pl-c"><span class="pl-c">//</span> 进行数据处理</span>
                self-&gt;<span class="pl-c1">start</span>();
            } <span class="pl-k">else</span> {
                std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket accept failed, error is <span class="pl-pds">"</span></span> &lt;&lt; ec.<span class="pl-c1">what</span>() &lt;&lt; std::endl;
            }
        } <span class="pl-k">catch</span> (std::<span class="pl-c1">exception</span> &amp;e) {
            std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket asyncAccept error is <span class="pl-pds">"</span></span> &lt;&lt; e.<span class="pl-c1">what</span>() &lt;&lt; std::endl;
        }
    });
}

<span class="pl-k">void</span> <span class="pl-en">Connection::start</span>() {
    <span class="pl-k">auto</span> self = <span class="pl-c1">shared_from_this</span>();
    _ws_ptr-&gt;<span class="pl-c1">async_read</span>(_rec_buffer, [self](error_code ec,<span class="pl-c1">size_t</span> size) {
        <span class="pl-k">try</span> {
            <span class="pl-k">if</span> (!ec) {
                <span class="pl-c"><span class="pl-c">//</span> 设置类型</span>
                self-&gt;<span class="pl-smi">_ws_ptr</span>-&gt;<span class="pl-c1">text</span>(self-&gt;<span class="pl-smi">_ws_ptr</span>-&gt;<span class="pl-c1">got_text</span>());
                std::string rec_data = <span class="pl-c1">buffers_to_string</span>(self-&gt;<span class="pl-smi">_rec_buffer</span>.<span class="pl-c1">data</span>());
                <span class="pl-c"><span class="pl-c">//</span> 清空 buffer</span>
                self-&gt;<span class="pl-smi">_rec_buffer</span>.<span class="pl-c1">consume</span>(self-&gt;<span class="pl-smi">_rec_buffer</span>.<span class="pl-c1">size</span>());
                std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket receive length is '<span class="pl-pds">"</span></span> &lt;&lt; size &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>'<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
                std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket receive message is '<span class="pl-pds">"</span></span> &lt;&lt; rec_data &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>'<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
                <span class="pl-c"><span class="pl-c">//</span> 发送回去，减少拷贝使用 move</span>
                self-&gt;<span class="pl-c1">asyncSend</span>(<span class="pl-c1">std::move</span>(rec_data));
                <span class="pl-c"><span class="pl-c">//</span> 继续监听读</span>
                self-&gt;<span class="pl-c1">start</span>();
            } <span class="pl-k">else</span> {
                std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket read failed, error is <span class="pl-pds">"</span></span> &lt;&lt; ec.<span class="pl-c1">what</span>() &lt;&lt; std::endl;
                <span class="pl-c"><span class="pl-c">//</span> 移除连接</span>
                <span class="pl-c1">ConnectionMgr::getInstance</span>().<span class="pl-c1">removeConnection</span>(self-&gt;<span class="pl-c1">getUuid</span>());
                <span class="pl-k">return</span>;
            }
        } <span class="pl-k">catch</span> (std::<span class="pl-c1">exception</span> &amp;e) {
            std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket asyncRead error is <span class="pl-pds">"</span></span> &lt;&lt; e.<span class="pl-c1">what</span>() &lt;&lt; std::endl;
            <span class="pl-c"><span class="pl-c">//</span> 移除连接</span>
            <span class="pl-c1">ConnectionMgr::getInstance</span>().<span class="pl-c1">removeConnection</span>(self-&gt;<span class="pl-c1">getUuid</span>());
        }
    });
}

<span class="pl-k">void</span> <span class="pl-en">Connection::asyncSend</span>(std::string msg) {
    <span class="pl-c"><span class="pl-c">//</span> 运行完代码块释放锁</span>
    {
        std::lock_guard&lt;std::mutex&gt; <span class="pl-c1">lock</span>(_send_mutex);
        <span class="pl-k">short</span> send_size = _send_que.<span class="pl-c1">size</span>();
        <span class="pl-c"><span class="pl-c">//</span> 最大大小 1000</span>
        <span class="pl-k">if</span> (send_size == <span class="pl-c1">1000</span>) {
            std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Send queue is full<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
            <span class="pl-k">return</span>;
        }
        _send_que.<span class="pl-c1">push</span>(msg);
        <span class="pl-k">if</span> (send_size &gt; <span class="pl-c1">0</span>) {
            <span class="pl-c"><span class="pl-c">//</span> 之前数据没法送完</span>
            <span class="pl-k">return</span>;
        }
    }
    <span class="pl-c"><span class="pl-c">//</span> 开始发送</span>
    <span class="pl-k">auto</span> self = <span class="pl-c1">shared_from_this</span>();
    _ws_ptr-&gt;<span class="pl-c1">async_write</span>(<span class="pl-c1">boost::asio::buffer</span>(msg.<span class="pl-c1">c_str</span>(), msg.<span class="pl-c1">length</span>()),
                         [self](error_code ec, <span class="pl-c1">size_t</span> buffer_transferred) {
                             <span class="pl-k">try</span> {
                                 <span class="pl-k">if</span> (!ec) {
                                     std::string send_msg;
                                     <span class="pl-c"><span class="pl-c">//</span> 查看队列中还有没有数据</span>
                                     {
                                         std::lock_guard&lt;std::mutex&gt; <span class="pl-c1">lock</span>(self-&gt;<span class="pl-smi">_send_mutex</span>);
                                         self-&gt;<span class="pl-smi">_send_que</span>.<span class="pl-c1">pop</span>();
                                         <span class="pl-k">if</span> (self-&gt;<span class="pl-smi">_send_que</span>.<span class="pl-c1">empty</span>()) {
                                             <span class="pl-k">return</span>;
                                         }
                                         send_msg = self-&gt;<span class="pl-smi">_send_que</span>.<span class="pl-c1">front</span>();
                                     }
                                     self-&gt;<span class="pl-c1">asyncSend</span>(<span class="pl-c1">std::move</span>(send_msg));
                                 } <span class="pl-k">else</span> {
                                     std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket asyncWrite failed, error is <span class="pl-pds">"</span></span> &lt;&lt; ec.<span class="pl-c1">what</span>() &lt;&lt; std::endl;
                                     <span class="pl-c"><span class="pl-c">//</span> 移除连接</span>
                                     <span class="pl-c1">ConnectionMgr::getInstance</span>().<span class="pl-c1">removeConnection</span>(self-&gt;<span class="pl-c1">getUuid</span>());
                                 }
                             } <span class="pl-k">catch</span> (std::<span class="pl-c1">exception</span> &amp;e) {
                                 std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket asyncWrite error is <span class="pl-pds">"</span></span> &lt;&lt; e.<span class="pl-c1">what</span>() &lt;&lt; std::endl;
                                 <span class="pl-c"><span class="pl-c">//</span> 移除连接</span>
                                 <span class="pl-c1">ConnectionMgr::getInstance</span>().<span class="pl-c1">removeConnection</span>(self-&gt;<span class="pl-c1">getUuid</span>());
                             }
                         });

}</pre></div>
<h1>同时支持http和websocket的demo</h1>
<p>创建acceptor接收连接后，在处理类中读取请求，并通过websocket::is_upgrade函数来判断是不是websocket请求，如果是 websocket 请求，就创建 websocket 流对象并绑定socket，并进行监听和处理数据（长连接）</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/beast/core.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/beast/http.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/beast/version.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/beast.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>chrono<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>ctime<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>cstdlib<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>memory<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>string<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>json/json.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>json/value.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>json/reader.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/beast/websocket.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>queue<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>mutex<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>boost/asio/strand.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>ProgramState.h<span class="pl-pds">"</span></span>

<span class="pl-k">namespace</span> <span class="pl-en">beast</span> <span class="pl-k">=</span> boost::beast;
<span class="pl-k">namespace</span> <span class="pl-en">http</span> <span class="pl-k">=</span> boost::beast::http;
<span class="pl-k">namespace</span> <span class="pl-en">net</span> <span class="pl-k">=</span> boost::asio;
<span class="pl-k">using</span> tcp = boost::asio::ip::tcp;
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">boost</span>::beast<span class="pl-k">;</span>
<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">boost</span>::beast::websocket<span class="pl-k">;</span>


<span class="pl-k">class</span> <span class="pl-en">http_connection</span> : <span class="pl-k">public</span> <span class="pl-en">std</span>::enable_shared_from_this&lt;http_connection&gt; {
<span class="pl-k">public:</span>
    <span class="pl-k">explicit</span> <span class="pl-en">http_connection</span>(tcp::socket socket, boost::asio::io_context &amp;ioc);

    <span class="pl-k">void</span> <span class="pl-en">start</span>();

<span class="pl-k">private:</span>
    tcp::socket _socket;
    <span class="pl-c"><span class="pl-c">//</span> 临时存储读取数据的缓冲区</span>
    beast::flat_buffer _buffer{<span class="pl-c1">8192</span>};
    <span class="pl-c"><span class="pl-c">//</span> 存储从客户端读取的 HTTP 请求消息</span>
    http::request&lt;http::dynamic_body&gt; _request;
    http::response&lt;http::dynamic_body&gt; _response;

    <span class="pl-c"><span class="pl-c">//</span> 定时器，获取调度器，60 秒为超时时间</span>
    net::steady_timer _deadline{
            _socket.<span class="pl-c1">get_executor</span>(), <span class="pl-c1">std::chrono::seconds</span>(<span class="pl-c1">60</span>)
    };

    std::unique_ptr&lt;stream&lt;boost::beast::tcp_stream&gt;&gt; _ws_ptr;

    <span class="pl-k">void</span> <span class="pl-en">read_request</span>();

    <span class="pl-k">void</span> <span class="pl-en">check_deadline</span>();

    <span class="pl-k">void</span> <span class="pl-en">stop_deadline</span>();

    <span class="pl-k">void</span> <span class="pl-en">process_request</span>();

    <span class="pl-k">void</span> <span class="pl-en">create_response</span>();

    <span class="pl-k">void</span> <span class="pl-en">write_response</span>();

    <span class="pl-k">void</span> <span class="pl-en">create_post_response</span>();

    <span class="pl-k">void</span> <span class="pl-en">upgrade_websocket</span>(<span class="pl-k">const</span> tcp::socket &amp;&amp;socket, std::<span class="pl-c1">size_t</span> bytes_transferred);

    <span class="pl-k">void</span> <span class="pl-en">websocket_async_read</span>();

    <span class="pl-k">void</span> <span class="pl-en">websocket_async_write</span>(std::string msg);

    <span class="pl-k">void</span> <span class="pl-en">async_send_to_queue</span>(std::string msg);

    flat_buffer _websocket_buffer;
    std::queue&lt;std::string&gt; _send_que;
    std::mutex _mutex;
    boost::asio::strand&lt;boost::asio::io_context::executor_type&gt; _strand;
    boost::asio::io_context &amp;_ioc;

    <span class="pl-k">void</span> <span class="pl-en">convert_websocket</span>(tcp::socket &amp;&amp;);
};</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">http_connection::start</span>() {
    <span class="pl-c"><span class="pl-c">//</span> 读取请求</span>
    <span class="pl-c1">read_request</span>();
    <span class="pl-c"><span class="pl-c">//</span> 超时检测</span>
    <span class="pl-c1">check_deadline</span>();
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::read_request</span>() {
    <span class="pl-k">auto</span> self = <span class="pl-c1">shared_from_this</span>();
    <span class="pl-c1">http::async_read</span>(_socket, _buffer, _request, [self](beast::error_code ec, std::<span class="pl-c1">size_t</span> bytes_transferred) {

        <span class="pl-k">if</span> (ec) {
            std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>async_read error ! msg is : <span class="pl-pds">"</span></span> &lt;&lt; ec.<span class="pl-c1">message</span>() &lt;&lt; std::endl;
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">if</span> (<span class="pl-c1">websocket::is_upgrade</span>(self-&gt;<span class="pl-smi">_request</span>)) {
            <span class="pl-c"><span class="pl-c">//</span> 升级成 websocket</span>
            self-&gt;<span class="pl-c1">upgrade_websocket</span>(<span class="pl-c1">std::move</span>(self-&gt;<span class="pl-smi">_socket</span>), bytes_transferred);
        } <span class="pl-k">else</span> {
            <span class="pl-c"><span class="pl-c">//</span> http 处理</span>
            self-&gt;<span class="pl-c1">process_request</span>();
        }
    });
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::check_deadline</span>() {
    <span class="pl-k">auto</span> self = <span class="pl-c1">shared_from_this</span>();
    _deadline.<span class="pl-c1">async_wait</span>([self](boost::<span class="pl-c1">system</span>::error_code ec) {
        <span class="pl-k">if</span> (!ec) {
            <span class="pl-c"><span class="pl-c">//</span> 超时关闭</span>
            self-&gt;<span class="pl-smi">_socket</span>.<span class="pl-c1">close</span>(ec);
        }
    });
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::process_request</span>() {
    <span class="pl-c"><span class="pl-c">//</span> 设置响应头的版本</span>
    _response.<span class="pl-c1">version</span>(_request.<span class="pl-c1">version</span>());
    <span class="pl-c"><span class="pl-c">//</span> 短连接</span>
    _response.<span class="pl-c1">keep_alive</span>(<span class="pl-c1">false</span>);
    <span class="pl-k">switch</span> (_request.<span class="pl-c1">method</span>()) {
        <span class="pl-k">case</span> http::verb::get:
            _response.<span class="pl-c1">result</span>(http::status::ok);
            _response.<span class="pl-c1">set</span>(http::field::server, <span class="pl-s"><span class="pl-pds">"</span>Beast<span class="pl-pds">"</span></span>);
            <span class="pl-c"><span class="pl-c">//</span> 创建响应头</span>
            <span class="pl-c1">create_response</span>();
            <span class="pl-k">break</span>;
        <span class="pl-k">case</span> http::verb::post:
            _response.<span class="pl-c1">result</span>(http::status::ok);
            _response.<span class="pl-c1">set</span>(http::field::server, <span class="pl-s"><span class="pl-pds">"</span>Beast<span class="pl-pds">"</span></span>);
            <span class="pl-c1">create_post_response</span>();
            <span class="pl-k">break</span>;
        <span class="pl-k">default</span>:
            <span class="pl-c"><span class="pl-c">//</span> 错误请求</span>
            _response.<span class="pl-c1">result</span>(http::status::bad_request);
            _response.<span class="pl-c1">set</span>(http::field::content_type, <span class="pl-s"><span class="pl-pds">"</span>text/plain<span class="pl-pds">"</span></span>);
            <span class="pl-c1">beast::ostream</span>(_response.<span class="pl-c1">body</span>()) &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Invalid request-method '<span class="pl-pds">"</span></span> &lt;&lt; <span class="pl-c1">std::string</span>(_request.<span class="pl-c1">method_string</span>())
                                             &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>'<span class="pl-pds">"</span></span>;
            <span class="pl-k">break</span>;
    }

    <span class="pl-c"><span class="pl-c">//</span> 发送回去</span>
    <span class="pl-c1">write_response</span>();
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::create_response</span>() {
    <span class="pl-c"><span class="pl-c">//</span> 判断请求路由</span>
    <span class="pl-k">if</span> (_request.<span class="pl-c1">target</span>() == <span class="pl-s"><span class="pl-pds">"</span>/count<span class="pl-pds">"</span></span>) {
        _response.<span class="pl-c1">set</span>(http::field::content_type, <span class="pl-s"><span class="pl-pds">"</span>text/html<span class="pl-pds">"</span></span>);
        <span class="pl-c1">beast::ostream</span>(_response.<span class="pl-c1">body</span>()) &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;html&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;head&gt;&lt;title&gt;Request count&lt;/title&gt;&lt;/head&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;body&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;h1&gt;Request count&lt;/h1&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;p&gt;There have been <span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-c1">my_program_state::request_count</span>()
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> requests so far.&lt;/p&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;/body&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;/html&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;

    } <span class="pl-k">else</span> <span class="pl-k">if</span> (_request.<span class="pl-c1">target</span>() == <span class="pl-s"><span class="pl-pds">"</span>/time<span class="pl-pds">"</span></span>) {
        _response.<span class="pl-c1">set</span>(http::field::content_type, <span class="pl-s"><span class="pl-pds">"</span>text/html<span class="pl-pds">"</span></span>);
        <span class="pl-c1">beast::ostream</span>(_response.<span class="pl-c1">body</span>()) &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;html&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;head&gt;&lt;title&gt;Current time&lt;/title&gt;&lt;/head&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;body&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;h1&gt;Current time&lt;/h1&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;p&gt;The current time is <span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-c1">my_program_state::now</span>()
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> seconds since the epoch.&lt;/p&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;/body&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>
                                         &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>&lt;/html&gt;<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
    } <span class="pl-k">else</span> {
        _response.<span class="pl-c1">result</span>(http::status::not_found);
        _response.<span class="pl-c1">set</span>(http::field::content_type, <span class="pl-s"><span class="pl-pds">"</span>text/plain<span class="pl-pds">"</span></span>);
        <span class="pl-c1">beast::ostream</span>(_response.<span class="pl-c1">body</span>()) &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Page not found<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>;
    }
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::write_response</span>() {
    <span class="pl-k">auto</span> self = <span class="pl-c1">shared_from_this</span>();
    <span class="pl-c"><span class="pl-c">//</span> 设置响应体长度</span>
    _response.<span class="pl-c1">content_length</span>(_response.<span class="pl-c1">body</span>().<span class="pl-c1">size</span>());
    <span class="pl-c"><span class="pl-c">//</span> 发送</span>
    <span class="pl-c1">http::async_write</span>(_socket, _response, [self](beast::error_code ec, <span class="pl-c1">size_t</span> bytes_transferred) {
        <span class="pl-c"><span class="pl-c">//</span> 关闭发送端</span>
        self-&gt;<span class="pl-smi">_socket</span>.<span class="pl-c1">shutdown</span>(tcp::socket::shutdown_send, ec);
        <span class="pl-c"><span class="pl-c">//</span> 关闭定时器</span>
        self-&gt;<span class="pl-smi">_deadline</span>.<span class="pl-c1">cancel</span>();
    });
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::create_post_response</span>() {
    <span class="pl-k">if</span> (_request.<span class="pl-c1">target</span>() == <span class="pl-s"><span class="pl-pds">"</span>/email<span class="pl-pds">"</span></span>) {
        <span class="pl-k">auto</span> &amp;body = <span class="pl-c1">this</span>-&gt;<span class="pl-smi">_request</span>.<span class="pl-c1">body</span>();
        <span class="pl-k">auto</span> body_str = <span class="pl-c1">beast::buffers_to_string</span>(body.<span class="pl-c1">data</span>());
        std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Receive body is <span class="pl-pds">"</span></span> &lt;&lt; body_str &lt;&lt; std::endl;
        _response.<span class="pl-c1">set</span>(http::field::content_type, <span class="pl-s"><span class="pl-pds">"</span>text/json<span class="pl-pds">"</span></span>);
        Json::Value root;
        Json::Reader reader;
        Json::Value src_root;
        <span class="pl-k">bool</span> parse_res = reader.<span class="pl-c1">parse</span>(body_str, src_root);
        <span class="pl-k">if</span> (!parse_res) {
            std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Failed to parse json data<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
            root[<span class="pl-s"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span>] = <span class="pl-c1">1001</span>;
            std::string jsonstr = root.<span class="pl-c1">toStyledString</span>();
            <span class="pl-c1">beast::ostream</span>(_response.<span class="pl-c1">body</span>()) &lt;&lt; jsonstr;
            <span class="pl-k">return</span>;
        }

        <span class="pl-k">auto</span> email = src_root[<span class="pl-s"><span class="pl-pds">"</span>email<span class="pl-pds">"</span></span>].<span class="pl-c1">asString</span>();
        std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>email is <span class="pl-pds">"</span></span> &lt;&lt; email &lt;&lt; std::endl;
        root[<span class="pl-s"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span>] = <span class="pl-c1">0</span>;
        root[<span class="pl-s"><span class="pl-pds">"</span>email<span class="pl-pds">"</span></span>] = email;
        root[<span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span>] = <span class="pl-s"><span class="pl-pds">"</span>received email post success<span class="pl-pds">"</span></span>;
        std::string jsonstr = root.<span class="pl-c1">toStyledString</span>();
        <span class="pl-c1">beast::ostream</span>(_response.<span class="pl-c1">body</span>()) &lt;&lt; jsonstr;
    } <span class="pl-k">else</span> {
        _response.<span class="pl-c1">result</span>(http::status::not_found);
        _response.<span class="pl-c1">set</span>(http::field::content_type, <span class="pl-s"><span class="pl-pds">"</span>text/plain<span class="pl-pds">"</span></span>);
        <span class="pl-c1">beast::ostream</span>(_response.<span class="pl-c1">body</span>()) &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Page not found<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>;
    }
}

<span class="pl-en">http_connection::http_connection</span>(tcp::socket socket, boost::asio::io_context &amp;ioc) : _socket(std::move(socket)),
                                                                                     _ws_ptr(<span class="pl-c1">nullptr</span>), _ioc(ioc),
                                                                                     _strand(ioc.get_executor()) {
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::stop_deadline</span>() {
    _deadline.<span class="pl-c1">cancel</span>();
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::upgrade_websocket</span>(<span class="pl-k">const</span> tcp::socket &amp;&amp;socket, std::<span class="pl-c1">size_t</span> bytes_transferred) {
    <span class="pl-k">auto</span> self = <span class="pl-c1">shared_from_this</span>();
    <span class="pl-c"><span class="pl-c">//</span> 使用 websocket 必须关闭其他的定时器</span>
    <span class="pl-c1">stop_deadline</span>();
    <span class="pl-c1">convert_websocket</span>(<span class="pl-c1">std::move</span>(_socket));
    <span class="pl-c1">BOOST_ASSERT</span>(_websocket_buffer.<span class="pl-c1">size</span>() == <span class="pl-c1">0</span>);

    self-&gt;<span class="pl-smi">_ws_ptr</span>-&gt;<span class="pl-c1">async_accept</span>(self-&gt;<span class="pl-smi">_request</span>,[self](boost::<span class="pl-c1">system</span>::error_code ec){
        <span class="pl-k">if</span>(!ec){
            std::cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Websocket async_accept succeed<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
            self-&gt;<span class="pl-c1">websocket_async_read</span>();
        }<span class="pl-k">else</span>{
            std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Websocket has error: <span class="pl-pds">"</span></span>&lt;&lt;ec.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
            <span class="pl-c1">get_lowest_layer</span>(*(self-&gt;<span class="pl-smi">_ws_ptr</span>)).<span class="pl-c1">close</span>();
        }
    });

}

<span class="pl-k">void</span> <span class="pl-en">http_connection::convert_websocket</span>(tcp::socket &amp;&amp;socket) {
    _ws_ptr.<span class="pl-c1">reset</span>(<span class="pl-k">new</span> stream&lt;tcp_stream&gt;(<span class="pl-c1">std::move</span>(socket)));
<span class="pl-c"><span class="pl-c">//</span>    _wsptr(std::make_unique&lt;stream&lt;tcp_stream&gt;&gt;(net::make_strand(_ioc)));</span>
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::websocket_async_read</span>() {
    <span class="pl-k">auto</span> self = <span class="pl-c1">shared_from_this</span>();

    self-&gt;<span class="pl-smi">_ws_ptr</span>-&gt;<span class="pl-c1">async_read</span>(self-&gt;<span class="pl-smi">_websocket_buffer</span>,[self](boost::<span class="pl-c1">system</span>::error_code ec, std::<span class="pl-c1">size_t</span> bytes_transferred){
        <span class="pl-k">try</span> {
            <span class="pl-k">if</span>(!ec){
                std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket async_read succeed<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
                self-&gt;<span class="pl-smi">_ws_ptr</span>-&gt;<span class="pl-c1">text</span>(self-&gt;<span class="pl-smi">_ws_ptr</span>-&gt;<span class="pl-c1">got_text</span>());
                std::string rec_data = <span class="pl-c1">buffers_to_string</span>(self-&gt;<span class="pl-smi">_websocket_buffer</span>.<span class="pl-c1">data</span>());
                self-&gt;<span class="pl-smi">_websocket_buffer</span>.<span class="pl-c1">consume</span>(self-&gt;<span class="pl-smi">_websocket_buffer</span>.<span class="pl-c1">size</span>()) ;
                std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>websocket receive data is <span class="pl-pds">"</span></span> &lt;&lt; rec_data &lt;&lt; std::endl;
                self-&gt;<span class="pl-c1">async_send_to_queue</span>(rec_data);
                self-&gt;<span class="pl-c1">websocket_async_read</span>();
            }<span class="pl-k">else</span>{
                std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>async_read failed, error is: <span class="pl-pds">"</span></span>&lt;&lt;ec.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
                <span class="pl-c1">get_lowest_layer</span>(*(self-&gt;<span class="pl-smi">_ws_ptr</span>)).<span class="pl-c1">close</span>();
            }
        } <span class="pl-k">catch</span> (std::<span class="pl-c1">exception</span>&amp;e) {
            std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception in async_read, error is: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
            <span class="pl-c1">get_lowest_layer</span>(*(self-&gt;<span class="pl-smi">_ws_ptr</span>)).<span class="pl-c1">close</span>();
        }
    });
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::websocket_async_write</span>(std::string msg) {
    <span class="pl-k">auto</span> self = <span class="pl-c1">shared_from_this</span>();
    self-&gt;<span class="pl-smi">_ws_ptr</span>-&gt;<span class="pl-c1">async_write</span>(<span class="pl-c1">boost::asio::buffer</span>(msg.<span class="pl-c1">c_str</span>(),msg.<span class="pl-c1">size</span>()), <span class="pl-c1">boost::asio::bind_executor</span>(_strand,[self](boost::<span class="pl-c1">system</span>::error_code ec,<span class="pl-c1">size_t</span> bytes_transferred){
            <span class="pl-k">try</span> {
                <span class="pl-k">if</span>(!ec){
                    std::cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>async_write succeed<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
                    std::string send_msg;
                    {
                        std::lock_guard&lt;std::mutex&gt; <span class="pl-c1">lock</span>(self-&gt;<span class="pl-smi">_mutex</span>);
                        self-&gt;<span class="pl-smi">_send_que</span>.<span class="pl-c1">pop</span>();
                        <span class="pl-k">if</span>(self-&gt;<span class="pl-smi">_send_que</span>.<span class="pl-c1">empty</span>()){
                            std::cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>send queue is empty<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
                            <span class="pl-k">return</span>;
                        }
                        send_msg = self-&gt;<span class="pl-smi">_send_que</span>.<span class="pl-c1">front</span>();
                    }
                    self-&gt;<span class="pl-c1">async_send_to_queue</span>(send_msg);
                }<span class="pl-k">else</span>{
                    std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>async_write failed, error is: <span class="pl-pds">"</span></span>&lt;&lt;ec.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
                    <span class="pl-c1">get_lowest_layer</span>(*(self-&gt;<span class="pl-smi">_ws_ptr</span>)).<span class="pl-c1">close</span>();
                }
            } <span class="pl-k">catch</span> (std::<span class="pl-c1">exception</span> &amp;ec) {
                std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception in async_write, error is: <span class="pl-pds">"</span></span>&lt;&lt;ec.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
                <span class="pl-c1">get_lowest_layer</span>(*(self-&gt;<span class="pl-smi">_ws_ptr</span>)).<span class="pl-c1">close</span>();
            }
    }));
}

<span class="pl-k">void</span> <span class="pl-en">http_connection::async_send_to_queue</span>(std::string msg) {
    std::<span class="pl-c1">size_t</span> que_size = <span class="pl-c1">0</span>;
    {
        std::lock_guard&lt;std::mutex&gt; <span class="pl-c1">lock</span>(_mutex);
        que_size = _send_que.<span class="pl-c1">size</span>();
        <span class="pl-k">if</span> (que_size == <span class="pl-c1">1000</span>) {
            <span class="pl-k">return</span>;
        }
        _send_que.<span class="pl-c1">push</span>(msg);
        std::cout&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Put msg into send queue succeed<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>;
    }
    <span class="pl-k">if</span>(que_size &gt;<span class="pl-c1">0</span>){
        <span class="pl-k">return</span>;
    }
    <span class="pl-c1">websocket_async_write</span>(msg);
}
</pre></div>
<p>代码地址:<a href="https://github.com/proacane/boost-asio-learn">proacane/boost-asio-learn (github.com)</a></p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://proacane.github.io">Proacane的个人微博</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","proacane/proacane.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>

</html>
