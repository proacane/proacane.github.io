<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Proacane的个人微博</title><link>https://proacane.github.io</link><description>学无止境</description><copyright>Proacane的个人微博</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true</url><title>avatar</title><link>https://proacane.github.io</link></image><lastBuildDate>Tue, 01 Oct 2024 08:05:31 +0000</lastBuildDate><managingEditor>Proacane的个人微博</managingEditor><ttl>60</ttl><webMaster>Proacane的个人微博</webMaster><item><title>QT实现局域网文件传输软件</title><link>https://proacane.github.io/post/QT-shi-xian-ju-yu-wang-wen-jian-chuan-shu-ruan-jian.html</link><description># 总体架构&#13;
软件通过 UDP 组播查询局域网内的设备，每个设备可以选择指定用户进行发送文件；接收文件时可以指定保存路径；系统支持多线程&#13;
&#13;
# 实现思路&#13;
## 准备工作&#13;
手动实现 clickedLabel，在点击时可以切换到 stackedWidget 的不同页&#13;
![image](https://github.com/user-attachments/assets/bb3513d2-d74e-4f81-ab95-16bec9c14182)&#13;
```C++&#13;
enum ClickedLabelState {&#13;
    Normal = 1,&#13;
    // Hover = 2,&#13;
    Selected = 3&#13;
};&#13;
&#13;
class ClickedLabel : public QLabel {&#13;
    Q_OBJECT&#13;
  public:&#13;
    explicit ClickedLabel(QWidget* parent = nullptr);&#13;
    void setInfo(const QString&amp; normalPath, const QString&amp; selectedPath, const QString&amp; text);&#13;
    ClickedLabelState getCurState() const;&#13;
    void setSelected(bool selected);&#13;
&#13;
  private:&#13;
    ClickedLabelState _curstate;&#13;
    void setImage(const QString&amp; path);&#13;
    // 两种状态的图片路径&#13;
    QString _normal_path;&#13;
    QString _selected_path;&#13;
    QString _text;&#13;
  signals:&#13;
    void clicked();&#13;
&#13;
  protected:&#13;
    // 鼠标点击&#13;
    virtual void mousePressEvent(QMouseEvent* event) override;&#13;
    // 鼠标松开&#13;
    virtual void mouseReleaseEvent(QMouseEvent* event) override;&#13;
    // 鼠标悬浮&#13;
    virtual void enterEvent(QEnterEvent* event) override;&#13;
    // 鼠标移走&#13;
    virtual void leaveEvent(QEvent* event) override;&#13;
};&#13;
```&#13;
```C++&#13;
ClickedLabel::ClickedLabel(QWidget* parent) : QLabel(parent), _curstate(ClickedLabelState::Normal) {&#13;
&#13;
}&#13;
&#13;
void ClickedLabel::setInfo(const QString&amp; normalPath, const QString&amp; selectedPath, const QString&amp; text) {&#13;
    _normal_path = normalPath;&#13;
    _selected_path = selectedPath;&#13;
    _text = text;&#13;
}&#13;
&#13;
ClickedLabelState ClickedLabel::getCurState() const {&#13;
    return _curstate;&#13;
}&#13;
&#13;
&#13;
void ClickedLabel::setSelected(bool selected) {&#13;
    if (selected) {&#13;
        _curstate = ClickedLabelState::Selected;&#13;
        setImage(_selected_path);&#13;
    } else {&#13;
        _curstate = ClickedLabelState::Normal;&#13;
        setImage(_normal_path);&#13;
    }&#13;
}&#13;
&#13;
void ClickedLabel::setImage(const QString&amp; path) {&#13;
    int imageWidth = 20;   // 图像宽度&#13;
    int imageHeight = 20;  // 图像高度&#13;
&#13;
    // 使用 HTML 标签设置图像和文字&#13;
    QString labelText =&#13;
        QString('&lt;img src='%1' width='%2' height='%3'&gt; %4').arg(path).arg(imageWidth).arg(imageHeight).arg(_text);&#13;
    setText(labelText);&#13;
}&#13;
&#13;
void ClickedLabel::mousePressEvent(QMouseEvent* event) {&#13;
    if (event-&gt;button() == Qt::LeftButton) {&#13;
        // 按下左键，切换状态&#13;
        if (_curstate == ClickedLabelState::Normal) {&#13;
            // qInfo() &lt;&lt; 'Mouse press event, set state selected';&#13;
            _curstate = ClickedLabelState::Selected;&#13;
        }else{&#13;
            qInfo()&lt;&lt;'This label is already selected';&#13;
        }&#13;
        return;&#13;
    }&#13;
    QLabel::mousePressEvent(event);&#13;
}&#13;
&#13;
void ClickedLabel::mouseReleaseEvent(QMouseEvent* event) {&#13;
    if (event-&gt;button() == Qt::LeftButton) {&#13;
        if (_curstate == ClickedLabelState::Selected) {&#13;
            setImage(_selected_path);&#13;
            emit clicked();&#13;
        }else{&#13;
            qInfo()&lt;&lt;'This label is already selected';&#13;
        }&#13;
        return;&#13;
    }&#13;
    // 调用基类的mousePressEvent以保证正常的事件处理&#13;
    QLabel::mousePressEvent(event);&#13;
}&#13;
&#13;
void ClickedLabel::enterEvent(QEnterEvent* event) {&#13;
    setCursor(Qt::PointingHandCursor);&#13;
    QLabel::enterEvent(event);&#13;
}&#13;
&#13;
void ClickedLabel::leaveEvent(QEvent* event) {&#13;
    setCursor(Qt::ArrowCursor);&#13;
    QLabel::leaveEvent(event);&#13;
}&#13;
```&#13;
## 设备信息&#13;
创建 DeviceInfo 头文件，存储设备的一些信息，为了发送与接收的时候方便解析，添加转换函数&#13;
```C++&#13;
struct DeviceInfo {&#13;
    QString deviceName;&#13;
    QString ip;&#13;
    // tcp 监听的端口&#13;
    QString port;]&#13;
    // 是否已经退出&#13;
    bool isQuit = false;&#13;
    // 重载运算符用于序列化&#13;
    friend QDataStream&amp; operator&lt;&lt;(QDataStream&amp; out, const DeviceInfo&amp; device) {&#13;
        out &lt;&lt; device.deviceName &lt;&lt; device.ip &lt;&lt; device.port &lt;&lt; device.isQuit;&#13;
        return out;&#13;
    }&#13;
&#13;
    // 重载运算符用于反序列化&#13;
    friend QDataStream&amp; operator&gt;&gt;(QDataStream&amp; in, DeviceInfo&amp; device) {&#13;
        in &gt;&gt; device.deviceName &gt;&gt; device.ip &gt;&gt; device.port &gt;&gt; device.isQuit;&#13;
        return in;&#13;
    }&#13;
};&#13;
&#13;
// 将结构体转换为QByteArray&#13;
static QByteArray deviceInfoToByteArray(const DeviceInfo&amp; device) {&#13;
    QByteArray byteArray;&#13;
    QDataStream out(&amp;byteArray, QIODevice::WriteOnly);&#13;
    out.setVersion(QDataStream::Qt_6_5);  // 设置版本，确保兼容性&#13;
    out &lt;&lt; device;                        // 使用重载的&lt;&lt;运算符&#13;
    return byteArray;&#13;
}&#13;
&#13;
// 从QByteArray恢复结构体&#13;
static DeviceInfo byteArrayToDeviceInfo(const QByteArray&amp; byteArray) {&#13;
    DeviceInfo device;&#13;
    QDataStream in(byteArray);&#13;
    in.setVersion(QDataStream::Qt_6_5);  // 设置版本，确保兼容性&#13;
    in &gt;&gt; device;                        // 使用重载的&gt;&gt;运算符&#13;
    return device;&#13;
}&#13;
```&#13;
## 组播功能&#13;
创建 DiscoveryService 单例类，进行组播，采用定时器定时组播，查询到的设备存放到 QMap 中进行管理&#13;
### 成员变量&#13;
```C++&#13;
class DiscoveryService : public QObject {&#13;
    Q_OBJECT&#13;
  public:&#13;
    static DiscoveryService* getInstance();&#13;
    // 开启组播服务&#13;
    void startDiscovery();&#13;
    DiscoveryService&amp; operator=(const DiscoveryService&amp;) = delete;&#13;
    DiscoveryService(const DiscoveryService&amp;) = delete;&#13;
    void setDeivceName(const QString&amp; name);&#13;
    ~DiscoveryService();&#13;
    void stopDiscovery();&#13;
  signals:&#13;
    // 发现了新设备&#13;
    void deviceDiscovered(const DeviceInfo&amp; receiveDevice);&#13;
    // 更新设备名称&#13;
    void deviceNameChanged(const DeviceInfo&amp; receiveDevice);&#13;
    void deviceRemoved(const DeviceInfo&amp; removeDevice);&#13;
&#13;
  private:&#13;
    explicit DiscoveryService(QObject* parent = nullptr);&#13;
    // 组播频率&#13;
    const int DISCOVERY_INTERVAL_MS = 500;&#13;
    // 组播的端口号&#13;
    const quint16 multicastPort;&#13;
    // 组播地址&#13;
    const QHostAddress multicastAddress;&#13;
    QUdpSocket* _udp_socket;&#13;
    QTimer* _discovery_timer;&#13;
    // 存放本机设备信息&#13;
    DeviceInfo _device;&#13;
    // 组播查询到的设备列表&#13;
    QMap&lt;QString, DeviceInfo&gt; _devices;&#13;
    // 获取本机IP地址&#13;
    const QString getLocalAddress();&#13;
&#13;
  private slots:&#13;
    void processPendingDatagrams();&#13;
};&#13;
```&#13;
### 构造函数&#13;
初始化UDPSocket、绑定组播端口、地址、设备的ip，绑定信号和槽函数&#13;
```C++&#13;
DiscoveryService::DiscoveryService(QObject* parent) :&#13;
    QObject{parent}, multicastPort(45454), multicastAddress(QHostAddress('239.255.255.250')) {&#13;
    _udp_socket = new QUdpSocket(this);&#13;
    _discovery_timer = new QTimer(this);&#13;
    _device.ip = getLocalAddress();&#13;
    // 绑定本地端口&#13;
    _udp_socket-&gt;bind(QHostAddress::AnyIPv4, multicastPort);&#13;
    // 加入组播组&#13;
    _udp_socket-&gt;joinMulticastGroup(multicastAddress);&#13;
    // 开始接受数据包&#13;
    connect(_udp_socket, &amp;QUdpSocket::readyRead, this, &amp;DiscoveryService::processPendingDatagrams);&#13;
}&#13;
const QString DiscoveryService::getLocalAddress() {&#13;
    QStringList ipAddressesList;  // 创建一个字符串列表来存储本机的所有 IP 地址&#13;
    // 获取所有网络接口的 IP 地址列表&#13;
    const QList&lt;QHostAddress&gt;&amp; allAddresses = QNetworkInterface::allAddresses();&#13;
    // 遍历所有 IP 地址，筛选出有效的 IPv4 地址（忽略回环地址和本地链路地址）&#13;
    for (const QHostAddress&amp; address : allAddresses) {&#13;
        if (address.protocol() == QAbstractSocket::IPv4Protocol &amp;&amp;  // 只选择 IPv4 地址&#13;
            !address.isLoopback()) {                                // 忽略回环地址（如 127.0.0.1）&#13;
            ipAddressesList.append(address.toString());             // 将符合条件的地址添加到列表中&#13;
        }&#13;
    }&#13;
    // 如果找到至少一个有效的本机 IP 地址，返回第一个&#13;
    if (!ipAddressesList.isEmpty()) {&#13;
        qDebug() &lt;&lt; 'Local address is ' &lt;&lt; ipAddressesList.first();&#13;
        return ipAddressesList.first();  // 返回第一个符合条件的本机 IP 地址&#13;
    } else {&#13;
        qWarning() &lt;&lt; 'Fail to find local address';&#13;
        return '0.0.0.0';  // 如果没有找到有效地址，返回 '0.0.0.0'&#13;
    }&#13;
}&#13;
```&#13;
### 发送与处理组播消息的槽函数&#13;
发送：将本机的信息进行组播，使用定时器定时发送&#13;
```C++&#13;
void DiscoveryService::startDiscovery() {&#13;
    connect(_discovery_timer, &amp;QTimer::timeout, this, [this]() {&#13;
        // 发送组播请求&#13;
        // TODO 本机分配给tcp的端口获取&#13;
        QByteArray datagram = deviceInfoToByteArray(_device);  // 组播请求内容&#13;
        // qDebug() &lt;&lt; 'Sending datagram:' &lt;&lt; datagram.toHex();   // 打印数据包内容&#13;
        _udp_socket-&gt;writeDatagram(datagram, multicastAddress, multicastPort);&#13;
    });&#13;
    _discovery_timer-&gt;start(DISCOVERY_INTERVAL_MS);&#13;
}&#13;
```&#13;
接收：解析收到的设备信息&#13;
1. 本机设备就直接return&#13;
2. isQuit为true就移除该设备&#13;
3. 已经存在于设备列表中并且设备名字也没更改也直接跳过&#13;
4. 已经存在于设备列表中但是设备名字更改了就发送deviceNameChanged信号通知ui更新&#13;
5. 不存在于设备列表中就发送deviceDiscovered信号通知ui更新&#13;
```C++&#13;
void DiscoveryService::processPendingDatagrams() {&#13;
    while (_udp_socket-&gt;hasPendingDatagrams()) {&#13;
        QByteArray datagram;&#13;
        // 接收到的设备信息&#13;
        QHostAddress sender;&#13;
        quint16 senderPort;&#13;
        // 接收数据包&#13;
        datagram.resize(_udp_socket-&gt;pendingDatagramSize());&#13;
        _udp_socket-&gt;readDatagram(datagram.data(), datagram.size(), &amp;sender, &amp;senderPort);&#13;
&#13;
        DeviceInfo receiveDevice = byteArrayToDeviceInfo(datagram);&#13;
        // 处理接收到的数据包&#13;
        QString ip = receiveDevice.ip;&#13;
        QString port = receiveDevice.port;&#13;
        QString name = receiveDevice.deviceName;&#13;
        bool quit = receiveDevice.isQuit;&#13;
        // 发现的是本机&#13;
        if (name == _device.deviceName &amp;&amp; ip == _device.ip) {&#13;
            return;&#13;
        }&#13;
        if (quit) {&#13;
            qDebug() &lt;&lt; 'Device removed: ' &lt;&lt; name;&#13;
            // 退出了&#13;
            _devices.remove(ip);&#13;
            emit deviceRemoved(receiveDevice);&#13;
            return;&#13;
        }&#13;
        // 第一次组播到该设备&#13;
        if (!_devices.contains(ip)) {&#13;
            // 更新设备列表&#13;
            _devices[ip] = receiveDevice;&#13;
            qDebug() &lt;&lt; 'New device discovered:' &lt;&lt; ip &lt;&lt; ', Tcp port:' &lt;&lt; port &lt;&lt; ', name: ' &lt;&lt; name;&#13;
            // 发现新设备&#13;
            emit deviceDiscovered(receiveDevice);&#13;
        } else {&#13;
            // 已经加到列表里了&#13;
            QString exist_name = _devices[ip].deviceName;&#13;
            if (exist_name == name) {&#13;
                // 如果名字一样就不更新&#13;
                return;&#13;
            } else {&#13;
                _devices[ip] = receiveDevice;&#13;
                // 更新名字&#13;
                emit deviceNameChanged(receiveDevice);&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
停止组播与析构：先将定时器关闭，将isQuit设置为true再进行一次组播，其它设备接受到后就会在上面的函数中执行从设备列表中移除该设备的逻辑&#13;
```C++&#13;
DiscoveryService::~DiscoveryService() {&#13;
    _udp_socket-&gt;leaveMulticastGroup(multicastAddress);&#13;
    _udp_socket-&gt;abort();&#13;
    qDebug() &lt;&lt; 'Exit multicast';&#13;
}&#13;
&#13;
void DiscoveryService::stopDiscovery() {&#13;
    _discovery_timer-&gt;stop();&#13;
    //  移除该设备&#13;
    _device.isQuit = true;&#13;
    QByteArray datagram = deviceInfoToByteArray(_device);  // 组播请求内容&#13;
    // qDebug() &lt;&lt; 'Sending datagram:' &lt;&lt; datagram.toHex();   // 打印数据包内容&#13;
    _udp_socket-&gt;writeDatagram(datagram, multicastAddress, multicastPort);&#13;
}&#13;
```&#13;
### MainWindow中对上面的各个信号的处理、初始化：&#13;
构造函数中，初始化各个图标，设置本机的设备名，开始进行组播，并连接信号与槽&#13;
```C++&#13;
MainWindow::MainWindow(QWidget* parent) : QMainWindow(parent), ui(new Ui::MainWindow) {&#13;
    ui-&gt;setupUi(this);&#13;
&#13;
    // .... 设置ui 的操作.....略&#13;
    // 获取本机设备名&#13;
    ui-&gt;edit_device_name-&gt;setText(QHostInfo::localHostName());&#13;
    DiscoveryService::getInstance()-&gt;setDeivceName(ui-&gt;edit_device_name-&gt;text());&#13;
    DiscoveryService::getInstance()-&gt;startDiscovery();&#13;
    // 发现新设备&#13;
    connect(DiscoveryService::getInstance(), &amp;DiscoveryService::deviceDiscovered, this, &amp;MainWindow::updateDeviceList);&#13;
    // 更新设备列表的名字&#13;
    connect(DiscoveryService::getInstance(), &amp;DiscoveryService::deviceNameChanged, this, &amp;MainWindow::updateDeviceName);&#13;
    // 移除设备&#13;
    connect(DiscoveryService::getInstance(), &amp;DiscoveryService::deviceRemoved, this, &amp;MainWindow::removeDevice);&#13;
}&#13;
```&#13;
发现了新设备的槽函数：将设备名称用于显示，ip等信息保存到data中即可&#13;
```C++&#13;
void MainWindow::updateDeviceList(const DeviceInfo&amp; receiveDevice) {&#13;
    QListWidgetItem* item = new QListWidgetItem(receiveDevice.deviceName);&#13;
    QByteArray data;&#13;
    QDataStream stream(&amp;data, QIODevice::WriteOnly);&#13;
    stream &lt;&lt; receiveDevice.ip &lt;&lt; receiveDevice.port;&#13;
    // 存储ip 和端口&#13;
    item-&gt;setData(Qt::UserRole, data);&#13;
    ui-&gt;deviceListWidget-&gt;addItem(item);&#13;
}&#13;
```&#13;
更新设备名称的槽函数：找到ip一样的，进行更新界面即可&#13;
```C++&#13;
void MainWindow::updateDeviceName(const DeviceInfo&amp; receiveDevice) {&#13;
    for (int i = ui-&gt;deviceListWidget-&gt;count() - 1; i &gt;= 0; i--) {&#13;
        QListWidgetItem* item = ui-&gt;deviceListWidget-&gt;item(i);&#13;
        QByteArray data = item-&gt;data(Qt::UserRole).toByteArray();&#13;
        QDataStream stream(&amp;data, QIODevice::ReadOnly);&#13;
        QString ip;&#13;
        // 读取 ip&#13;
        stream &gt;&gt; ip;&#13;
        if (ip == receiveDevice.ip) {&#13;
            qDebug() &lt;&lt; 'Found devices that name changed ip: ' &lt;&lt; ip;&#13;
            // 更新设备名称&#13;
            qDebug() &lt;&lt; 'Updating device name to: ' &lt;&lt; receiveDevice.deviceName;&#13;
            item-&gt;setText(receiveDevice.deviceName);&#13;
            ui-&gt;deviceListWidget-&gt;update();&#13;
            return;&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
移除设备的槽函数：找到设备名称一样的item进行移除即可&#13;
```C++&#13;
void MainWindow::removeDevice(const DeviceInfo&amp; removeDevice) {&#13;
    for (int i = ui-&gt;deviceListWidget-&gt;count() - 1; i &gt;= 0; i--) {&#13;
        QListWidgetItem* item = ui-&gt;deviceListWidget-&gt;item(i);&#13;
        if (item-&gt;text() == removeDevice.deviceName) {&#13;
            qDebug() &lt;&lt; 'Remove device: ' &lt;&lt; item-&gt;text();&#13;
            ui-&gt;deviceListWidget-&gt;removeItemWidget(item);&#13;
            delete ui-&gt;deviceListWidget-&gt;takeItem(ui-&gt;deviceListWidget-&gt;row(item));&#13;
            return;&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
添加信号与槽：在设备名称的输入框修改后，同步更改DiscoveryService中的本机设备信息&#13;
```C++&#13;
void MainWindow::on_edit_device_name_editingFinished() {&#13;
    qDebug() &lt;&lt; 'Editing finished slot';&#13;
    DiscoveryService::getInstance()-&gt;setDeivceName(ui-&gt;edit_device_name-&gt;text());&#13;
}&#13;
```&#13;
在MainWindow的析构函数中，停止组播即可：&#13;
```C++&#13;
MainWindow::~MainWindow() {&#13;
    DiscoveryService::getInstance()-&gt;stopDiscovery();&#13;
    delete ui;&#13;
}&#13;
```。</description><guid isPermaLink="true">https://proacane.github.io/post/QT-shi-xian-ju-yu-wang-wen-jian-chuan-shu-ruan-jian.html</guid><pubDate>Tue, 01 Oct 2024 08:05:03 +0000</pubDate></item><item><title>DS_3：字符串</title><link>https://proacane.github.io/post/DS_3%EF%BC%9A-zi-fu-chuan.html</link><description># 字符串&#13;
由零个或多个字符组成的有限序列&#13;
1. 子串：串中任意个连续的字符组成的子序列&#13;
2. 主串：包含子串的串&#13;
3. 字符在主串中的位置：字符在串中的序号&#13;
4. 子串在主串中的位置：子串的第一个字符在主串中的位置&#13;
基本操作：&#13;
1. 赋值：assign(str*t,str*s)：t赋值为s&#13;
2. 复制：copy(str*t,str*s)：s复制给t&#13;
3. 判空&#13;
4. 长度&#13;
5. 清空&#13;
6. 释放内存&#13;
7. 拼接&#13;
8. 子串：substr(str*s,int pos,int len)&#13;
9. 定位：若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0&#13;
10. 比较大小&#13;
实现依然是分为顺序存储和链式存储&#13;
## 顺序存储实现&#13;
顺序存储内部的 char 数组，可以使用静态数组，也可以使用动态分配，这里使用静态数组&#13;
顺序存储有几种不同的实现方案:&#13;
1. char数组从索引0开始存放字符，使用单独的变量存储字符串长度&#13;
2. char数组索引0存储长度，后面存放字符&#13;
3. 没有长度变量，以\0作为字符串结尾&#13;
4. char数组索引0不使用，使用单独的变量存储字符串长度&#13;
我采用的是：最后一位是'\0'，同时使用len变量&#13;
```C&#13;
#define MAX_LEN 10&#13;
&#13;
typedef struct {&#13;
    char data[MAX_LEN];&#13;
    int length;&#13;
} string;&#13;
&#13;
void constructor(string *s) {&#13;
    s-&gt;length = 0;&#13;
    s-&gt;data[0] = '\0';&#13;
}&#13;
&#13;
bool isEmpty(string *s) {&#13;
    return s-&gt;length == 0;&#13;
}&#13;
&#13;
// 赋值&#13;
void assign(string *s, const char *t, int len) {&#13;
    if (t[0] == '\0') {&#13;
        return;&#13;
    }&#13;
    if (len &gt;= MAX_LEN ) {&#13;
        len = MAX_LEN - 1;&#13;
        printf('t is too long, use %d chars\n', len);&#13;
    }&#13;
    for (int i = 0; i &lt; len; i++) {&#13;
        s-&gt;data[i] = t[i];&#13;
    }&#13;
    s-&gt;length = len;&#13;
    s-&gt;data[len] = '\0';&#13;
}&#13;
&#13;
void copy(string *s, string *t) {&#13;
    memcpy(s-&gt;data, t-&gt;data, t-&gt;length);&#13;
    s-&gt;length = t-&gt;length;&#13;
    s-&gt;data[s-&gt;length] = '\0';&#13;
}&#13;
&#13;
void clear(string *s) {&#13;
    memset(s-&gt;data, '\0', s-&gt;length);&#13;
    s-&gt;length = 0;&#13;
}&#13;
&#13;
void destructor(string *s) {&#13;
&#13;
}&#13;
&#13;
bool concat(string *dest, string *s, string *t) {&#13;
    if (s-&gt;length + t-&gt;length &gt; MAX_LEN) {&#13;
        return false;&#13;
    }&#13;
    for (int i = 0; i &lt; s-&gt;length; i++) {&#13;
        dest-&gt;data[i] = s-&gt;data[i];&#13;
    }&#13;
    for(int j = 0;j&lt; t-&gt;length;j++){&#13;
        dest-&gt;data[j + s-&gt;length] = t-&gt;data[j];&#13;
    }&#13;
    dest-&gt;length = s-&gt;length + t-&gt;length;&#13;
    dest-&gt;data[dest-&gt;length] = '\0';&#13;
    return true;&#13;
}&#13;
&#13;
bool substr(string *dest, string *s, int pos, int len) {&#13;
    if (pos + len &gt; s-&gt;length) {&#13;
        return false;&#13;
    }&#13;
&#13;
    for (int i = pos; i &lt; pos + len; i++) {&#13;
        dest-&gt;data[i - pos] = s-&gt;data[i];&#13;
    }&#13;
    dest-&gt;length = len;&#13;
    dest-&gt;data[len] = '\0';&#13;
    return true;&#13;
}&#13;
&#13;
// s1&gt;s2 返回值大于0&#13;
int compare(string*s1,string*s2){&#13;
    for(int i = 0; i&lt; s1-&gt;length &amp;&amp; i &lt; s2-&gt;length;i++){&#13;
        if(s1-&gt;data[i] != s2-&gt;data[i]){&#13;
            return s1-&gt;data[i] - s2-&gt;data[i];&#13;
        }&#13;
    }&#13;
    // 长度长的串大&#13;
    return s1-&gt;length -s2-&gt;length;&#13;
}&#13;
// 返回t子串在 s 中第一次出现的位置&#13;
int index(string*s,string* t){&#13;
    int i = 0;&#13;
    int n = s-&gt;length;&#13;
    int m = t-&gt;length;&#13;
    if(m &gt; n){&#13;
        return -1;&#13;
    }&#13;
    // 截取子串&#13;
    string sub;&#13;
    constructor(&amp;sub);&#13;
    while(i &lt;= n-m){&#13;
        substr(&amp;sub,s,i,m);&#13;
        // 相等直接返回&#13;
        if(compare(&amp;sub,t) == 0){&#13;
            return i;&#13;
        }&#13;
        i++;&#13;
    }&#13;
    return -1;&#13;
}&#13;
```&#13;
## 链式存储实现&#13;
链式存储的每个节点可以放1个或多个字符，这里存放4个字符&#13;
```C&#13;
#define MAX_CHARS 4&#13;
typedef struct Node {&#13;
    // 每个节点存放4个字符&#13;
    char data[MAX_CHARS];&#13;
    struct Node *next;&#13;
} Node;&#13;
typedef Node *string;&#13;
&#13;
void constructor(string *s) {&#13;
    *s = (Node *) malloc(sizeof(Node));&#13;
    if (*s == NULL) {&#13;
        printf('Failed to allocate memory\n');&#13;
        return;&#13;
    }&#13;
    (*s)-&gt;next = NULL;&#13;
    for (int i = 0; i &lt; MAX_CHARS; ++i) {&#13;
        (*s)-&gt;data[i] = '\0';&#13;
    }&#13;
}&#13;
&#13;
void destructor(string *s) {&#13;
    Node *current = *s;&#13;
    while (current != NULL) {&#13;
        Node *temp = current;&#13;
        current = current-&gt;next;&#13;
        free(temp);&#13;
    }&#13;
    *s = NULL;&#13;
}&#13;
&#13;
int size(string *s) {&#13;
    Node *current = *s;&#13;
    int totalLen = 0;&#13;
    while (current != NULL) {&#13;
        for (int i = 0; i &lt; MAX_CHARS; i++) {&#13;
            if (current-&gt;data[i] == '\0') {&#13;
                return totalLen;&#13;
            }&#13;
            totalLen++;&#13;
        }&#13;
        current = current-&gt;next;&#13;
    }&#13;
    return totalLen;&#13;
}&#13;
&#13;
bool isEmpty(string *s) {&#13;
    return (*s == NULL || (*s)-&gt;data[0] == '\0');&#13;
}&#13;
&#13;
void assign(string *s, const char *t, int len) {&#13;
    if (t[0] == '\0') {&#13;
        return;&#13;
    }&#13;
    destructor(s);&#13;
    constructor(s);&#13;
    Node *current = *s;&#13;
    for (int i = 0; i &lt; len; i++) {&#13;
        if (i != 0 &amp;&amp; i % MAX_CHARS == 0) {&#13;
            // 创建新节点&#13;
            Node *newNode = (Node *) malloc(sizeof(Node));&#13;
            if (newNode == NULL) {&#13;
                printf('Failed to allocate memory\n');&#13;
                return;&#13;
            }&#13;
            newNode-&gt;next = NULL;&#13;
            for (int k = 0; k &lt; MAX_CHARS; ++k) {&#13;
                newNode-&gt;data[k] = '\0';&#13;
            }&#13;
            current-&gt;next = newNode;&#13;
            current = newNode;&#13;
        }&#13;
        current-&gt;data[i % MAX_CHARS] = t[i];&#13;
    }&#13;
}&#13;
&#13;
void printStr(string *s) {&#13;
    Node *current = *s;&#13;
    while (current != NULL) {&#13;
        for (int i = 0; i &lt; MAX_CHARS; i++) {&#13;
            if (current-&gt;data[i] != '\0') {&#13;
                printf('%c', current-&gt;data[i]);&#13;
            }&#13;
        }&#13;
        current = current-&gt;next;&#13;
    }&#13;
    printf('\n');&#13;
}&#13;
&#13;
bool concat(string *dest, string *s, string *t) {&#13;
    destructor(dest);&#13;
    constructor(dest);&#13;
    Node *current = *s;&#13;
    Node *destCurrent = *dest;&#13;
    int i = 0;&#13;
    // s 拼到 dest&#13;
    while (current != NULL) {&#13;
        for (int j = 0; j &lt; MAX_CHARS; j++) {&#13;
            if (current-&gt;data[j] == '\0') {&#13;
                break;&#13;
            }&#13;
            destCurrent-&gt;data[i++] = current-&gt;data[j];&#13;
            if (i == MAX_CHARS) {&#13;
                // 创建新节点&#13;
                Node *newNode = (Node *) malloc(sizeof(Node));&#13;
                if (newNode == NULL) {&#13;
                    printf('Failed to allocate memory\n');&#13;
                    return false;&#13;
                }&#13;
                newNode-&gt;next = NULL;&#13;
                for (int k = 0; k &lt; MAX_CHARS; ++k) {&#13;
                    newNode-&gt;data[k] = '\0';&#13;
                }&#13;
                destCurrent-&gt;next = newNode;&#13;
                destCurrent = newNode;&#13;
                i = 0;&#13;
            }&#13;
        }&#13;
        current = current-&gt;next;&#13;
    }&#13;
&#13;
    // 拼接完了 s，从 dest当前节点的第 i位拼接 t&#13;
    current = *t;&#13;
    while (current != NULL) {&#13;
        for (int j = 0; j &lt; MAX_CHARS; j++) {&#13;
            if (current-&gt;data[j] == '\0') {&#13;
                break;&#13;
            }&#13;
            destCurrent-&gt;data[i++] = current-&gt;data[j];&#13;
            // dest的节点满了，创建新节点&#13;
            if (i == MAX_CHARS) {&#13;
                Node *newNode = (Node *) malloc(sizeof(Node));&#13;
                if (newNode == NULL) {&#13;
                    printf('Failed to allocate memory\n');&#13;
                    return false;&#13;
                }&#13;
                newNode-&gt;next = NULL;&#13;
                for (int k = 0; k &lt; MAX_CHARS; ++k) {&#13;
                    newNode-&gt;data[k] = '\0';&#13;
                }&#13;
                destCurrent-&gt;next = newNode;&#13;
                destCurrent = newNode;&#13;
                i = 0;&#13;
            }&#13;
        }&#13;
        current = current-&gt;next;&#13;
    }&#13;
    return true;&#13;
}&#13;
&#13;
bool substr(string *dest, string *s, int pos, int len) {&#13;
    destructor(dest);&#13;
    constructor(dest);&#13;
    int strLen = size(s);&#13;
    if (pos + len &gt; strLen) {&#13;
        return false;&#13;
    }&#13;
    // 从第几个节点开始截取&#13;
    int i = pos / MAX_CHARS;&#13;
    // 从节点的第几位开始截取&#13;
    int j = pos % MAX_CHARS;&#13;
    Node *current = *s;&#13;
    // 移动到第 i 个节点&#13;
    while (i &gt; 0 &amp;&amp; current != NULL) {&#13;
        current = current-&gt;next;&#13;
        i--;&#13;
    }&#13;
&#13;
    if (current == NULL) {&#13;
        return false; // 如果没有足够的节点&#13;
    }&#13;
&#13;
    Node *destCurrent = *dest;&#13;
    int destIndex = 0;&#13;
&#13;
    // 开始向 dest 中添加字符&#13;
    for (int k = 0; k &lt; len; k++) {&#13;
        // 截取完了一个节点&#13;
        if (j == MAX_CHARS) {&#13;
            current = current-&gt;next;&#13;
            j = 0;&#13;
        }&#13;
        // dest的节点放满了&#13;
        if (destIndex == MAX_CHARS) {&#13;
            // 创建新节点&#13;
            Node *newNode = (Node *) malloc(sizeof(Node));&#13;
            if (newNode == NULL) {&#13;
                printf('Failed to allocate memory\n');&#13;
                return false;&#13;
            }&#13;
            newNode-&gt;next = NULL;&#13;
            for (int l = 0; l &lt; MAX_CHARS; ++l) {&#13;
                newNode-&gt;data[l] = '\0';&#13;
            }&#13;
            destCurrent-&gt;next = newNode;&#13;
            destCurrent = newNode;&#13;
            destIndex = 0;&#13;
        }&#13;
        destCurrent-&gt;data[destIndex++] = current-&gt;data[j++];&#13;
    }&#13;
    return true;&#13;
}&#13;
&#13;
// s1&gt;s2 返回值大于0&#13;
int compare(string *s1, string *s2) {&#13;
    Node *current1 = *s1;&#13;
    Node *current2 = *s2;&#13;
    while (current1 != NULL &amp;&amp; current2 != NULL) {&#13;
        for (int i = 0; i &lt; MAX_CHARS; i++) {&#13;
            if (current1-&gt;data[i] == '\0' || current2-&gt;data[i] == '\0') {&#13;
                return current1-&gt;data[i] - current2-&gt;data[i];&#13;
            }&#13;
&#13;
            if (current1-&gt;data[i] != current2-&gt;data[i]) {&#13;
                return current1-&gt;data[i] - current2-&gt;data[i];&#13;
            }&#13;
        }&#13;
        current1 = current1-&gt;next;&#13;
        current2 = current2-&gt;next;&#13;
    }&#13;
    return size(s1) - size(s2);&#13;
}&#13;
&#13;
int indexOfString(string *s, string *t) {&#13;
    int sSize = size(s);&#13;
    int tSize = size(t);&#13;
    if (tSize &gt; sSize) {&#13;
        return -1;&#13;
    }&#13;
&#13;
    string sub = NULL;&#13;
    int i = 0;&#13;
    while (i &lt;= sSize - tSize) {&#13;
        if (!substr(&amp;sub, s, i, tSize)) {&#13;
            destructor(&amp;sub);&#13;
            return -1;&#13;
        };&#13;
        if (compare(&amp;sub, t) == 0) {&#13;
            destructor(&amp;sub);&#13;
            return i;&#13;
        }&#13;
        i++;&#13;
    }&#13;
    destructor(&amp;sub);&#13;
    return -1;&#13;
}&#13;
```&#13;
初始化的时候可能初始化为NULL比较好，这里就不作更改了。</description><guid isPermaLink="true">https://proacane.github.io/post/DS_3%EF%BC%9A-zi-fu-chuan.html</guid><pubDate>Sat, 28 Sep 2024 07:27:52 +0000</pubDate></item><item><title>OS_1：进程管理</title><link>https://proacane.github.io/post/OS_1%EF%BC%9A-jin-cheng-guan-li.html</link><description># 进程的概念、组成、特征&#13;
## 概念&#13;
进程可以理解为程序的一次执行，同一个程序可以创建多个进程&#13;
## 组成&#13;
当进程被创建时，操作系统会为该进程分配一个唯一的PID（Process ID，进程ID），操作系统还会记录给进程分配的资源情况、运行状况等，这些信息都被保存在一个数据结构PCB中，也叫进程控制块&#13;
![image](https://github.com/user-attachments/assets/568e1105-9df3-4f30-af4a-54a0885708b6)&#13;
而进程的组成，则如下图：&#13;
![image](https://github.com/user-attachments/assets/195c850a-cbcb-4398-9a1c-77ae05880fef)&#13;
其中，PCB由操作系统使用，程序段和数据段由进程使用&#13;
## 特征&#13;
1. 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的&#13;
2. 并发性：内存中有多个进程实体，各进程可并发执行&#13;
3. 独立性：进程是能独立运行、独立获得资源、独立接收调度的基本单位&#13;
4. 异步性：各进程按各自的速度推进，操作系统提供**进程同步机制**来解决异步问题&#13;
5. 结构性：每个进程都会配置一个PCB，结构上由三段组成（如上图）&#13;
# 进程的组织&#13;
因为操作系统中会存在很多进程，所以需要使用适当的方式将多个进程的PCB进行组织管理&#13;
## 链接方式&#13;
按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针&#13;
![image](https://github.com/user-attachments/assets/583f94a8-0fb0-4df4-8960-78e4651ba05b)&#13;
## 索引方式&#13;
根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针&#13;
![image](https://github.com/user-attachments/assets/615a052b-8780-418c-9dcf-2e7ba81e1e6d)&#13;
# 进程的状态与转换&#13;
进程的状态有：&#13;
1. 运行状态&#13;
2. 就绪状态&#13;
3. 阻塞状态&#13;
4. 创建状态&#13;
5. 终止状态&#13;
其中，运行、就绪、阻塞是三种最基本的状态&#13;
状态之间的转换:&#13;
1. 就绪态-&gt;运行态&#13;
2. 运行态-&gt;就绪态&#13;
3. 运行态-&gt;阻塞态&#13;
4. 阻塞态-&gt;就绪态&#13;
## 创建态、就绪态&#13;
进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB；当进程创建完成后，便进入“就绪态”，处于就绪态的进程已经具备运行条件，等待cpu的执行&#13;
## 运行态&#13;
cpu正在运行的进程&#13;
## 阻塞态&#13;
在进程运行的过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应）。</description><guid isPermaLink="true">https://proacane.github.io/post/OS_1%EF%BC%9A-jin-cheng-guan-li.html</guid><pubDate>Fri, 27 Sep 2024 07:37:03 +0000</pubDate></item><item><title>DS_2：队列</title><link>https://proacane.github.io/post/DS_2%EF%BC%9A-dui-lie.html</link><description># 队列&#13;
只允许一端进入，另一端删除的线性表&#13;
基本操作：&#13;
1. 初始化&#13;
2. 释放内存&#13;
3. 入队&#13;
4. 出队&#13;
5. 获取队头元素&#13;
6. 判空&#13;
## 顺序存储实现队列&#13;
内部使用连续内存的数组，采用循环队列的格式&#13;
```C&#13;
#define MAX_SIZE 10&#13;
#define Type int&#13;
typedef struct {&#13;
    Type data[MAX_SIZE];&#13;
    // 队头指针&#13;
    int front;&#13;
    // 队尾指针&#13;
    int rear;&#13;
    // 添加 size，来维护队列的长度，用于判断队列是否已满&#13;
    int size;&#13;
} Queue;&#13;
&#13;
void constructor(Queue *q) {&#13;
    q-&gt;front = 0;&#13;
    q-&gt;rear = 0;&#13;
}&#13;
&#13;
bool isEmpty(Queue *q) {&#13;
    return q-&gt;front == q-&gt;rear;&#13;
}&#13;
&#13;
bool isFull(Queue *q) {&#13;
    return (q-&gt;rear + 1) % MAX_SIZE == q-&gt;front;&#13;
}&#13;
&#13;
void push(Queue *q, Type e) {&#13;
    // 如果队列已满则不能添加&#13;
    if (isFull(q)) {&#13;
        printf('Queue is full');&#13;
        return;&#13;
    }&#13;
    q-&gt;data[q-&gt;rear] = e;&#13;
    q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE;&#13;
}&#13;
&#13;
Type pop(Queue*q){&#13;
    if(isEmpty(q)){&#13;
        return -1;&#13;
    }&#13;
    Type t = q-&gt;data[q-&gt;front];&#13;
    q-&gt;front = (q-&gt;front+1)%MAX_SIZE;&#13;
    return t;&#13;
}&#13;
```&#13;
&#13;
&gt; 在判断队列是否已满，或是否空的时候，可以采用不同的方式，一种就是上面代码所用的方式，也可以添加 size 成员，记录当前队列的有效元素数量，通过 size == MAX_SIZE 和 size == 0 来判断队列状态；&#13;
&gt; 另一种有效的方式是添加 tag 标记，0和1分别表示上次成功的操作为出队和入队，当 front == rear &amp;&amp; tag == 0，就代表队列空了， front == rear &amp;&amp; tag == 1就代表队列已满&#13;
## 链式队列&#13;
链式存储依然分为有头结点和无头结点两种方式，链式存储没有判空、判满的必要&#13;
无头结点：&#13;
```C&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;malloc.h&gt;&#13;
#include &lt;stdbool.h&gt;&#13;
&#13;
#define Type int&#13;
&#13;
typedef struct Node {&#13;
    struct Node *next;&#13;
    Type data;&#13;
} Node;&#13;
typedef struct {&#13;
    Node *front;&#13;
    Node *rear;&#13;
} Queue;&#13;
&#13;
void constructor(Queue *q) {&#13;
    (*q).front = NULL;&#13;
    (*q).rear = NULL;&#13;
}&#13;
&#13;
bool isEmpty(Queue *q) {&#13;
    return q-&gt;front == NULL;&#13;
}&#13;
&#13;
void destructor(Queue *q) {&#13;
    Node *p = (*q).front;&#13;
    while (p != NULL) {&#13;
        Node *temp = p;&#13;
        p = p-&gt;next;&#13;
        free(temp);&#13;
    }&#13;
    (*q).front = NULL;&#13;
    (*q).rear = NULL;  // 确保队列的 rear 也设置为 NULL&#13;
}&#13;
&#13;
void push(Queue *q, Type e) {&#13;
    if (q == NULL) {&#13;
        printf('Queue is not initialized\n');&#13;
        return;&#13;
    }&#13;
    // 插入到队尾&#13;
    Node *newNode = (Node *) malloc(sizeof(Node));&#13;
    if (newNode == NULL) {&#13;
        printf('Can't allocate memory');&#13;
        return;&#13;
    }&#13;
    newNode-&gt;next = NULL;&#13;
    newNode-&gt;data = e;&#13;
    // 如果没有结点&#13;
    if (q-&gt;front == NULL) {&#13;
        q-&gt;front = newNode;&#13;
        q-&gt;rear = newNode;&#13;
        printf('Inserted %d as the first element\n', e);&#13;
    } else {&#13;
        q-&gt;rear-&gt;next = newNode;&#13;
        q-&gt;rear = newNode;&#13;
        printf('Inserted %d at the rear of the queue\n', e);&#13;
    }&#13;
}&#13;
&#13;
Type pop(Queue *q) {&#13;
    if (isEmpty(q)) {&#13;
        printf('Queue is empty, can't pop\n');&#13;
        return -1;&#13;
    }&#13;
    Node *popNode = q-&gt;front;&#13;
    q-&gt;front = q-&gt;front-&gt;next;&#13;
    Type v = popNode-&gt;data;&#13;
    if (q-&gt;front == NULL) {&#13;
        q-&gt;rear = NULL;&#13;
        printf('Queue is now empty after popping %d\n', v);&#13;
    } else {&#13;
        printf('Popped %d from the queue\n', v);&#13;
    }&#13;
    free(popNode);&#13;
    return v;&#13;
}&#13;
```&#13;
带头结点:&#13;
```C&#13;
#define Type int&#13;
&#13;
typedef struct Node {&#13;
    struct Node *next;&#13;
    Type data;&#13;
} Node;&#13;
&#13;
typedef struct {&#13;
    Node *front;&#13;
    Node *rear;&#13;
} Queue;&#13;
&#13;
void constructor(Queue *q) {&#13;
    // 创建头结点&#13;
    q-&gt;front = q-&gt;rear = (Node *) malloc(sizeof(Node));&#13;
    q-&gt;front-&gt;next = NULL;&#13;
}&#13;
&#13;
void destructor(Queue *q) {&#13;
    Node *p = q-&gt;front;&#13;
    while (p != NULL) {&#13;
        Node *temp = p;&#13;
        p = p-&gt;next;&#13;
        free(temp);&#13;
    }&#13;
    (*q).front = NULL;&#13;
    (*q).rear = NULL;  // 确保队列的 rear 也设置为 NULL&#13;
}&#13;
&#13;
bool isEmpty(Queue *q) {&#13;
    return q-&gt;front == q-&gt;rear;&#13;
}&#13;
&#13;
void push(Queue *q, Type e) {&#13;
//    printf('Pushing element: %d\n', e);  // 日志记录&#13;
    Node *newNode = (Node *) malloc(sizeof(Node));&#13;
    if (newNode == NULL) {&#13;
        printf('Can't allocate memory');&#13;
        return;&#13;
    }&#13;
    newNode-&gt;next = NULL;&#13;
    newNode-&gt;data = e;&#13;
    q-&gt;rear-&gt;next = newNode;&#13;
    q-&gt;rear = newNode;&#13;
    printf('Element pushed: %d\n', e);  // 日志记录&#13;
}&#13;
&#13;
Type pop(Queue*q){&#13;
    if(isEmpty(q)){&#13;
        printf('Queue is empty, cannot pop.\n');  // 日志记录&#13;
        return -1;&#13;
    }&#13;
    Node* popNode = q-&gt;front-&gt;next;&#13;
    Type v = popNode-&gt;data;&#13;
//    printf('Popping element: %d\n', v);  // 日志记录&#13;
    q-&gt;front-&gt;next = popNode-&gt;next;&#13;
    // 如果只有一个结点&#13;
    if(q-&gt;rear == popNode){&#13;
        q-&gt;rear = q-&gt;front;&#13;
    }&#13;
    free(popNode);&#13;
    printf('Element popped: %d\n', v);  // 日志记录&#13;
    return v;&#13;
}&#13;
```。</description><guid isPermaLink="true">https://proacane.github.io/post/DS_2%EF%BC%9A-dui-lie.html</guid><pubDate>Fri, 27 Sep 2024 06:47:33 +0000</pubDate></item><item><title>操作系统概述</title><link>https://proacane.github.io/post/cao-zuo-xi-tong-gai-shu.html</link><description># 操作系统的概念&#13;
操作系统（Operating System， OS）是指控制和**管理**整个计算机系统的**硬件和软件**资源，并合理地组织调度计算机的工作和资源的分配；以**提供给用户和其他软件方便的接口和环境**；它是计算机系统中**最基本的系统软件**&#13;
# 特征&#13;
操作系统的4个特征：&#13;
1. 并发&#13;
2. 共享&#13;
3. 虚拟&#13;
4. 异步&#13;
其中，并发、共享是操作系统最基本的特征，并且二者相互依存&#13;
## 并发&#13;
并发是指两个或多个事件在同一时间间隔内发生，在宏观看来是同时发生的，但是微观上是交替运行的；&#13;
操作系统的并发指的是可以同时存在多个运行的程序&#13;
并行：指多个事件在同一时刻同时发生&#13;
单核 cpu 同一时刻只能运行一个进程，只能并发&#13;
多核 cpu 同一时刻可以运行多个进程，既存在并发、也存在并行&#13;
## 共享&#13;
共享：指系统中的资源可以被多个并发执行的进程使用&#13;
互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源，例如摄像头等资源&#13;
同时共享：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问，例如磁盘的读写&#13;
从共享的定义就可以看出来，若操作系统没有并发性，共享就没有意义；没有共享性，并发也没有意义&#13;
## 虚拟&#13;
虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。</description><guid isPermaLink="true">https://proacane.github.io/post/cao-zuo-xi-tong-gai-shu.html</guid><pubDate>Thu, 26 Sep 2024 07:22:55 +0000</pubDate></item><item><title>DS_2：栈</title><link>https://proacane.github.io/post/DS_2%EF%BC%9A-zhan.html</link><description># 栈&#13;
定义：只允许在一端进行操作（插入、删除）的线性表&#13;
基本操作：&#13;
1. 初始化栈&#13;
2. 释放内存&#13;
3. 进栈&#13;
4. 出栈&#13;
5. 获取栈顶元素&#13;
6. 判空&#13;
## 顺序栈&#13;
实现:静态数组中存放栈元素&#13;
```C&#13;
#define Type int&#13;
#define MAX_SIZE 10&#13;
typedef struct Stack {&#13;
    // 存放栈元素&#13;
    Type data[MAX_SIZE];&#13;
    // 栈顶指针&#13;
    int top;&#13;
} Stack;&#13;
&#13;
void initStack(Stack *s) {&#13;
    // 栈为空&#13;
    s-&gt;top = -1;&#13;
}&#13;
&#13;
void destructorStack(Stack *s) {&#13;
    s-&gt;top = -1;&#13;
}&#13;
&#13;
bool isEmpty(Stack *s) {&#13;
    return s-&gt;top == -1;&#13;
}&#13;
&#13;
bool push(Stack *s, Type e) {&#13;
    if (s-&gt;top == MAX_SIZE - 1) {&#13;
        printf('Stack is full');&#13;
        return false;&#13;
    }&#13;
    s-&gt;data[++s-&gt;top] = e;&#13;
    return true;&#13;
}&#13;
&#13;
bool pop(Stack *s) {&#13;
    if (isEmpty(s)) {&#13;
        printf('Stack is empty');&#13;
        return false;&#13;
    }&#13;
    s-&gt;top--;&#13;
    return true;&#13;
}&#13;
&#13;
Type front(Stack*s){&#13;
    if (isEmpty(s)) {&#13;
        printf('Stack is empty');&#13;
        return false;&#13;
    }&#13;
    return s-&gt;data[s-&gt;top];&#13;
}&#13;
```&#13;
也可以将top初始化为0，这样top指向的就是下一个入栈的位置&#13;
## 共享栈&#13;
就是在顺序栈的基础上，再添加一个top标记，将一整片数组空间分为两个栈使用，top0是从数组的索引0向上，top1从数组的最大索引向下；相交的时候就是满了&#13;
&#13;
## 链式栈&#13;
每个元素就是一个链表结点，实现栈的功能就行，也是分为带头结点和不带头结点&#13;
不带头结点:&#13;
```C&#13;
#define Type int&#13;
typedef struct Node {&#13;
    Type data;&#13;
    struct Node *next;&#13;
} Node;&#13;
typedef Node *stack;&#13;
&#13;
void initStack(stack *s) {&#13;
    (*s) = NULL;&#13;
}&#13;
&#13;
void destructor(stack *s) {&#13;
    Node *p = *s;&#13;
    while (p != NULL) {&#13;
        Node *temp = p;&#13;
        p = p-&gt;next;&#13;
        free(temp);&#13;
    }&#13;
    (*s) = NULL;&#13;
}&#13;
&#13;
bool push(stack *s, Type e) {&#13;
    Node *p = *s;&#13;
    Node *newNode = (Node *) malloc(sizeof(Node));&#13;
    if (newNode == NULL) {&#13;
        printf('Failed to allocate memory');&#13;
        return false;&#13;
    }&#13;
    newNode-&gt;data = e;&#13;
    newNode-&gt;next = p;&#13;
    *s = newNode;&#13;
    return true;&#13;
}&#13;
&#13;
bool pop(stack *s) {&#13;
    if (*s == NULL) {&#13;
        printf('Stack is empty\n');&#13;
        return false;&#13;
    }&#13;
    Node *p = *s;&#13;
    (*s) = (*s)-&gt;next;&#13;
    free(p);&#13;
    return true;&#13;
}&#13;
&#13;
Type front(stack *s) {&#13;
    if (*s == NULL) {&#13;
        printf('Stack is empty\n');&#13;
        return -1;&#13;
    }&#13;
    return (*s)-&gt;data;&#13;
}&#13;
```&#13;
带头结点：&#13;
```C&#13;
#define Type int&#13;
typedef struct Node {&#13;
    Type data;&#13;
    struct Node *next;&#13;
} Node;&#13;
typedef Node *stack;&#13;
&#13;
void constructor(stack *s) {&#13;
    // 分配头结点&#13;
    (*s) = (Node *) malloc(sizeof(Node));&#13;
    if (*s == NULL) {&#13;
        printf('Failed to allocate memory');&#13;
        return;&#13;
    }&#13;
    (*s)-&gt;data = -1;&#13;
    (*s)-&gt;next = NULL;&#13;
}&#13;
&#13;
void destructor(stack *s) {&#13;
    if (*s == NULL) {&#13;
        return;&#13;
    }&#13;
    Node *p = *s;&#13;
    while (p != NULL) {&#13;
        Node *temp = p;&#13;
        p = p-&gt;next;&#13;
        free(temp);&#13;
    }&#13;
    (*s) = NULL;&#13;
}&#13;
&#13;
bool push(stack *s, Type e) {&#13;
    if (*s == NULL) {&#13;
        printf('stack is not initialized');&#13;
        return false;&#13;
    }&#13;
    Node *newNode = (Node *) malloc(sizeof(Node));&#13;
    if (newNode == NULL) {&#13;
        printf('Failed to allocate memory');&#13;
        return false;&#13;
    }&#13;
    newNode-&gt;data = e;&#13;
    newNode-&gt;next = (*s)-&gt;next;&#13;
    (*s)-&gt;next = newNode;&#13;
    return true;&#13;
}&#13;
&#13;
bool pop(stack *s) {&#13;
    if ((*s) == NULL || (*s)-&gt;next == NULL) {&#13;
        printf('Stack is empty\n');&#13;
        return false;&#13;
    }&#13;
    Node *p = (*s)-&gt;next;&#13;
    (*s)-&gt;next = p-&gt;next;&#13;
    free(p);&#13;
    return true;&#13;
}&#13;
&#13;
Type front(stack *s) {&#13;
    if ((*s) == NULL || (*s)-&gt;next == NULL) {&#13;
        printf('Stack is empty\n');&#13;
        return -1;&#13;
    }&#13;
    return (*s)-&gt;next-&gt;data;&#13;
}&#13;
```&#13;
代码地址：https://github.com/proacane/DataStructure。</description><guid isPermaLink="true">https://proacane.github.io/post/DS_2%EF%BC%9A-zhan.html</guid><pubDate>Thu, 26 Sep 2024 06:31:05 +0000</pubDate></item><item><title>DS_1：线性表</title><link>https://proacane.github.io/post/DS_1%EF%BC%9A-xian-xing-biao.html</link><description># 线性表&#13;
线性表是具有相同数据类型的n（n≥0）个数据元素的**有限序列**，其中n为表长，当n = 0时线性表是一个空表。</description><guid isPermaLink="true">https://proacane.github.io/post/DS_1%EF%BC%9A-xian-xing-biao.html</guid><pubDate>Mon, 23 Sep 2024 08:20:56 +0000</pubDate></item><item><title>Asio协程</title><link>https://proacane.github.io/post/Asio-xie-cheng.html</link><description># 协程&#13;
协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</description><guid isPermaLink="true">https://proacane.github.io/post/Asio-xie-cheng.html</guid><pubDate>Mon, 23 Sep 2024 06:04:56 +0000</pubDate></item><item><title>Grpc</title><link>https://proacane.github.io/post/Grpc.html</link><description># 下载&#13;
&#13;
vcpkg install grpc&#13;
&#13;
# 配置&#13;
&#13;
cmake 中：&#13;
&#13;
```cmake&#13;
find_package(Protobuf CONFIG REQUIRED)&#13;
find_package(gRPC CONFIG REQUIRED)&#13;
include_directories(${CMAKE_CURRENT_BINARY_DIR})&#13;
arget_link_libraries(${projectName} PRIVATE gRPC::grpc++ protobuf::libprotobuf)&#13;
```&#13;
&#13;
# 编译&#13;
&#13;
编写好 proto文件，在 powershell 中使用如下命令，插件选择自己的路径：&#13;
&#13;
```cmd&#13;
protoc --proto_path=. --cpp_out=. demo.proto&#13;
protoc --proto_path=. --grpc_out=. --plugin=protoc-gen-grpc='D:\develop_tools\cppsoft\vcpkg\packages\grpc_x64-windows\tools\grpc\grpc_cpp_plugin.exe' demo.proto&#13;
```&#13;
&#13;
生成文件添加到 cmakelists.txt 中&#13;
&#13;
# 通信流程&#13;
&#13;
1. 连接到服务端的地址&#13;
2. 创建客户端实例，调用函数，将请求消息发送给服务端&#13;
3. 服务端接收到请求，处理请求消息并生成响应消息。</description><guid isPermaLink="true">https://proacane.github.io/post/Grpc.html</guid><pubDate>Mon, 23 Sep 2024 06:03:31 +0000</pubDate></item><item><title>Beast实现websocket服务器</title><link>https://proacane.github.io/post/Beast-shi-xian-websocket-fu-wu-qi.html</link><description># 流对象&#13;
&#13;
WebSocket连接需要一个有状态对象，由Beast中的一个类模板websocket::stream表示。</description><guid isPermaLink="true">https://proacane.github.io/post/Beast-shi-xian-websocket-fu-wu-qi.html</guid><pubDate>Mon, 23 Sep 2024 06:01:36 +0000</pubDate></item><item><title>Asio实现Http服务器</title><link>https://proacane.github.io/post/Asio-shi-xian-Http-fu-wu-qi.html</link><description># Http简介&#13;
&#13;
## Http包头信息&#13;
&#13;
一个标准的HTTP报文头通常由请求头和响应头两部分组成。</description><guid isPermaLink="true">https://proacane.github.io/post/Asio-shi-xian-Http-fu-wu-qi.html</guid><pubDate>Mon, 23 Sep 2024 06:00:29 +0000</pubDate></item><item><title>多线程Asio</title><link>https://proacane.github.io/post/duo-xian-cheng-Asio.html</link><description># 多线程模型&#13;
asio 的多线程模型有两种，IOServicePool 和 IOThreadPool&#13;
# IOServicePool&#13;
IOServicePool模型：&#13;
![image-20240801133223177](https://github.com/user-attachments/assets/c036abee-852d-42a7-ab2d-b2acb054f14f)&#13;
特点:&#13;
1. 每个 io_context 都运行在不同的线程内，对于一个 socket，会注册在同一个 io_context 内，并且回调函数的触发也是在同一个线程内，不存在并发安全问题&#13;
2. 不同的 socket，回调函数可能由不同的线程调用，如果回调函数中进行了共享数据的修改，就会存在线程安全问题，这时可以在回调函数中加锁或者使用逻辑队列的方式&#13;
3. 多线程模式极大的提高了并发能力；单线程模式下如果回调函数调用时间过长，会影响后续函数的调用；通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题&#13;
## 实现&#13;
&#13;
本质就是一个线程池，基本功能就是根据构造函数传入的数量创建n个线程和 io_context，然后每个线程跑一个 io_context，这样就可以并发处理不同 io_context 读写事件了。</description><guid isPermaLink="true">https://proacane.github.io/post/duo-xian-cheng-Asio.html</guid><pubDate>Mon, 23 Sep 2024 05:51:27 +0000</pubDate></item><item><title>Asio网络库摘要</title><link>https://proacane.github.io/post/Asio-wang-luo-ku-zhai-yao.html</link><description># 单线程通信流程&#13;
![image-20240726093453475](https://github.com/user-attachments/assets/a53c98fb-c149-403e-b102-d110905e5eb4)&#13;
# 同步读写的示例&#13;
- 服务端&#13;
```cpp&#13;
#include &lt;iostream&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;memory&gt;&#13;
#include &lt;set&gt;&#13;
#include &lt;thread&gt;&#13;
&#13;
using namespace std;&#13;
using namespace boost::asio::ip;&#13;
&#13;
const int MAX_LEN = 1024;&#13;
typedef shared_ptr&lt;tcp::socket&gt; socket_ptr;&#13;
std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt; thread_set;&#13;
&#13;
void session(socket_ptr sock) {&#13;
    try {&#13;
        for (;;) {&#13;
            char data[MAX_LEN];&#13;
            boost::system::error_code error;&#13;
            // 读取客户端发送的内容&#13;
            size_t length = sock-&gt;read_some(boost::asio::buffer(data), error);&#13;
&#13;
            if (error == boost::asio::error::eof) {&#13;
                std::cout &lt;&lt; 'Connection closed by peer\n';&#13;
                break;&#13;
            } else if (error) {&#13;
                throw boost::system::system_error(error);&#13;
            }&#13;
&#13;
            std::string received_message(data, length);&#13;
            std::cout &lt;&lt; 'Received from ' &lt;&lt; sock-&gt;remote_endpoint().address().to_string() &lt;&lt; ': ' &lt;&lt; received_message &lt;&lt; std::endl;&#13;
&#13;
            // 转换为 大写&#13;
            // Process the received message (e.g., convert to upper case)&#13;
            std::transform(received_message.begin(), received_message.end(), received_message.begin(), ::toupper);&#13;
            // 再写回客户端&#13;
            boost::asio::write(*sock, boost::asio::buffer(received_message));&#13;
        }&#13;
    } catch (exception &amp;e) {&#13;
        std::cerr &lt;&lt; 'Exception in thread: ' &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
    }&#13;
}&#13;
&#13;
// 建立连接&#13;
void server(boost::asio::io_context &amp;ios, unsigned short port_num) {&#13;
    boost::asio::ip::tcp::acceptor acceptor(ios, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port_num));&#13;
    std::cout &lt;&lt; 'Server started on port ' &lt;&lt; port_num &lt;&lt; std::endl;&#13;
    // 没连接就一直阻塞&#13;
    for (;;) {&#13;
        socket_ptr socket(new tcp::socket(ios));&#13;
        acceptor.accept(*socket);&#13;
        std::cout &lt;&lt; 'Accepted connection from ' &lt;&lt; socket-&gt;remote_endpoint().address().to_string() &lt;&lt; std::endl;&#13;
        // 为连接创建一个线程，开始通信&#13;
        auto t = make_shared&lt;std::thread&gt;(session, socket);&#13;
        thread_set.insert(t);&#13;
    }&#13;
}&#13;
&#13;
int main() {&#13;
    try {&#13;
        boost::asio::io_context ios;&#13;
        server(ios, 1234);&#13;
        // 防止有数据未传输完时，主线程就结束了&#13;
        for (auto &amp;t: thread_set) {&#13;
            t-&gt;join();&#13;
        }&#13;
    } catch (exception &amp;e) {&#13;
        std::cerr &lt;&lt; 'Exception in main thread: ' &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
    }&#13;
&#13;
    return 0;&#13;
}&#13;
```&#13;
# 异步读写示例&#13;
![image-20240726095026183](https://github.com/user-attachments/assets/bd621b55-b962-4eaf-9488-5bb8f7c47f79)&#13;
## 注意的问题&#13;
&#13;
- 异常处理时，为防止 Session 二次析构，需要继承 std::enable_shared_from_this&lt;CSession&gt;；使用智能指针与 map 延长 Session 的生命周期&#13;
&#13;
- 发送消息时，为保证消息的有序性，需要增加发送队列&#13;
&#13;
- 处理粘包问题，消息结构采用 TLV 格式，使用 async_read_some 比较麻烦，使用 async_read 比较简洁&#13;
&#13;
  ​							![image-20240726093831093](https://github.com/user-attachments/assets/45a3e63d-53d6-4124-b647-d9742bc9897e)&#13;
&#13;
  - async_read_some：回调函数里不断判断已经处理的字节&#13;
&#13;
  - async_read：两层回调，第一层处理包头，第二层处理包体&#13;
&#13;
- 字节序的处理：发送前转换为网络字节序，接收后转换为本地字节序 (boost::asio::detail::socket_ops::network_to_host_short)&#13;
- 发送数据使用jsoncpp进行封装&#13;
&#13;
CServer.h&#13;
&#13;
```cpp&#13;
#ifndef ASYNCSERVER_CSERVER_H&#13;
#define ASYNCSERVER_CSERVER_H&#13;
#include 'CSession.h'&#13;
#include &lt;iostream&gt;&#13;
class CSession;&#13;
/**&#13;
 * 接受新的客户端连接，每个连接都会创建一个新的 Session 实例&#13;
 */&#13;
class CServer {&#13;
public:&#13;
    CServer(boost::asio::io_context &amp;ioc, unsigned short port_num);&#13;
    // 移除已处理完成的 Session 实例&#13;
    void clear_session(std::string uuid);&#13;
private:&#13;
    // 创建一个新的 Session 并等待新的客户端连接&#13;
    void start_accept();&#13;
    // 处理新的客户端连接，将其加入 _sessions 中，并启动数据处理&#13;
    void handle_accept(std::shared_ptr&lt;CSession&gt; newSession, const boost::system::error_code errorCode);&#13;
&#13;
    boost::asio::io_context &amp;_ioc;&#13;
    boost::asio::ip::tcp::acceptor _acceptor;&#13;
    // 管理连接&#13;
    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;&#13;
&#13;
};&#13;
#endif //ASYNCSERVER_CSERVER_H&#13;
```&#13;
&#13;
CServer.cpp&#13;
&#13;
```cpp&#13;
#include 'CServer.h'&#13;
&#13;
CServer::CServer(boost::asio::io_context &amp;ioc, unsigned short port_num) : _ioc(ioc),&#13;
                                                                          _acceptor(_ioc,&#13;
                                                                                    tcp::endpoint(tcp::v4(),&#13;
                                                                                                  port_num)) {&#13;
    std::cout &lt;&lt; 'Acceptor create succeed! port number is ' &lt;&lt; port_num &lt;&lt; std::endl;&#13;
    start_accept();&#13;
}&#13;
&#13;
void CServer::start_accept() {&#13;
    // 使用智能指针来管理 session 实例，以保证不会二次析构&#13;
    std::shared_ptr&lt;CSession&gt; newSession = std::make_shared&lt;CSession&gt;(_ioc, this);&#13;
    // 绑定到服务上，新连接到来后触发回调函数 handle_accept&#13;
    _acceptor.async_accept(newSession-&gt;get_socket(),&#13;
                           std::bind(&amp;CServer::handle_accept, this, newSession, std::placeholders::_1));&#13;
&#13;
}&#13;
&#13;
void CServer::handle_accept(std::shared_ptr&lt;CSession&gt; newSession, const boost::system::error_code errorCode) {&#13;
    if (errorCode.value() != 0) {&#13;
        std::cerr &lt;&lt; 'Error occurred int accept connection: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
//        delete newSession;&#13;
    } else {&#13;
        std::cout &lt;&lt; 'Accept connection successfully ' &lt;&lt; std::endl;&#13;
        std::cout &lt;&lt; 'Start dealing with data' &lt;&lt; std::endl;&#13;
        // 没问题就开始处理数据&#13;
        newSession-&gt;start();&#13;
        _sessions.insert(std::make_pair(newSession-&gt;get_uuid(), newSession));&#13;
    }&#13;
    // 继续接收新连接&#13;
    start_accept();&#13;
}&#13;
&#13;
void CServer::clear_session(std::string uuid) {&#13;
    _sessions.erase(uuid);&#13;
}&#13;
```&#13;
&#13;
CSession.h&#13;
&#13;
```cpp&#13;
#ifndef ASYNCSERVER_CSESSION_H&#13;
#define ASYNCSERVER_CSESSION_H&#13;
&#13;
#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;map&gt;&#13;
#include &lt;boost/uuid/uuid_generators.hpp&gt;&#13;
#include &lt;boost/uuid/uuid_io.hpp&gt;&#13;
#include 'CServer.h'&#13;
#include &lt;queue&gt;&#13;
#include 'global.h'&#13;
using namespace boost::asio::ip;&#13;
&#13;
class MsgNode;&#13;
&#13;
class CServer;&#13;
&#13;
/**&#13;
 * 处理客户端消息收发&#13;
 */&#13;
class CSession : public std::enable_shared_from_this&lt;CSession&gt; {&#13;
public:&#13;
    tcp::socket &amp;get_socket() { return _socket; };&#13;
&#13;
    explicit CSession(boost::asio::io_context &amp;ioc, CServer *server);;&#13;
&#13;
    // 开始处理&#13;
    void start();&#13;
&#13;
    // 获取 uuid&#13;
    std::string &amp;get_uuid() {&#13;
        return _uuid;&#13;
    }&#13;
&#13;
    /**&#13;
     * 发送接口&#13;
     * @param msg&#13;
     * @param max_length&#13;
     */&#13;
    void send(char *msg, int max_length);&#13;
&#13;
    void send(std::string msg);&#13;
private:&#13;
    // 写的回调函数&#13;
    void handle_write(const boost::system::error_code &amp;errorCode, std::shared_ptr&lt;CSession&gt; self_shared);&#13;
&#13;
    // 读的回调函数&#13;
    void handle_read(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                     std::shared_ptr&lt;CSession&gt; self_shared);&#13;
&#13;
    /**&#13;
     * 读取包头的回调函数&#13;
     * @param errorCode&#13;
     * @param bytes_transferred&#13;
     * @param self_shared&#13;
     */&#13;
    void handle_read_head(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                          std::shared_ptr&lt;CSession&gt; self_shared);&#13;
&#13;
    /**&#13;
     * 读取包体的回调函数&#13;
     * @param errorCode&#13;
     * @param bytes_transferred&#13;
     * @param self_shared&#13;
     */&#13;
    void handle_read_msg(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                          std::shared_ptr&lt;CSession&gt; self_shared);&#13;
    // 打印收到的二进制数据&#13;
    void printRecvData(char* data, int length);&#13;
    // 传输信息的 socket&#13;
    tcp::socket _socket;&#13;
    // 保存数据&#13;
&#13;
    char _data[MAX_LENGTH];&#13;
    // 隶属于哪个 server&#13;
    CServer *_server;&#13;
    // uuid&#13;
    std::string _uuid;&#13;
    // 发送队列&#13;
    std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;&#13;
    // 互斥锁，防止多个线程同时操作队列&#13;
    std::mutex _send_lock;&#13;
&#13;
    //收到的消息结构&#13;
    std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;&#13;
    // 标记头部结构是否接收完毕&#13;
    bool _b_head_parse;&#13;
    //收到的头部结构&#13;
    std::shared_ptr&lt;MsgNode&gt; _recv_head_node;&#13;
};&#13;
&#13;
/**&#13;
 * 消息结点&#13;
 */&#13;
class MsgNode {&#13;
    friend class CSession;&#13;
&#13;
public:&#13;
    MsgNode(const char *msg, short max_len) : _total_len(max_len + HEAD_LENGTH), _cur_len(0) {&#13;
        _data = new char[_total_len + 1];&#13;
        // 包头字节序转换&#13;
        int max_len_host = boost::asio::detail::socket_ops::host_to_network_short(max_len);&#13;
        // 记录长度&#13;
        memcpy(_data, &amp;max_len_host, HEAD_LENGTH);&#13;
        // 拷贝数据&#13;
        memcpy(_data + HEAD_LENGTH, msg, max_len);&#13;
        _data[_total_len] = '\0';&#13;
    }&#13;
&#13;
    MsgNode(short max_len) : _total_len(max_len), _cur_len(0) {&#13;
        _data = new char[_total_len + 1];&#13;
    }&#13;
&#13;
    void clear() {&#13;
        memset(_data, 0, _total_len);&#13;
        _cur_len = 0;&#13;
    }&#13;
&#13;
    ~MsgNode() {&#13;
        delete[] _data;&#13;
    }&#13;
&#13;
private:&#13;
    int _cur_len;&#13;
    int _total_len;&#13;
    char *_data;&#13;
};&#13;
&#13;
#endif //ASYNCSERVER_CSESSION_H&#13;
```&#13;
&#13;
CSession.cpp&#13;
&#13;
```cpp&#13;
#include &lt;iostream&gt;&#13;
#include &lt;iomanip&gt;&#13;
#include &lt;thread&gt;&#13;
#include 'CSession.h'&#13;
#include 'proto/msg.pb.h'&#13;
#include &lt;json/json.h&gt;&#13;
#include &lt;json/value.h&gt;&#13;
#include &lt;json/reader.h&gt;&#13;
&#13;
CSession::CSession(boost::asio::io_context &amp;ioc, CServer *server) : _socket(ioc), _server(server),&#13;
                                                                    _b_head_parse(false) {&#13;
    std::memset(_data, '\0', MAX_LENGTH);&#13;
    // 生成 uuid&#13;
    boost::uuids::uuid a_uuid = boost::uuids::random_generator()();&#13;
    _uuid = boost::uuids::to_string(a_uuid);&#13;
    _recv_head_node = std::make_shared&lt;MsgNode&gt;(HEAD_LENGTH);&#13;
}&#13;
&#13;
void CSession::start() {&#13;
    std::cout &lt;&lt; 'First read from client\n';&#13;
    // 先在客户端读取&#13;
//    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
//                            std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2,&#13;
//                                      shared_from_this()));&#13;
    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node-&gt;_data, HEAD_LENGTH),&#13;
                            std::bind(&amp;CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,&#13;
                                      shared_from_this()));&#13;
}&#13;
&#13;
void CSession::handle_read(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                           std::shared_ptr&lt;CSession&gt; self_shared) {&#13;
    try {&#13;
        if (errorCode.value() != 0) {&#13;
            std::cerr &lt;&lt; 'Error occurred int read: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
            // 移除连接&#13;
            _server-&gt;clear_session(_uuid);&#13;
            return;&#13;
        }&#13;
        // 测试粘包&#13;
        printRecvData(_data, bytes_transferred);&#13;
        std::chrono::milliseconds dura(2000);&#13;
        std::this_thread::sleep_for(dura);&#13;
&#13;
        while (bytes_transferred &gt; 0) {&#13;
            // 记录已经处理的字节&#13;
            int copy_len = 0;&#13;
            if (!_b_head_parse) {&#13;
                // 头部结构还没处理完&#13;
                // 收到的数据比头部结构小&#13;
                if (bytes_transferred &lt; HEAD_LENGTH) {&#13;
                    // 先接收这部分数据&#13;
                    memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);&#13;
                    _recv_head_node-&gt;_cur_len += bytes_transferred;&#13;
                    // 清空 _data 缓冲区&#13;
                    memset(_data, 0, MAX_LENGTH);&#13;
                    // 继续监听&#13;
                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                            std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                      std::placeholders::_2, self_shared));&#13;
                    return;&#13;
                }&#13;
                // 收到的数据比头部结构大&#13;
                int head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;&#13;
                // 剩余的数据拷贝进去&#13;
                memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);&#13;
                _recv_head_node-&gt;_cur_len += head_remain;&#13;
                copy_len += head_remain;&#13;
                bytes_transferred -= head_remain;&#13;
                // 获取头部存储的数据&#13;
                short data_len = 0;&#13;
                memcpy(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);&#13;
                // 网络字节序转换为本地字节序&#13;
                data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);&#13;
&#13;
                std::cout &lt;&lt; 'Receive data length is ' &lt;&lt; data_len &lt;&lt; std::endl;&#13;
                if (data_len &gt; MAX_LENGTH) {&#13;
                    std::cerr &lt;&lt; 'invalid data length is ' &lt;&lt; data_len &lt;&lt; std::endl;&#13;
                    return;&#13;
                }&#13;
&#13;
                _recv_msg_node = std::make_shared&lt;MsgNode&gt;(data_len);&#13;
                // 剩余消息的长度小于数据长度，先将部分数据放到节点里&#13;
                if (bytes_transferred &lt; data_len) {&#13;
                    memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);&#13;
                    _recv_msg_node-&gt;_cur_len += bytes_transferred;&#13;
                    // 重置 _data&#13;
                    memset(_data, 0, MAX_LENGTH);&#13;
                    // 继续监听&#13;
                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                            std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                      std::placeholders::_2, self_shared));&#13;
                    // 头部处理完毕&#13;
                    _b_head_parse = true;&#13;
                    return;&#13;
                }&#13;
                // 大于直接拷贝进去&#13;
                memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);&#13;
                _recv_msg_node-&gt;_cur_len += data_len;&#13;
                copy_len += data_len;&#13;
                bytes_transferred -= data_len;&#13;
                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = '\0';&#13;
                // 调用 send 测试&#13;
//                MsgData msgData;&#13;
//                std::string receive_data;&#13;
//                msgData.ParseFromString(std::string(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len));&#13;
//                std::cout &lt;&lt; 'Received msg id  is ' &lt;&lt; msgData.id() &lt;&lt; ' msg data is ' &lt;&lt; msgData.data() &lt;&lt;std:: endl;&#13;
//                std::string return_str = 'Server has received msg, msg data is ' + msgData.data();&#13;
//                MsgData msgReturn;&#13;
//                msgReturn.set_id(msgData.id());&#13;
//                msgReturn.set_data(return_str);&#13;
//                msgReturn.SerializeToString(&amp;return_str);&#13;
//                send(return_str);&#13;
//                Json::Reader reader;&#13;
//                Json::Value root;&#13;
//                reader.parse(std::string(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);&#13;
//                std::cout &lt;&lt; 'Received msg id  is ' &lt;&lt; root['id'].asInt() &lt;&lt; ' msg data is ''&#13;
//                          &lt;&lt; root['data'].asString() &lt;&lt; ''' &lt;&lt; std::endl;&#13;
//                root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';&#13;
//                send(root.toStyledString());&#13;
                send(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len);&#13;
                // 继续处理剩下的字节&#13;
                _b_head_parse = false;&#13;
                _recv_head_node-&gt;clear();&#13;
                // 如果小于等于0，其实只能等于&#13;
                if (bytes_transferred &lt;= 0) {&#13;
                    // 需要继续监听&#13;
                    memset(_data, 0, MAX_LENGTH);&#13;
                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                            std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                      std::placeholders::_2, self_shared));&#13;
                    return;&#13;
                }&#13;
                // 继续循环即可&#13;
                continue;&#13;
            }&#13;
            // 头结点处理完了，接着处理数据&#13;
            int remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;&#13;
            // 本次接收的还是不足&#13;
            if (bytes_transferred &lt; remain_msg) {&#13;
                // 拷贝部分，继续监听&#13;
                memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);&#13;
                _recv_msg_node-&gt;_cur_len += bytes_transferred;&#13;
                memset(_data, 0, MAX_LENGTH);&#13;
                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                  std::placeholders::_2, self_shared));&#13;
                return;&#13;
            }&#13;
            // 足够就直接拷进来&#13;
            memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);&#13;
            _recv_msg_node-&gt;_cur_len += remain_msg;&#13;
            copy_len += remain_msg;&#13;
            bytes_transferred -= remain_msg;&#13;
            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = '\0';&#13;
            // 调用 send 测试&#13;
//            MsgData msgData;&#13;
//            std::string receive_data;&#13;
//            msgData.ParseFromString(std::string(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len));&#13;
//            std::cout &lt;&lt; 'Received msg id  is ' &lt;&lt; msgData.id() &lt;&lt; ' msg data is ' &lt;&lt; msgData.data() &lt;&lt;std:: endl;&#13;
//            std::string return_str = 'Server has received msg, msg data is ' + msgData.data();&#13;
//            MsgData msgReturn;&#13;
//            msgReturn.set_id(msgData.id());&#13;
//            msgReturn.set_data(return_str);&#13;
//            msgReturn.SerializeToString(&amp;return_str);&#13;
//            send(return_str);&#13;
&#13;
//            Json::Reader reader;&#13;
//            Json::Value root;&#13;
//            reader.parse(std::string(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);&#13;
//            std::cout &lt;&lt; 'Received msg id  is ' &lt;&lt; root['id'].asInt() &lt;&lt; ' msg data is ''&#13;
//                      &lt;&lt; root['data'].asString() &lt;&lt; ''' &lt;&lt; std::endl;&#13;
//            root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';&#13;
//            send(root.toStyledString());&#13;
            send(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len);&#13;
&#13;
            // 继续处理&#13;
            _b_head_parse = false;&#13;
            _recv_head_node-&gt;clear();&#13;
&#13;
            // 不剩下数据了&#13;
            if (bytes_transferred &lt;= 0) {&#13;
                memset(_data, 0, MAX_LENGTH);&#13;
                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                  std::placeholders::_2, self_shared));&#13;
                return;&#13;
            }&#13;
            // 继续循环即可&#13;
            continue;&#13;
        }&#13;
    } catch (std::exception &amp;e) {&#13;
        std::cerr &lt;&lt; 'Error occurred: ' &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
    }&#13;
}&#13;
&#13;
void CSession::handle_write(const boost::system::error_code &amp;errorCode, std::shared_ptr&lt;CSession&gt; self_shared) {&#13;
    try {&#13;
        if (errorCode.value() != 0) {&#13;
            std::cerr &lt;&lt; 'Error occurred int write: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
            // 移除连接&#13;
            _server-&gt;clear_session(_uuid);&#13;
            return;&#13;
        }&#13;
        std::cout &lt;&lt; 'Writing to client successfully, start read from client\n';&#13;
&#13;
        // 调用回调函数表示已经写完&#13;
        // 上锁&#13;
        std::lock_guard&lt;std::mutex&gt; lock(_send_lock);&#13;
        // 弹出队列元素&#13;
        _send_que.pop();&#13;
        // 队列是否还有剩下的消息&#13;
        if (!_send_que.empty()) {&#13;
            // 接着发，直到队列为空&#13;
            auto &amp;msgNode = _send_que.front();&#13;
            boost::asio::async_write(_socket, boost::asio::buffer(msgNode-&gt;_data, msgNode-&gt;_total_len),&#13;
                                     std::bind(&amp;CSession::handle_write, this, std::placeholders::_1, self_shared));&#13;
        }&#13;
    } catch (std::exception &amp;e) {&#13;
        std::cerr &lt;&lt; 'Error occurred: ' &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
    }&#13;
}&#13;
&#13;
void CSession::send(char *msg, int max_length) {&#13;
    // 发送队列里是否还有没法完的数据&#13;
    bool pending = false;&#13;
    // 上锁&#13;
    std::lock_guard&lt;std::mutex&gt; lock(_send_lock);&#13;
    int send_que_size = _send_que.size();&#13;
    if (send_que_size &gt; MAX_SENDQUE) {&#13;
        std::cout &lt;&lt; 'session: ' &lt;&lt; _uuid &lt;&lt; ' send que fulled, size is ' &lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;&#13;
        return;&#13;
    }&#13;
&#13;
    // 加入发送队列&#13;
    _send_que.push(std::make_shared&lt;MsgNode&gt;(msg, max_length));&#13;
&#13;
    if (send_que_size &gt; 0) {&#13;
        // 之前的还没发送完&#13;
        return;&#13;
    }&#13;
    auto &amp;msgNode = _send_que.front();&#13;
    // 之前的全发完了，直接发本次的&#13;
    boost::asio::async_write(_socket, boost::asio::buffer(msgNode-&gt;_data, msgNode-&gt;_total_len),&#13;
                             std::bind(&amp;CSession::handle_write, this, std::placeholders::_1, shared_from_this()));&#13;
}&#13;
&#13;
// 打印二进制数据&#13;
void CSession::printRecvData(char *data, int length) {&#13;
    std::stringstream ss;&#13;
    std::string result = '0x';&#13;
    for (int i = 0; i &lt; length; i++) {&#13;
        std::string hexstr;&#13;
        ss &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; int(data[i]) &lt;&lt; std::endl;&#13;
        ss &gt;&gt; hexstr;&#13;
        result += hexstr;&#13;
    }&#13;
    std::cout &lt;&lt; 'receive raw data is : ' &lt;&lt; result &lt;&lt; std::endl;;&#13;
}&#13;
&#13;
void CSession::send(std::string msg) {&#13;
    std::lock_guard&lt;std::mutex&gt; lock(_send_lock);&#13;
&#13;
    int send_que_size = _send_que.size();&#13;
    if (send_que_size &gt; MAX_SENDQUE) {&#13;
        std::cout &lt;&lt; 'session: ' &lt;&lt; _uuid &lt;&lt; ' send que fulled, size is ' &lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;&#13;
        return;&#13;
    }&#13;
    _send_que.push(std::make_shared&lt;MsgNode&gt;(msg.c_str(), msg.size()));&#13;
    if (send_que_size &gt; 0) {&#13;
        return;&#13;
    }&#13;
    auto &amp;msgNode = _send_que.front();&#13;
    boost::asio::async_write(_socket, boost::asio::buffer(msgNode-&gt;_data, msgNode-&gt;_total_len),&#13;
                             std::bind(&amp;CSession::handle_write, this, std::placeholders::_1, shared_from_this()));&#13;
}&#13;
&#13;
void CSession::handle_read_head(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                                std::shared_ptr&lt;CSession&gt; self_shared) {&#13;
    if (errorCode.value() != 0) {&#13;
        std::cerr &lt;&lt; 'Error occurred in read head: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
        // 移除连接&#13;
        _server-&gt;clear_session(_uuid);&#13;
        return;&#13;
    }&#13;
    if (bytes_transferred &lt; HEAD_LENGTH) {&#13;
        std::cerr &lt;&lt; 'Error occurred in read head: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
        // 移除连接&#13;
        _server-&gt;clear_session(_uuid);&#13;
        return;&#13;
    }&#13;
    // 解析包头数据&#13;
    short data_len = 0;&#13;
    memcpy(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);&#13;
    // 字节序处理&#13;
    data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);&#13;
    if (data_len &gt; MAX_LENGTH) {&#13;
        std::cerr &lt;&lt; 'Invalid data length :' &lt;&lt; data_len &lt;&lt; std::endl;&#13;
        _server-&gt;clear_session(_uuid);&#13;
        return;&#13;
    }&#13;
&#13;
&#13;
    _recv_msg_node = std::make_shared&lt;MsgNode&gt;(data_len);&#13;
&#13;
    boost::asio::async_read(_socket, boost::asio::buffer(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len),&#13;
                            std::bind(&amp;CSession::handle_read_msg, this, std::placeholders::_1, std::placeholders::_2,&#13;
                                      shared_from_this()));&#13;
}&#13;
&#13;
void CSession::handle_read_msg(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                               std::shared_ptr&lt;CSession&gt; self_shared) {&#13;
    if (errorCode.value() != 0) {&#13;
        std::cerr &lt;&lt; 'Error occurred in read msg: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
        // 移除连接&#13;
        _server-&gt;clear_session(_uuid);&#13;
        return;&#13;
    }&#13;
    // 测试粘包&#13;
    printRecvData(_recv_msg_node-&gt;_data, bytes_transferred);&#13;
    std::chrono::milliseconds dura(2000);&#13;
    std::this_thread::sleep_for(dura);&#13;
    _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = '\0';&#13;
    std::cout &lt;&lt; 'receive data is ' &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;&#13;
    send(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);&#13;
    // 再次接收头部数据&#13;
    _recv_head_node-&gt;clear();&#13;
    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node-&gt;_data, HEAD_LENGTH),&#13;
                            std::bind(&amp;CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,&#13;
                                      shared_from_this()));&#13;
}&#13;
```。</description><guid isPermaLink="true">https://proacane.github.io/post/Asio-wang-luo-ku-zhai-yao.html</guid><pubDate>Mon, 23 Sep 2024 05:46:54 +0000</pubDate></item></channel></rss>