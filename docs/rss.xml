<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Proacane的个人微博</title><link>https://proacane.github.io</link><description>学无止境</description><copyright>Proacane的个人微博</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.com/proacane/proacane.github.io/blob/main/avatar.jpg?raw=true</url><title>avatar</title><link>https://proacane.github.io</link></image><lastBuildDate>Thu, 26 Sep 2024 07:28:17 +0000</lastBuildDate><managingEditor>Proacane的个人微博</managingEditor><ttl>60</ttl><webMaster>Proacane的个人微博</webMaster><item><title>操作系统概述</title><link>https://proacane.github.io/post/cao-zuo-xi-tong-gai-shu.html</link><description># 操作系统的概念&#13;
操作系统（Operating System， OS）是指控制和**管理**整个计算机系统的**硬件和软件**资源，并合理地组织调度计算机的工作和资源的分配；以**提供给用户和其他软件方便的接口和环境**；它是计算机系统中**最基本的系统软件**&#13;
# 特征&#13;
操作系统的4个特征：&#13;
1. 并发&#13;
2. 共享&#13;
3. 虚拟&#13;
4. 异步&#13;
其中，并发、共享是操作系统最基本的特征，并且二者相互依存&#13;
## 并发&#13;
并发是指两个或多个事件在同一时间间隔内发生，在宏观看来是同时发生的，但是微观上是交替运行的；&#13;
操作系统的并发指的是可以同时存在多个运行的程序&#13;
并行：指多个事件在同一时刻同时发生&#13;
单核 cpu 同一时刻只能运行一个进程，只能并发&#13;
多核 cpu 同一时刻可以运行多个进程，既存在并发、也存在并行&#13;
## 共享&#13;
共享：指系统中的资源可以被多个并发执行的进程使用&#13;
互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源，例如摄像头等资源&#13;
同时共享：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问，例如磁盘的读写&#13;
从共享的定义就可以看出来，若操作系统没有并发性，共享就没有意义；没有共享性，并发也没有意义&#13;
## 虚拟&#13;
虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。</description><guid isPermaLink="true">https://proacane.github.io/post/cao-zuo-xi-tong-gai-shu.html</guid><pubDate>Thu, 26 Sep 2024 07:22:55 +0000</pubDate></item><item><title>DS_2：栈</title><link>https://proacane.github.io/post/DS_2%EF%BC%9A-zhan.html</link><description># 栈&#13;
定义：只允许在一端进行操作（插入、删除）的线性表&#13;
基本操作：&#13;
1. 初始化栈&#13;
2. 释放内存&#13;
3. 进栈&#13;
4. 出栈&#13;
5. 获取栈顶元素&#13;
6. 判空&#13;
## 顺序栈&#13;
实现:静态数组中存放栈元素&#13;
```C&#13;
#define Type int&#13;
#define MAX_SIZE 10&#13;
typedef struct Stack {&#13;
    // 存放栈元素&#13;
    Type data[MAX_SIZE];&#13;
    // 栈顶指针&#13;
    int top;&#13;
} Stack;&#13;
&#13;
void initStack(Stack *s) {&#13;
    // 栈为空&#13;
    s-&gt;top = -1;&#13;
}&#13;
&#13;
void destructorStack(Stack *s) {&#13;
    s-&gt;top = -1;&#13;
}&#13;
&#13;
bool isEmpty(Stack *s) {&#13;
    return s-&gt;top == -1;&#13;
}&#13;
&#13;
bool push(Stack *s, Type e) {&#13;
    if (s-&gt;top == MAX_SIZE - 1) {&#13;
        printf('Stack is full');&#13;
        return false;&#13;
    }&#13;
    s-&gt;data[++s-&gt;top] = e;&#13;
    return true;&#13;
}&#13;
&#13;
bool pop(Stack *s) {&#13;
    if (isEmpty(s)) {&#13;
        printf('Stack is empty');&#13;
        return false;&#13;
    }&#13;
    s-&gt;top--;&#13;
    return true;&#13;
}&#13;
&#13;
Type front(Stack*s){&#13;
    if (isEmpty(s)) {&#13;
        printf('Stack is empty');&#13;
        return false;&#13;
    }&#13;
    return s-&gt;data[s-&gt;top];&#13;
}&#13;
```&#13;
也可以将top初始化为0，这样top指向的就是下一个入栈的位置&#13;
## 共享栈&#13;
就是在顺序栈的基础上，再添加一个top标记，将一整片数组空间分为两个栈使用，top0是从数组的索引0向上，top1从数组的最大索引向下；相交的时候就是满了&#13;
&#13;
## 链式栈&#13;
每个元素就是一个链表结点，实现栈的功能就行，也是分为带头结点和不带头结点&#13;
不带头结点:&#13;
```C&#13;
#define Type int&#13;
typedef struct Node {&#13;
    Type data;&#13;
    struct Node *next;&#13;
} Node;&#13;
typedef Node *stack;&#13;
&#13;
void initStack(stack *s) {&#13;
    (*s) = NULL;&#13;
}&#13;
&#13;
void destructor(stack *s) {&#13;
    Node *p = *s;&#13;
    while (p != NULL) {&#13;
        Node *temp = p;&#13;
        p = p-&gt;next;&#13;
        free(temp);&#13;
    }&#13;
    (*s) = NULL;&#13;
}&#13;
&#13;
bool push(stack *s, Type e) {&#13;
    Node *p = *s;&#13;
    Node *newNode = (Node *) malloc(sizeof(Node));&#13;
    if (newNode == NULL) {&#13;
        printf('Failed to allocate memory');&#13;
        return false;&#13;
    }&#13;
    newNode-&gt;data = e;&#13;
    newNode-&gt;next = p;&#13;
    *s = newNode;&#13;
    return true;&#13;
}&#13;
&#13;
bool pop(stack *s) {&#13;
    if (*s == NULL) {&#13;
        printf('Stack is empty\n');&#13;
        return false;&#13;
    }&#13;
    Node *p = *s;&#13;
    (*s) = (*s)-&gt;next;&#13;
    free(p);&#13;
    return true;&#13;
}&#13;
&#13;
Type front(stack *s) {&#13;
    if (*s == NULL) {&#13;
        printf('Stack is empty\n');&#13;
        return -1;&#13;
    }&#13;
    return (*s)-&gt;data;&#13;
}&#13;
```&#13;
带头结点：&#13;
```C&#13;
#define Type int&#13;
typedef struct Node {&#13;
    Type data;&#13;
    struct Node *next;&#13;
} Node;&#13;
typedef Node *stack;&#13;
&#13;
void constructor(stack *s) {&#13;
    // 分配头结点&#13;
    (*s) = (Node *) malloc(sizeof(Node));&#13;
    if (*s == NULL) {&#13;
        printf('Failed to allocate memory');&#13;
        return;&#13;
    }&#13;
    (*s)-&gt;data = -1;&#13;
    (*s)-&gt;next = NULL;&#13;
}&#13;
&#13;
void destructor(stack *s) {&#13;
    if (*s == NULL) {&#13;
        return;&#13;
    }&#13;
    Node *p = *s;&#13;
    while (p != NULL) {&#13;
        Node *temp = p;&#13;
        p = p-&gt;next;&#13;
        free(temp);&#13;
    }&#13;
    (*s) = NULL;&#13;
}&#13;
&#13;
bool push(stack *s, Type e) {&#13;
    if (*s == NULL) {&#13;
        printf('stack is not initialized');&#13;
        return false;&#13;
    }&#13;
    Node *newNode = (Node *) malloc(sizeof(Node));&#13;
    if (newNode == NULL) {&#13;
        printf('Failed to allocate memory');&#13;
        return false;&#13;
    }&#13;
    newNode-&gt;data = e;&#13;
    newNode-&gt;next = (*s)-&gt;next;&#13;
    (*s)-&gt;next = newNode;&#13;
    return true;&#13;
}&#13;
&#13;
bool pop(stack *s) {&#13;
    if ((*s) == NULL || (*s)-&gt;next == NULL) {&#13;
        printf('Stack is empty\n');&#13;
        return false;&#13;
    }&#13;
    Node *p = (*s)-&gt;next;&#13;
    (*s)-&gt;next = p-&gt;next;&#13;
    free(p);&#13;
    return true;&#13;
}&#13;
&#13;
Type front(stack *s) {&#13;
    if ((*s) == NULL || (*s)-&gt;next == NULL) {&#13;
        printf('Stack is empty\n');&#13;
        return -1;&#13;
    }&#13;
    return (*s)-&gt;next-&gt;data;&#13;
}&#13;
```&#13;
代码地址：https://github.com/proacane/DataStructure。</description><guid isPermaLink="true">https://proacane.github.io/post/DS_2%EF%BC%9A-zhan.html</guid><pubDate>Thu, 26 Sep 2024 06:31:05 +0000</pubDate></item><item><title>DS_1：线性表</title><link>https://proacane.github.io/post/DS_1%EF%BC%9A-xian-xing-biao.html</link><description># 线性表&#13;
线性表是具有相同数据类型的n（n≥0）个数据元素的**有限序列**，其中n为表长，当n = 0时线性表是一个空表。</description><guid isPermaLink="true">https://proacane.github.io/post/DS_1%EF%BC%9A-xian-xing-biao.html</guid><pubDate>Mon, 23 Sep 2024 08:20:56 +0000</pubDate></item><item><title>Asio协程</title><link>https://proacane.github.io/post/Asio-xie-cheng.html</link><description># 协程&#13;
协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</description><guid isPermaLink="true">https://proacane.github.io/post/Asio-xie-cheng.html</guid><pubDate>Mon, 23 Sep 2024 06:04:56 +0000</pubDate></item><item><title>Grpc</title><link>https://proacane.github.io/post/Grpc.html</link><description># 下载&#13;
&#13;
vcpkg install grpc&#13;
&#13;
# 配置&#13;
&#13;
cmake 中：&#13;
&#13;
```cmake&#13;
find_package(Protobuf CONFIG REQUIRED)&#13;
find_package(gRPC CONFIG REQUIRED)&#13;
include_directories(${CMAKE_CURRENT_BINARY_DIR})&#13;
arget_link_libraries(${projectName} PRIVATE gRPC::grpc++ protobuf::libprotobuf)&#13;
```&#13;
&#13;
# 编译&#13;
&#13;
编写好 proto文件，在 powershell 中使用如下命令，插件选择自己的路径：&#13;
&#13;
```cmd&#13;
protoc --proto_path=. --cpp_out=. demo.proto&#13;
protoc --proto_path=. --grpc_out=. --plugin=protoc-gen-grpc='D:\develop_tools\cppsoft\vcpkg\packages\grpc_x64-windows\tools\grpc\grpc_cpp_plugin.exe' demo.proto&#13;
```&#13;
&#13;
生成文件添加到 cmakelists.txt 中&#13;
&#13;
# 通信流程&#13;
&#13;
1. 连接到服务端的地址&#13;
2. 创建客户端实例，调用函数，将请求消息发送给服务端&#13;
3. 服务端接收到请求，处理请求消息并生成响应消息。</description><guid isPermaLink="true">https://proacane.github.io/post/Grpc.html</guid><pubDate>Mon, 23 Sep 2024 06:03:31 +0000</pubDate></item><item><title>Beast实现websocket服务器</title><link>https://proacane.github.io/post/Beast-shi-xian-websocket-fu-wu-qi.html</link><description># 流对象&#13;
&#13;
WebSocket连接需要一个有状态对象，由Beast中的一个类模板websocket::stream表示。</description><guid isPermaLink="true">https://proacane.github.io/post/Beast-shi-xian-websocket-fu-wu-qi.html</guid><pubDate>Mon, 23 Sep 2024 06:01:36 +0000</pubDate></item><item><title>Asio实现Http服务器</title><link>https://proacane.github.io/post/Asio-shi-xian-Http-fu-wu-qi.html</link><description># Http简介&#13;
&#13;
## Http包头信息&#13;
&#13;
一个标准的HTTP报文头通常由请求头和响应头两部分组成。</description><guid isPermaLink="true">https://proacane.github.io/post/Asio-shi-xian-Http-fu-wu-qi.html</guid><pubDate>Mon, 23 Sep 2024 06:00:29 +0000</pubDate></item><item><title>多线程Asio</title><link>https://proacane.github.io/post/duo-xian-cheng-Asio.html</link><description># 多线程模型&#13;
asio 的多线程模型有两种，IOServicePool 和 IOThreadPool&#13;
# IOServicePool&#13;
IOServicePool模型：&#13;
![image-20240801133223177](https://github.com/user-attachments/assets/c036abee-852d-42a7-ab2d-b2acb054f14f)&#13;
特点:&#13;
1. 每个 io_context 都运行在不同的线程内，对于一个 socket，会注册在同一个 io_context 内，并且回调函数的触发也是在同一个线程内，不存在并发安全问题&#13;
2. 不同的 socket，回调函数可能由不同的线程调用，如果回调函数中进行了共享数据的修改，就会存在线程安全问题，这时可以在回调函数中加锁或者使用逻辑队列的方式&#13;
3. 多线程模式极大的提高了并发能力；单线程模式下如果回调函数调用时间过长，会影响后续函数的调用；通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题&#13;
## 实现&#13;
&#13;
本质就是一个线程池，基本功能就是根据构造函数传入的数量创建n个线程和 io_context，然后每个线程跑一个 io_context，这样就可以并发处理不同 io_context 读写事件了。</description><guid isPermaLink="true">https://proacane.github.io/post/duo-xian-cheng-Asio.html</guid><pubDate>Mon, 23 Sep 2024 05:51:27 +0000</pubDate></item><item><title>Asio网络库摘要</title><link>https://proacane.github.io/post/Asio-wang-luo-ku-zhai-yao.html</link><description># 单线程通信流程&#13;
![image-20240726093453475](https://github.com/user-attachments/assets/a53c98fb-c149-403e-b102-d110905e5eb4)&#13;
# 同步读写的示例&#13;
- 服务端&#13;
```cpp&#13;
#include &lt;iostream&gt;&#13;
#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;memory&gt;&#13;
#include &lt;set&gt;&#13;
#include &lt;thread&gt;&#13;
&#13;
using namespace std;&#13;
using namespace boost::asio::ip;&#13;
&#13;
const int MAX_LEN = 1024;&#13;
typedef shared_ptr&lt;tcp::socket&gt; socket_ptr;&#13;
std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt; thread_set;&#13;
&#13;
void session(socket_ptr sock) {&#13;
    try {&#13;
        for (;;) {&#13;
            char data[MAX_LEN];&#13;
            boost::system::error_code error;&#13;
            // 读取客户端发送的内容&#13;
            size_t length = sock-&gt;read_some(boost::asio::buffer(data), error);&#13;
&#13;
            if (error == boost::asio::error::eof) {&#13;
                std::cout &lt;&lt; 'Connection closed by peer\n';&#13;
                break;&#13;
            } else if (error) {&#13;
                throw boost::system::system_error(error);&#13;
            }&#13;
&#13;
            std::string received_message(data, length);&#13;
            std::cout &lt;&lt; 'Received from ' &lt;&lt; sock-&gt;remote_endpoint().address().to_string() &lt;&lt; ': ' &lt;&lt; received_message &lt;&lt; std::endl;&#13;
&#13;
            // 转换为 大写&#13;
            // Process the received message (e.g., convert to upper case)&#13;
            std::transform(received_message.begin(), received_message.end(), received_message.begin(), ::toupper);&#13;
            // 再写回客户端&#13;
            boost::asio::write(*sock, boost::asio::buffer(received_message));&#13;
        }&#13;
    } catch (exception &amp;e) {&#13;
        std::cerr &lt;&lt; 'Exception in thread: ' &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
    }&#13;
}&#13;
&#13;
// 建立连接&#13;
void server(boost::asio::io_context &amp;ios, unsigned short port_num) {&#13;
    boost::asio::ip::tcp::acceptor acceptor(ios, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port_num));&#13;
    std::cout &lt;&lt; 'Server started on port ' &lt;&lt; port_num &lt;&lt; std::endl;&#13;
    // 没连接就一直阻塞&#13;
    for (;;) {&#13;
        socket_ptr socket(new tcp::socket(ios));&#13;
        acceptor.accept(*socket);&#13;
        std::cout &lt;&lt; 'Accepted connection from ' &lt;&lt; socket-&gt;remote_endpoint().address().to_string() &lt;&lt; std::endl;&#13;
        // 为连接创建一个线程，开始通信&#13;
        auto t = make_shared&lt;std::thread&gt;(session, socket);&#13;
        thread_set.insert(t);&#13;
    }&#13;
}&#13;
&#13;
int main() {&#13;
    try {&#13;
        boost::asio::io_context ios;&#13;
        server(ios, 1234);&#13;
        // 防止有数据未传输完时，主线程就结束了&#13;
        for (auto &amp;t: thread_set) {&#13;
            t-&gt;join();&#13;
        }&#13;
    } catch (exception &amp;e) {&#13;
        std::cerr &lt;&lt; 'Exception in main thread: ' &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
    }&#13;
&#13;
    return 0;&#13;
}&#13;
```&#13;
# 异步读写示例&#13;
![image-20240726095026183](https://github.com/user-attachments/assets/bd621b55-b962-4eaf-9488-5bb8f7c47f79)&#13;
## 注意的问题&#13;
&#13;
- 异常处理时，为防止 Session 二次析构，需要继承 std::enable_shared_from_this&lt;CSession&gt;；使用智能指针与 map 延长 Session 的生命周期&#13;
&#13;
- 发送消息时，为保证消息的有序性，需要增加发送队列&#13;
&#13;
- 处理粘包问题，消息结构采用 TLV 格式，使用 async_read_some 比较麻烦，使用 async_read 比较简洁&#13;
&#13;
  ​							![image-20240726093831093](https://github.com/user-attachments/assets/45a3e63d-53d6-4124-b647-d9742bc9897e)&#13;
&#13;
  - async_read_some：回调函数里不断判断已经处理的字节&#13;
&#13;
  - async_read：两层回调，第一层处理包头，第二层处理包体&#13;
&#13;
- 字节序的处理：发送前转换为网络字节序，接收后转换为本地字节序 (boost::asio::detail::socket_ops::network_to_host_short)&#13;
- 发送数据使用jsoncpp进行封装&#13;
&#13;
CServer.h&#13;
&#13;
```cpp&#13;
#ifndef ASYNCSERVER_CSERVER_H&#13;
#define ASYNCSERVER_CSERVER_H&#13;
#include 'CSession.h'&#13;
#include &lt;iostream&gt;&#13;
class CSession;&#13;
/**&#13;
 * 接受新的客户端连接，每个连接都会创建一个新的 Session 实例&#13;
 */&#13;
class CServer {&#13;
public:&#13;
    CServer(boost::asio::io_context &amp;ioc, unsigned short port_num);&#13;
    // 移除已处理完成的 Session 实例&#13;
    void clear_session(std::string uuid);&#13;
private:&#13;
    // 创建一个新的 Session 并等待新的客户端连接&#13;
    void start_accept();&#13;
    // 处理新的客户端连接，将其加入 _sessions 中，并启动数据处理&#13;
    void handle_accept(std::shared_ptr&lt;CSession&gt; newSession, const boost::system::error_code errorCode);&#13;
&#13;
    boost::asio::io_context &amp;_ioc;&#13;
    boost::asio::ip::tcp::acceptor _acceptor;&#13;
    // 管理连接&#13;
    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; _sessions;&#13;
&#13;
};&#13;
#endif //ASYNCSERVER_CSERVER_H&#13;
```&#13;
&#13;
CServer.cpp&#13;
&#13;
```cpp&#13;
#include 'CServer.h'&#13;
&#13;
CServer::CServer(boost::asio::io_context &amp;ioc, unsigned short port_num) : _ioc(ioc),&#13;
                                                                          _acceptor(_ioc,&#13;
                                                                                    tcp::endpoint(tcp::v4(),&#13;
                                                                                                  port_num)) {&#13;
    std::cout &lt;&lt; 'Acceptor create succeed! port number is ' &lt;&lt; port_num &lt;&lt; std::endl;&#13;
    start_accept();&#13;
}&#13;
&#13;
void CServer::start_accept() {&#13;
    // 使用智能指针来管理 session 实例，以保证不会二次析构&#13;
    std::shared_ptr&lt;CSession&gt; newSession = std::make_shared&lt;CSession&gt;(_ioc, this);&#13;
    // 绑定到服务上，新连接到来后触发回调函数 handle_accept&#13;
    _acceptor.async_accept(newSession-&gt;get_socket(),&#13;
                           std::bind(&amp;CServer::handle_accept, this, newSession, std::placeholders::_1));&#13;
&#13;
}&#13;
&#13;
void CServer::handle_accept(std::shared_ptr&lt;CSession&gt; newSession, const boost::system::error_code errorCode) {&#13;
    if (errorCode.value() != 0) {&#13;
        std::cerr &lt;&lt; 'Error occurred int accept connection: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
//        delete newSession;&#13;
    } else {&#13;
        std::cout &lt;&lt; 'Accept connection successfully ' &lt;&lt; std::endl;&#13;
        std::cout &lt;&lt; 'Start dealing with data' &lt;&lt; std::endl;&#13;
        // 没问题就开始处理数据&#13;
        newSession-&gt;start();&#13;
        _sessions.insert(std::make_pair(newSession-&gt;get_uuid(), newSession));&#13;
    }&#13;
    // 继续接收新连接&#13;
    start_accept();&#13;
}&#13;
&#13;
void CServer::clear_session(std::string uuid) {&#13;
    _sessions.erase(uuid);&#13;
}&#13;
```&#13;
&#13;
CSession.h&#13;
&#13;
```cpp&#13;
#ifndef ASYNCSERVER_CSESSION_H&#13;
#define ASYNCSERVER_CSESSION_H&#13;
&#13;
#include &lt;boost/asio.hpp&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;map&gt;&#13;
#include &lt;boost/uuid/uuid_generators.hpp&gt;&#13;
#include &lt;boost/uuid/uuid_io.hpp&gt;&#13;
#include 'CServer.h'&#13;
#include &lt;queue&gt;&#13;
#include 'global.h'&#13;
using namespace boost::asio::ip;&#13;
&#13;
class MsgNode;&#13;
&#13;
class CServer;&#13;
&#13;
/**&#13;
 * 处理客户端消息收发&#13;
 */&#13;
class CSession : public std::enable_shared_from_this&lt;CSession&gt; {&#13;
public:&#13;
    tcp::socket &amp;get_socket() { return _socket; };&#13;
&#13;
    explicit CSession(boost::asio::io_context &amp;ioc, CServer *server);;&#13;
&#13;
    // 开始处理&#13;
    void start();&#13;
&#13;
    // 获取 uuid&#13;
    std::string &amp;get_uuid() {&#13;
        return _uuid;&#13;
    }&#13;
&#13;
    /**&#13;
     * 发送接口&#13;
     * @param msg&#13;
     * @param max_length&#13;
     */&#13;
    void send(char *msg, int max_length);&#13;
&#13;
    void send(std::string msg);&#13;
private:&#13;
    // 写的回调函数&#13;
    void handle_write(const boost::system::error_code &amp;errorCode, std::shared_ptr&lt;CSession&gt; self_shared);&#13;
&#13;
    // 读的回调函数&#13;
    void handle_read(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                     std::shared_ptr&lt;CSession&gt; self_shared);&#13;
&#13;
    /**&#13;
     * 读取包头的回调函数&#13;
     * @param errorCode&#13;
     * @param bytes_transferred&#13;
     * @param self_shared&#13;
     */&#13;
    void handle_read_head(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                          std::shared_ptr&lt;CSession&gt; self_shared);&#13;
&#13;
    /**&#13;
     * 读取包体的回调函数&#13;
     * @param errorCode&#13;
     * @param bytes_transferred&#13;
     * @param self_shared&#13;
     */&#13;
    void handle_read_msg(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                          std::shared_ptr&lt;CSession&gt; self_shared);&#13;
    // 打印收到的二进制数据&#13;
    void printRecvData(char* data, int length);&#13;
    // 传输信息的 socket&#13;
    tcp::socket _socket;&#13;
    // 保存数据&#13;
&#13;
    char _data[MAX_LENGTH];&#13;
    // 隶属于哪个 server&#13;
    CServer *_server;&#13;
    // uuid&#13;
    std::string _uuid;&#13;
    // 发送队列&#13;
    std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_que;&#13;
    // 互斥锁，防止多个线程同时操作队列&#13;
    std::mutex _send_lock;&#13;
&#13;
    //收到的消息结构&#13;
    std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;&#13;
    // 标记头部结构是否接收完毕&#13;
    bool _b_head_parse;&#13;
    //收到的头部结构&#13;
    std::shared_ptr&lt;MsgNode&gt; _recv_head_node;&#13;
};&#13;
&#13;
/**&#13;
 * 消息结点&#13;
 */&#13;
class MsgNode {&#13;
    friend class CSession;&#13;
&#13;
public:&#13;
    MsgNode(const char *msg, short max_len) : _total_len(max_len + HEAD_LENGTH), _cur_len(0) {&#13;
        _data = new char[_total_len + 1];&#13;
        // 包头字节序转换&#13;
        int max_len_host = boost::asio::detail::socket_ops::host_to_network_short(max_len);&#13;
        // 记录长度&#13;
        memcpy(_data, &amp;max_len_host, HEAD_LENGTH);&#13;
        // 拷贝数据&#13;
        memcpy(_data + HEAD_LENGTH, msg, max_len);&#13;
        _data[_total_len] = '\0';&#13;
    }&#13;
&#13;
    MsgNode(short max_len) : _total_len(max_len), _cur_len(0) {&#13;
        _data = new char[_total_len + 1];&#13;
    }&#13;
&#13;
    void clear() {&#13;
        memset(_data, 0, _total_len);&#13;
        _cur_len = 0;&#13;
    }&#13;
&#13;
    ~MsgNode() {&#13;
        delete[] _data;&#13;
    }&#13;
&#13;
private:&#13;
    int _cur_len;&#13;
    int _total_len;&#13;
    char *_data;&#13;
};&#13;
&#13;
#endif //ASYNCSERVER_CSESSION_H&#13;
```&#13;
&#13;
CSession.cpp&#13;
&#13;
```cpp&#13;
#include &lt;iostream&gt;&#13;
#include &lt;iomanip&gt;&#13;
#include &lt;thread&gt;&#13;
#include 'CSession.h'&#13;
#include 'proto/msg.pb.h'&#13;
#include &lt;json/json.h&gt;&#13;
#include &lt;json/value.h&gt;&#13;
#include &lt;json/reader.h&gt;&#13;
&#13;
CSession::CSession(boost::asio::io_context &amp;ioc, CServer *server) : _socket(ioc), _server(server),&#13;
                                                                    _b_head_parse(false) {&#13;
    std::memset(_data, '\0', MAX_LENGTH);&#13;
    // 生成 uuid&#13;
    boost::uuids::uuid a_uuid = boost::uuids::random_generator()();&#13;
    _uuid = boost::uuids::to_string(a_uuid);&#13;
    _recv_head_node = std::make_shared&lt;MsgNode&gt;(HEAD_LENGTH);&#13;
}&#13;
&#13;
void CSession::start() {&#13;
    std::cout &lt;&lt; 'First read from client\n';&#13;
    // 先在客户端读取&#13;
//    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
//                            std::bind(&amp;CSession::handle_read, this, std::placeholders::_1, std::placeholders::_2,&#13;
//                                      shared_from_this()));&#13;
    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node-&gt;_data, HEAD_LENGTH),&#13;
                            std::bind(&amp;CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,&#13;
                                      shared_from_this()));&#13;
}&#13;
&#13;
void CSession::handle_read(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                           std::shared_ptr&lt;CSession&gt; self_shared) {&#13;
    try {&#13;
        if (errorCode.value() != 0) {&#13;
            std::cerr &lt;&lt; 'Error occurred int read: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
            // 移除连接&#13;
            _server-&gt;clear_session(_uuid);&#13;
            return;&#13;
        }&#13;
        // 测试粘包&#13;
        printRecvData(_data, bytes_transferred);&#13;
        std::chrono::milliseconds dura(2000);&#13;
        std::this_thread::sleep_for(dura);&#13;
&#13;
        while (bytes_transferred &gt; 0) {&#13;
            // 记录已经处理的字节&#13;
            int copy_len = 0;&#13;
            if (!_b_head_parse) {&#13;
                // 头部结构还没处理完&#13;
                // 收到的数据比头部结构小&#13;
                if (bytes_transferred &lt; HEAD_LENGTH) {&#13;
                    // 先接收这部分数据&#13;
                    memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);&#13;
                    _recv_head_node-&gt;_cur_len += bytes_transferred;&#13;
                    // 清空 _data 缓冲区&#13;
                    memset(_data, 0, MAX_LENGTH);&#13;
                    // 继续监听&#13;
                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                            std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                      std::placeholders::_2, self_shared));&#13;
                    return;&#13;
                }&#13;
                // 收到的数据比头部结构大&#13;
                int head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;&#13;
                // 剩余的数据拷贝进去&#13;
                memcpy(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);&#13;
                _recv_head_node-&gt;_cur_len += head_remain;&#13;
                copy_len += head_remain;&#13;
                bytes_transferred -= head_remain;&#13;
                // 获取头部存储的数据&#13;
                short data_len = 0;&#13;
                memcpy(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);&#13;
                // 网络字节序转换为本地字节序&#13;
                data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);&#13;
&#13;
                std::cout &lt;&lt; 'Receive data length is ' &lt;&lt; data_len &lt;&lt; std::endl;&#13;
                if (data_len &gt; MAX_LENGTH) {&#13;
                    std::cerr &lt;&lt; 'invalid data length is ' &lt;&lt; data_len &lt;&lt; std::endl;&#13;
                    return;&#13;
                }&#13;
&#13;
                _recv_msg_node = std::make_shared&lt;MsgNode&gt;(data_len);&#13;
                // 剩余消息的长度小于数据长度，先将部分数据放到节点里&#13;
                if (bytes_transferred &lt; data_len) {&#13;
                    memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);&#13;
                    _recv_msg_node-&gt;_cur_len += bytes_transferred;&#13;
                    // 重置 _data&#13;
                    memset(_data, 0, MAX_LENGTH);&#13;
                    // 继续监听&#13;
                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                            std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                      std::placeholders::_2, self_shared));&#13;
                    // 头部处理完毕&#13;
                    _b_head_parse = true;&#13;
                    return;&#13;
                }&#13;
                // 大于直接拷贝进去&#13;
                memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);&#13;
                _recv_msg_node-&gt;_cur_len += data_len;&#13;
                copy_len += data_len;&#13;
                bytes_transferred -= data_len;&#13;
                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = '\0';&#13;
                // 调用 send 测试&#13;
//                MsgData msgData;&#13;
//                std::string receive_data;&#13;
//                msgData.ParseFromString(std::string(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len));&#13;
//                std::cout &lt;&lt; 'Received msg id  is ' &lt;&lt; msgData.id() &lt;&lt; ' msg data is ' &lt;&lt; msgData.data() &lt;&lt;std:: endl;&#13;
//                std::string return_str = 'Server has received msg, msg data is ' + msgData.data();&#13;
//                MsgData msgReturn;&#13;
//                msgReturn.set_id(msgData.id());&#13;
//                msgReturn.set_data(return_str);&#13;
//                msgReturn.SerializeToString(&amp;return_str);&#13;
//                send(return_str);&#13;
//                Json::Reader reader;&#13;
//                Json::Value root;&#13;
//                reader.parse(std::string(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);&#13;
//                std::cout &lt;&lt; 'Received msg id  is ' &lt;&lt; root['id'].asInt() &lt;&lt; ' msg data is ''&#13;
//                          &lt;&lt; root['data'].asString() &lt;&lt; ''' &lt;&lt; std::endl;&#13;
//                root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';&#13;
//                send(root.toStyledString());&#13;
                send(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len);&#13;
                // 继续处理剩下的字节&#13;
                _b_head_parse = false;&#13;
                _recv_head_node-&gt;clear();&#13;
                // 如果小于等于0，其实只能等于&#13;
                if (bytes_transferred &lt;= 0) {&#13;
                    // 需要继续监听&#13;
                    memset(_data, 0, MAX_LENGTH);&#13;
                    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                            std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                      std::placeholders::_2, self_shared));&#13;
                    return;&#13;
                }&#13;
                // 继续循环即可&#13;
                continue;&#13;
            }&#13;
            // 头结点处理完了，接着处理数据&#13;
            int remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;&#13;
            // 本次接收的还是不足&#13;
            if (bytes_transferred &lt; remain_msg) {&#13;
                // 拷贝部分，继续监听&#13;
                memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);&#13;
                _recv_msg_node-&gt;_cur_len += bytes_transferred;&#13;
                memset(_data, 0, MAX_LENGTH);&#13;
                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                  std::placeholders::_2, self_shared));&#13;
                return;&#13;
            }&#13;
            // 足够就直接拷进来&#13;
            memcpy(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);&#13;
            _recv_msg_node-&gt;_cur_len += remain_msg;&#13;
            copy_len += remain_msg;&#13;
            bytes_transferred -= remain_msg;&#13;
            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = '\0';&#13;
            // 调用 send 测试&#13;
//            MsgData msgData;&#13;
//            std::string receive_data;&#13;
//            msgData.ParseFromString(std::string(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len));&#13;
//            std::cout &lt;&lt; 'Received msg id  is ' &lt;&lt; msgData.id() &lt;&lt; ' msg data is ' &lt;&lt; msgData.data() &lt;&lt;std:: endl;&#13;
//            std::string return_str = 'Server has received msg, msg data is ' + msgData.data();&#13;
//            MsgData msgReturn;&#13;
//            msgReturn.set_id(msgData.id());&#13;
//            msgReturn.set_data(return_str);&#13;
//            msgReturn.SerializeToString(&amp;return_str);&#13;
//            send(return_str);&#13;
&#13;
//            Json::Reader reader;&#13;
//            Json::Value root;&#13;
//            reader.parse(std::string(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);&#13;
//            std::cout &lt;&lt; 'Received msg id  is ' &lt;&lt; root['id'].asInt() &lt;&lt; ' msg data is ''&#13;
//                      &lt;&lt; root['data'].asString() &lt;&lt; ''' &lt;&lt; std::endl;&#13;
//            root['data'] = 'Server has received msg, msg data is '' + root['data'].asString() + ''';&#13;
//            send(root.toStyledString());&#13;
            send(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len);&#13;
&#13;
            // 继续处理&#13;
            _b_head_parse = false;&#13;
            _recv_head_node-&gt;clear();&#13;
&#13;
            // 不剩下数据了&#13;
            if (bytes_transferred &lt;= 0) {&#13;
                memset(_data, 0, MAX_LENGTH);&#13;
                _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),&#13;
                                        std::bind(&amp;CSession::handle_read, this, std::placeholders::_1,&#13;
                                                  std::placeholders::_2, self_shared));&#13;
                return;&#13;
            }&#13;
            // 继续循环即可&#13;
            continue;&#13;
        }&#13;
    } catch (std::exception &amp;e) {&#13;
        std::cerr &lt;&lt; 'Error occurred: ' &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
    }&#13;
}&#13;
&#13;
void CSession::handle_write(const boost::system::error_code &amp;errorCode, std::shared_ptr&lt;CSession&gt; self_shared) {&#13;
    try {&#13;
        if (errorCode.value() != 0) {&#13;
            std::cerr &lt;&lt; 'Error occurred int write: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
            // 移除连接&#13;
            _server-&gt;clear_session(_uuid);&#13;
            return;&#13;
        }&#13;
        std::cout &lt;&lt; 'Writing to client successfully, start read from client\n';&#13;
&#13;
        // 调用回调函数表示已经写完&#13;
        // 上锁&#13;
        std::lock_guard&lt;std::mutex&gt; lock(_send_lock);&#13;
        // 弹出队列元素&#13;
        _send_que.pop();&#13;
        // 队列是否还有剩下的消息&#13;
        if (!_send_que.empty()) {&#13;
            // 接着发，直到队列为空&#13;
            auto &amp;msgNode = _send_que.front();&#13;
            boost::asio::async_write(_socket, boost::asio::buffer(msgNode-&gt;_data, msgNode-&gt;_total_len),&#13;
                                     std::bind(&amp;CSession::handle_write, this, std::placeholders::_1, self_shared));&#13;
        }&#13;
    } catch (std::exception &amp;e) {&#13;
        std::cerr &lt;&lt; 'Error occurred: ' &lt;&lt; e.what() &lt;&lt; std::endl;&#13;
    }&#13;
}&#13;
&#13;
void CSession::send(char *msg, int max_length) {&#13;
    // 发送队列里是否还有没法完的数据&#13;
    bool pending = false;&#13;
    // 上锁&#13;
    std::lock_guard&lt;std::mutex&gt; lock(_send_lock);&#13;
    int send_que_size = _send_que.size();&#13;
    if (send_que_size &gt; MAX_SENDQUE) {&#13;
        std::cout &lt;&lt; 'session: ' &lt;&lt; _uuid &lt;&lt; ' send que fulled, size is ' &lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;&#13;
        return;&#13;
    }&#13;
&#13;
    // 加入发送队列&#13;
    _send_que.push(std::make_shared&lt;MsgNode&gt;(msg, max_length));&#13;
&#13;
    if (send_que_size &gt; 0) {&#13;
        // 之前的还没发送完&#13;
        return;&#13;
    }&#13;
    auto &amp;msgNode = _send_que.front();&#13;
    // 之前的全发完了，直接发本次的&#13;
    boost::asio::async_write(_socket, boost::asio::buffer(msgNode-&gt;_data, msgNode-&gt;_total_len),&#13;
                             std::bind(&amp;CSession::handle_write, this, std::placeholders::_1, shared_from_this()));&#13;
}&#13;
&#13;
// 打印二进制数据&#13;
void CSession::printRecvData(char *data, int length) {&#13;
    std::stringstream ss;&#13;
    std::string result = '0x';&#13;
    for (int i = 0; i &lt; length; i++) {&#13;
        std::string hexstr;&#13;
        ss &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; int(data[i]) &lt;&lt; std::endl;&#13;
        ss &gt;&gt; hexstr;&#13;
        result += hexstr;&#13;
    }&#13;
    std::cout &lt;&lt; 'receive raw data is : ' &lt;&lt; result &lt;&lt; std::endl;;&#13;
}&#13;
&#13;
void CSession::send(std::string msg) {&#13;
    std::lock_guard&lt;std::mutex&gt; lock(_send_lock);&#13;
&#13;
    int send_que_size = _send_que.size();&#13;
    if (send_que_size &gt; MAX_SENDQUE) {&#13;
        std::cout &lt;&lt; 'session: ' &lt;&lt; _uuid &lt;&lt; ' send que fulled, size is ' &lt;&lt; MAX_SENDQUE &lt;&lt; std::endl;&#13;
        return;&#13;
    }&#13;
    _send_que.push(std::make_shared&lt;MsgNode&gt;(msg.c_str(), msg.size()));&#13;
    if (send_que_size &gt; 0) {&#13;
        return;&#13;
    }&#13;
    auto &amp;msgNode = _send_que.front();&#13;
    boost::asio::async_write(_socket, boost::asio::buffer(msgNode-&gt;_data, msgNode-&gt;_total_len),&#13;
                             std::bind(&amp;CSession::handle_write, this, std::placeholders::_1, shared_from_this()));&#13;
}&#13;
&#13;
void CSession::handle_read_head(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                                std::shared_ptr&lt;CSession&gt; self_shared) {&#13;
    if (errorCode.value() != 0) {&#13;
        std::cerr &lt;&lt; 'Error occurred in read head: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
        // 移除连接&#13;
        _server-&gt;clear_session(_uuid);&#13;
        return;&#13;
    }&#13;
    if (bytes_transferred &lt; HEAD_LENGTH) {&#13;
        std::cerr &lt;&lt; 'Error occurred in read head: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
        // 移除连接&#13;
        _server-&gt;clear_session(_uuid);&#13;
        return;&#13;
    }&#13;
    // 解析包头数据&#13;
    short data_len = 0;&#13;
    memcpy(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);&#13;
    // 字节序处理&#13;
    data_len = boost::asio::detail::socket_ops::network_to_host_short(data_len);&#13;
    if (data_len &gt; MAX_LENGTH) {&#13;
        std::cerr &lt;&lt; 'Invalid data length :' &lt;&lt; data_len &lt;&lt; std::endl;&#13;
        _server-&gt;clear_session(_uuid);&#13;
        return;&#13;
    }&#13;
&#13;
&#13;
    _recv_msg_node = std::make_shared&lt;MsgNode&gt;(data_len);&#13;
&#13;
    boost::asio::async_read(_socket, boost::asio::buffer(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len),&#13;
                            std::bind(&amp;CSession::handle_read_msg, this, std::placeholders::_1, std::placeholders::_2,&#13;
                                      shared_from_this()));&#13;
}&#13;
&#13;
void CSession::handle_read_msg(const boost::system::error_code &amp;errorCode, size_t bytes_transferred,&#13;
                               std::shared_ptr&lt;CSession&gt; self_shared) {&#13;
    if (errorCode.value() != 0) {&#13;
        std::cerr &lt;&lt; 'Error occurred in read msg: ' &lt;&lt; errorCode.message() &lt;&lt; std::endl;&#13;
        // 移除连接&#13;
        _server-&gt;clear_session(_uuid);&#13;
        return;&#13;
    }&#13;
    // 测试粘包&#13;
    printRecvData(_recv_msg_node-&gt;_data, bytes_transferred);&#13;
    std::chrono::milliseconds dura(2000);&#13;
    std::this_thread::sleep_for(dura);&#13;
    _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = '\0';&#13;
    std::cout &lt;&lt; 'receive data is ' &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;&#13;
    send(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);&#13;
    // 再次接收头部数据&#13;
    _recv_head_node-&gt;clear();&#13;
    boost::asio::async_read(_socket, boost::asio::buffer(_recv_head_node-&gt;_data, HEAD_LENGTH),&#13;
                            std::bind(&amp;CSession::handle_read_head, this, std::placeholders::_1, std::placeholders::_2,&#13;
                                      shared_from_this()));&#13;
}&#13;
```。</description><guid isPermaLink="true">https://proacane.github.io/post/Asio-wang-luo-ku-zhai-yao.html</guid><pubDate>Mon, 23 Sep 2024 05:46:54 +0000</pubDate></item></channel></rss>